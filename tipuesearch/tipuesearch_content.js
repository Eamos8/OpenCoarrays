var tipuesearch = {"pages":[{"text":"OpenCoarrays Brief description ToDo Compilers Citations Brief description Warning The OpenCoarrays API documentation is currently underconstruction. As\nsuch, information may be missing orincomplete on this website. Please\ncheck back frequently for updated content. OpenCoarrays is an open-source software project that produces an\napplication binary interface ( ABI ) supporting coarray Fortran ( CAF )\ncompilers, an application programming interface ( API ) that supports\nusers of non- CAF compilers, and an associated compiler wrapper and\nprogram launcher. OpenCoarrays supports the coarray parallel programming feature set\nspecified in the Fortran 2008 standard.  We also support several\nfeatures proposed for Fortran 2015 in the draft Technical\nSpecification TS18508 Additional Parallel Features in Fortran. ToDo Add brief description text Macros should be passed on command line to FORD by build system MPI include should be passed on the command line (ideally,\n       although presently not supported) or specified by configuring this\n       file with CMake… Deal with include compiler_capabilities.txt Add documentation to libcaf.h Add documentation to libcaf-gfortran-descriptor.h Add documentation to mpi_caf.c Add documentation to caf_auxiliary.c Add documentation to opencoarrays Add documentation to single.c (or remove it…) Add documentation for unit tests Add documentation for integration tests Compilers The GNU Compiler Collection (GCC) Fortran front-end (GFortran) v. 5.1 and later employ OpenCoarrays to support parallel execution. Citations Please acknowledge the use of OpenCoarrays by citing the following publication: Fanfarillo, A., Burnus, T., Cardellini, V., Filippone, S., Nagle, D., & Rouson, D. (2014, October). OpenCoarrays: open-source transport layers supporting coarray Fortran compilers. In Proceedings of the 8th International Conference on Partitioned Global Address Space Programming Models (p. 4). ACM.﻿ ((window.gitter = {}).chat = {}).options = {\n            room: 'sourceryinstitute/opencoarrays'\n            }; Developer Info Sourcery Institute Sourcery Institute is a California public-benefit nonprofit corporation engaged in research, education, and consulting in computational science, engineering, and mathematics (CSEM).  We are a network of independent CSEM professionals who research and develop advanced software engineering methods, tools, and libraries for CSEM.  We teach related short courses and university courses.   We also lead and contribute to open-source software and open language standards used in CSEM fields.","tags":"","loc":"index.html","title":" OpenCoarrays "},{"text":"Source Code ! Fortran 2015 feature support for Fortran 2008 compilers ! ! Copyright (c) 2015-2016, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! module opencoarrays #ifdef COMPILER_SUPPORTS_ATOMICS use iso_fortran_env , only : atomic_int_kind #endif use iso_c_binding , only : c_int , c_char , c_ptr , c_loc , c_double , c_int32_t , c_ptrdiff_t , c_sizeof , c_bool , c_funloc implicit none private public :: co_reduce public :: co_broadcast public :: co_sum public :: co_min public :: co_max public :: this_image public :: num_images public :: error_stop public :: sync_all #ifdef COMPILER_SUPPORTS_ATOMICS public :: event_type public :: event_post type event_type private integer ( atomic_int_kind ), allocatable :: atom [:] end type #endif ! Generic interface to co_broadcast with implementations for various types, kinds, and ranks interface co_reduce module procedure co_reduce_c_int , co_reduce_c_double , co_reduce_logical end interface ! Generic interface to co_broadcast with implementations for various types, kinds, and ranks interface co_broadcast module procedure co_broadcast_c_int , co_broadcast_c_double , co_broadcast_c_char end interface ! Generic interface to co_sum with implementations for various types, kinds, and ranks interface co_sum module procedure co_sum_c_int , co_sum_c_double end interface ! Generic interface to co_sum with implementations for various types, kinds, and ranks interface co_min module procedure co_min_c_int , co_min_c_double end interface ! Generic interface to co_sum with implementations for various types, kinds, and ranks interface co_max module procedure co_max_c_int , co_max_c_double end interface abstract interface pure function c_int_operator ( lhs , rhs ) result ( lhs_op_rhs ) import c_int integer ( c_int ), intent ( in ) :: lhs , rhs integer ( c_int ) :: lhs_op_rhs end function pure function c_double_operator ( lhs , rhs ) result ( lhs_op_rhs ) import c_double real ( c_double ), intent ( in ) :: lhs , rhs real ( c_double ) :: lhs_op_rhs end function pure function logical_operator ( lhs , rhs ) result ( lhs_op_rhs ) logical , intent ( in ) :: lhs , rhs logical :: lhs_op_rhs end function end interface ! __________ End Public Interface _____________ ! __________ Begin Private Implementation _____ ! Enumeration from ../libcaf-gfortran-descriptor.h: !  enum !{ BT_UNKNOWN = 0, BT_INTEGER, BT_LOGICAL, BT_REAL, BT_COMPLEX, !  BT_DERIVED, BT_CHARACTER, BT_CLASS, BT_PROCEDURE, BT_HOLLERITH, BT_VOID, !  BT_ASSUMED !}; enum , bind ( C ) enumerator :: & BT_UNKNOWN = 0 , BT_INTEGER , BT_LOGICAL , BT_REAL , BT_COMPLEX , & BT_DERIVED , BT_CHARACTER , BT_CLASS , BT_PROCEDURE , BT_HOLLERITH , BT_VOID , & BT_ASSUMED end enum ! Type definition from ../libcaf-gfortran-descriptor.h: !typedef struct descriptor_dimension !{ !  ptrdiff_t _stride; !  ptrdiff_t lower_bound; !  ptrdiff_t _ubound; !} !descriptor_dimension; ! Fortran derived type interoperable with like-named C type: type , bind ( C ) :: descriptor_dimension integer ( c_ptrdiff_t ) :: stride integer ( c_ptrdiff_t ) :: lower_bound integer ( c_ptrdiff_t ) :: ubound_ end type ! Type definition from ../libcaf-gfortran-descriptor.h: !typedef struct gfc_descriptor_t { !  void *base_addr; !  size_t offset; !  ptrdiff_t dtype; !  descriptor_dimension dim[]; !} gfc_descriptor_t; integer , parameter :: max_dimensions = 15 ! Fortran derived type interoperable with like-named C type: type , bind ( C ) :: gfc_descriptor_t type ( c_ptr ) :: base_addr integer ( c_ptrdiff_t ) :: offset integer ( c_ptrdiff_t ) :: dtype type ( descriptor_dimension ) :: dim_ ( max_dimensions ) end type ! C comment and source from ../libcaf.h ! /* When there is a vector subscript in this dimension, nvec == 0, otherwise, ! lower_bound, upper_bound, stride contains the bounds relative to the declared ! bounds; kind denotes the integer kind of the elements of vector[].  */ ! type, bind(C) :: caf_vector_t { !   size_t nvec; !   union { !     struct { !       void *vector; !       int kind; !     } v; !     struct { !       ptrdiff_t lower_bound, upper_bound, stride; !     } triplet; !   } u; ! } ! caf_vector_t; type , bind ( C ) :: v_t type ( c_ptr ) :: vector integer ( c_int ) :: kind_ end type type , bind ( C ) :: triplet_t integer ( c_ptrdiff_t ) :: lower_bound , upper_bound , stride end type type , bind ( C ) :: u_t type ( v_t ) :: v type ( triplet_t ) :: triplet end type type , bind ( C ) :: caf_vector_t integer ( c_ptrdiff_t ) :: nvec type ( u_t ) :: u end type ! -------------------- integer ( c_int ), save , volatile , bind ( C , name = \"CAF_COMM_WORLD\" ) :: CAF_COMM_WORLD integer ( c_int32_t ), parameter :: bytes_per_word = 4_c_int32_t interface gfc_descriptor module procedure gfc_descriptor_c_int , gfc_descriptor_c_double , gfc_descriptor_logical end interface ! Bindings for OpenCoarrays C procedures interface ! C function signature from ../mpi/mpi_caf.c: ! void ! PREFIX (co_min) (gfc_descriptor_t *a, int result_image, int *stat, char *errmsg, !                  int src_len, int errmsg_len) #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_co_min ( a , result_image , stat , errmsg , unused , errmsg_len ) bind ( C , name = \"_caf_extensions_co_min\" ) #else subroutine opencoarrays_co_min ( a , result_image , stat , errmsg , unused , errmsg_len ) bind ( C , name = \"_gfortran_caf_co_min\" ) #endif import :: c_int , c_char , c_ptr type ( c_ptr ), intent ( in ), value :: a integer ( c_int ), intent ( in ), value :: result_image , errmsg_len , unused integer ( c_int ), intent ( out ), optional , volatile :: stat character ( kind = c_char ), intent ( out ), optional , volatile :: errmsg ( * ) end subroutine ! C function signature from ../mpi/mpi_caf.c ! void ! PREFIX (co_reduce) (gfc_descriptor_t *a, void *(*opr) (void *, void *), int opr_flags, !                     int result_image, int *stat, char *errmsg, int a_len, int errmsg_len) subroutine opencoarrays_co_reduce ( a , opr , opr_flags , result_image , stat , errmsg , a_len , errmsg_len ) & #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS bind ( C , name = \"_caf_extensions_co_reduce\" ) #else bind ( C , name = \"_gfortran_caf_co_reduce\" ) #endif use iso_c_binding , only : c_ptr , c_funptr , c_int , c_char type ( c_ptr ), intent ( in ), value :: a type ( c_funptr ), intent ( in ), value :: opr integer ( c_int ), intent ( in ), value :: opr_flags , result_image integer ( c_int ), intent ( out ) :: stat character ( kind = c_char ), intent ( out ), optional , volatile :: errmsg ( * ) integer ( c_int ), intent ( in ), value :: a_len integer ( c_int ), intent ( in ), value :: errmsg_len end subroutine ! C function signature from ../mpi/mpi_caf.c: ! void ! PREFIX (get) (caf_token_t token, size_t offset, !              int image_index, !              gfc_descriptor_t *src , !              caf_vector_t *src_vector __attribute__ ((unused)), !              gfc_descriptor_t *dest, int src_kind, int dst_kind, !              bool mrt) subroutine opencoarrays_get ( token , offset , image_index_ , src , src_vector_unused , dest , src_kind , dst_kind , mrt ) & #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS bind ( C , name = \"_caf_extensions_get\" ) #else bind ( C , name = \"_gfortran_caf_get\" ) #endif import c_ptrdiff_t , c_int , gfc_descriptor_t , c_bool , caf_vector_t , c_ptr type ( c_ptr ), value :: token integer ( c_ptrdiff_t ), value :: offset integer ( c_int ), value :: image_index_ type ( gfc_descriptor_t ) :: src type ( caf_vector_t ) :: src_vector_unused type ( gfc_descriptor_t ) :: dest integer ( c_int ), value :: src_kind integer ( c_int ), value :: dst_kind logical ( c_bool ), value :: mrt end subroutine ! C function signature from ../mpi/mpi_caf.c: ! void ! PREFIX (co_max) (gfc_descriptor_t *a, int result_image, int *stat, !                  char *errmsg, int src_len, int errmsg_len) #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_co_max ( a , result_image , stat , errmsg , unused , errmsg_len ) bind ( C , name = \"_caf_extensions_co_max\" ) #else subroutine opencoarrays_co_max ( a , result_image , stat , errmsg , unused , errmsg_len ) bind ( C , name = \"_gfortran_caf_co_max\" ) #endif import :: c_int , c_char , c_ptr type ( c_ptr ), intent ( in ), value :: a integer ( c_int ), intent ( in ), value :: result_image , errmsg_len , unused integer ( c_int ), intent ( out ), optional :: stat character ( kind = c_char ), intent ( out ), optional :: errmsg ( * ) end subroutine ! C function signature from ../mpi/mpi_caf.c: ! void ! PREFIX (co_sum) (gfc_descriptor_t *a, int result_image, int *stat, char *errmsg, !                  int errmsg_len) #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_co_sum ( a , result_image , stat , errmsg , errmsg_len ) bind ( C , name = \"_caf_extensions_co_sum\" ) #else subroutine opencoarrays_co_sum ( a , result_image , stat , errmsg , errmsg_len ) bind ( C , name = \"_gfortran_caf_co_sum\" ) #endif import :: c_int , c_char , c_ptr type ( c_ptr ), intent ( in ), value :: a integer ( c_int ), intent ( in ), value :: result_image , errmsg_len integer ( c_int ), intent ( out ), optional :: stat character ( kind = c_char ), intent ( out ), optional :: errmsg ( * ) end subroutine ! C function signature from ../mpi/mpi_caf.c ! void ! PREFIX (co_broadcast) (gfc_descriptor_t *a, int source_image, int *stat, char *errmsg, !                  int errmsg_len) #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_co_broadcast ( a , source_image , stat , errmsg , errmsg_len ) bind ( C , name = \"_caf_extensions_co_broadcast\" ) #else subroutine opencoarrays_co_broadcast ( a , source_image , stat , errmsg , errmsg_len ) bind ( C , name = \"_gfortran_caf_co_broadcast\" ) #endif import :: c_int , c_char , c_ptr type ( c_ptr ), intent ( in ), value :: a integer ( c_int ), intent ( in ), value :: source_image , errmsg_len integer ( c_int ), intent ( out ), optional :: stat character ( kind = c_char ), intent ( out ), optional :: errmsg ( * ) end subroutine ! C function signature from ../mpi/mpi_caf.c: ! int PREFIX (this_image) (int); function opencoarrays_this_image ( coarray ) bind ( C , name = \"_gfortran_caf_this_image\" ) result ( image_num ) import :: c_int integer ( c_int ), value , intent ( in ) :: coarray integer ( c_int ) :: image_num end function ! C function signature from ../mpi/mpi_caf.c: ! int PREFIX (num_images) (int, int); function opencoarrays_num_images ( coarray , dim_ ) bind ( C , name = \"_gfortran_caf_num_images\" ) result ( num_images_ ) import :: c_int integer ( c_int ), value , intent ( in ) :: coarray , dim_ integer ( c_int ) :: num_images_ end function ! C function signature from ../mpi_caf.c ! void PREFIX (error_stop) (int32_t) __attribute__ ((noreturn)); #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_error_stop ( stop_code ) bind ( C , name = \"_caf_extensions_error_stop\" ) #else subroutine opencoarrays_error_stop ( stop_code ) bind ( C , name = \"_gfortran_caf_error_stop\" ) #endif import :: c_int32_t integer ( c_int32_t ), value , intent ( in ) :: stop_code end subroutine ! C function signature from ../mpi_caf.c ! void PREFIX (sync_all) (int *, char *, int); #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS subroutine opencoarrays_sync_all ( stat , errmsg , unused ) bind ( C , name = \"_caf_extensions_sync_all\" ) #else subroutine opencoarrays_sync_all ( stat , errmsg , unused ) bind ( C , name = \"_gfortran_caf_sync_all\" ) #endif import :: c_int , c_char integer ( c_int ), intent ( out ) :: stat , unused character ( c_char ), intent ( out ) :: errmsg ( * ) end subroutine end interface contains ! __________ Descriptor constructors for for each supported type and kind ____________ ! ____________________________________________________________________________________ function my_dtype ( type_ , kind_ , rank_ ) result ( dtype_ ) integer , parameter :: GFC_DTYPE_SIZE_SHIFT = 8 , GFC_DTYPE_TYPE_SHIFT = 3 integer ( c_int32_t ), intent ( in ) :: type_ , kind_ , rank_ integer ( c_int32_t ) :: dtype_ ! SIZE Type Rank ! 0000  000  000 ! Rank is represented in the 3 least significant bits dtype_ = ior ( 0_c_int32_t , rank_ ) ! The next three bits represent the type id as expressed in libcaf-gfortran-descriptor.h dtype_ = ior ( dtype_ , ishft ( type_ , GFC_DTYPE_TYPE_SHIFT )) ! The most significant bits represent the size of a the type (single or double precision). ! We can express the precision in terms of 32-bit words: 1 for single, 2 for double. dtype_ = ior ( dtype_ , ishft ( kind_ , GFC_DTYPE_SIZE_SHIFT )) end function function gfc_descriptor_c_int ( a ) result ( a_descriptor ) integer ( c_int ), intent ( in ), target , contiguous :: a (..) type ( gfc_descriptor_t ) :: a_descriptor integer ( c_int ), parameter :: unit_stride = 1 , scalar_offset =- 1 integer ( c_int ) :: i a_descriptor % dtype = my_dtype ( type_ = BT_INTEGER , kind_ = int ( c_sizeof ( a ) / bytes_per_word , c_int32_t ), rank_ = rank ( a )) a_descriptor % offset = scalar_offset a_descriptor % base_addr = c_loc ( a ) ! data do concurrent ( i = 1 : rank ( a )) a_descriptor % dim_ ( i )% stride = unit_stride a_descriptor % dim_ ( i )% lower_bound = lbound ( a , i ) a_descriptor % dim_ ( i )% ubound_ = ubound ( a , i ) end do end function function gfc_descriptor_logical ( a ) result ( a_descriptor ) logical , intent ( in ), target , contiguous :: a (..) type ( gfc_descriptor_t ) :: a_descriptor integer ( c_int ), parameter :: unit_stride = 1 , scalar_offset =- 1 , words = 1 integer ( c_int ) :: i a_descriptor % dtype = my_dtype ( type_ = BT_LOGICAL , kind_ = words , rank_ = rank ( a )) a_descriptor % offset = scalar_offset a_descriptor % base_addr = c_loc ( a ) ! data do concurrent ( i = 1 : rank ( a )) a_descriptor % dim_ ( i )% stride = unit_stride a_descriptor % dim_ ( i )% lower_bound = lbound ( a , i ) a_descriptor % dim_ ( i )% ubound_ = ubound ( a , i ) end do end function function gfc_descriptor_c_double ( a ) result ( a_descriptor ) real ( c_double ), intent ( in ), target , contiguous :: a (..) type ( gfc_descriptor_t ) :: a_descriptor integer ( c_int ), parameter :: unit_stride = 1 , scalar_offset =- 1 integer ( c_int ) :: i a_descriptor % dtype = my_dtype ( type_ = BT_REAL , kind_ = int ( c_sizeof ( a ) / bytes_per_word , c_int32_t ), rank_ = rank ( a )) a_descriptor % offset = scalar_offset a_descriptor % base_addr = c_loc ( a ) ! data do concurrent ( i = 1 : rank ( a )) a_descriptor % dim_ ( i )% stride = unit_stride a_descriptor % dim_ ( i )% lower_bound = lbound ( a , i ) a_descriptor % dim_ ( i )% ubound_ = ubound ( a , i ) end do end function ! This version should work for any rank but causes an ICE with gfortran 4.9.2 ! !function gfc_descriptor_c_char(a) result(a_descriptor) !  character(c_char), intent(in), target, contiguous :: a(..) !  type(gfc_descriptor_t) :: a_descriptor !  integer(c_int), parameter :: unit_stride=1,scalar_offset=-1 !  integer(c_int) :: i !  a_descriptor%dtype = my_dtype(type_=BT_CHARACTER,kind_=int(c_sizeof(a)/bytes_per_word,c_int32_t),rank_=rank(a)) !  a_descriptor%offset = scalar_offset !  a_descriptor%base_addr = c_loc(a) ! data !  do concurrent(i=1:rank(a)) !    a_descriptor%dim_(i)%stride  = unit_stride !    a_descriptor%dim_(i)%lower_bound = lbound(a,i) !    a_descriptor%dim_(i)%ubound_ = ubound(a,i) !  end do !end function ! ______ Assumed-rank co_reduce wrappers for each supported type and kind _________ ! _________________________________________________________________________________ subroutine co_reduce_c_int ( a , opr , result_image , stat , errmsg ) ! Dummy variables integer ( c_int ), intent ( inout ), volatile , contiguous :: a (..) procedure ( c_int_operator ) :: opr integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional , volatile :: stat character ( kind = c_char ), intent ( out ), optional , volatile :: errmsg ( * ) ! Local variables integer ( c_int ), volatile :: opr_flags_unused , a_len_unused , errmsg_len type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: result_image_ result_image_ = merge ( result_image , default_result_image , present ( result_image )) a_descriptor = gfc_descriptor ( a ) call opencoarrays_co_reduce ( & c_loc ( a_descriptor ), c_funloc ( opr ), opr_flags_unused , result_image_ , stat , errmsg , a_len_unused , errmsg_len & ) end subroutine subroutine co_reduce_logical ( a , opr , result_image , stat , errmsg ) ! Dummy variables logical , intent ( inout ), volatile , contiguous :: a (..) procedure ( logical_operator ) :: opr integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional , volatile :: stat character ( kind = c_char ), intent ( out ), optional , volatile :: errmsg ( * ) ! Local variables integer ( c_int ), volatile :: opr_flags_unused , a_len_unused , errmsg_len type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: result_image_ result_image_ = merge ( result_image , default_result_image , present ( result_image )) a_descriptor = gfc_descriptor ( a ) call opencoarrays_co_reduce ( & c_loc ( a_descriptor ), c_funloc ( opr ), opr_flags_unused , result_image_ , stat , errmsg , a_len_unused , errmsg_len & ) end subroutine subroutine co_reduce_c_double ( a , opr , result_image , stat , errmsg ) ! Dummy variables real ( c_double ), intent ( inout ), volatile , contiguous :: a (..) procedure ( c_double_operator ) :: opr integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional , volatile :: stat character ( kind = c_char ), intent ( out ), optional , volatile :: errmsg ( * ) ! Local variables integer ( c_int ), volatile :: opr_flags_unused , a_len_unused , errmsg_len type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: result_image_ result_image_ = merge ( result_image , default_result_image , present ( result_image )) a_descriptor = gfc_descriptor ( a ) call opencoarrays_co_reduce ( & c_loc ( a_descriptor ), c_funloc ( opr ), opr_flags_unused , result_image_ , stat , errmsg , a_len_unused , errmsg_len & ) end subroutine ! ______ Assumed-rank co_broadcast wrappers for each supported type and kind _________ ! ____________________________________________________________________________________ ! This provisional implementation incurs some overhead by converting the character argument ! to an integer(c_int) array, invoking co_broadcast_c_int and then convering the received ! message back from the integer(c_int) array to a character variable. ! ! Replace this implementation with one that avoids the conversions and the associated copies ! once the compiler provides support for co_broadcast with scalar arguments. ! subroutine co_broadcast_c_char ( a , source_image , stat , errmsg ) character ( kind = c_char , len =* ), intent ( inout ), volatile , target :: a integer ( c_int ), intent ( in ), optional :: source_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: integer ( c_int ), allocatable :: a_cast_to_integer_array (:) ! Convert \"a\" to an integer(c_int) array where each 32-bit integer element holds four 1-byte characters a_cast_to_integer_array = transfer ( a ,[ 0_c_int ]) ! Broadcast the integer(c_int) array call co_broadcast_c_int ( a_cast_to_integer_array , source_image , stat , errmsg ) ! Recover the characters from the broadcasted integer(c_int) array a = transfer ( a_cast_to_integer_array , repeat ( ' ' , len ( a ))) end subroutine subroutine co_broadcast_c_double ( a , source_image , stat , errmsg ) real ( c_double ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: source_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants integer ( c_int ), parameter :: default_source_image = 0 integer ( c_int ) :: source_image_ ! Local replacement for the corresponding intent(in) dummy argument type ( gfc_descriptor_t ), target :: a_descriptor source_image_ = merge ( source_image , default_source_image , present ( source_image )) a_descriptor = gfc_descriptor ( a ) call opencoarrays_co_broadcast ( c_loc ( a_descriptor ), source_image_ , stat , errmsg , len ( errmsg )) end subroutine subroutine co_broadcast_c_int ( a , source_image , stat , errmsg ) integer ( c_int ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: source_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: integer ( c_int ), parameter :: default_source_image = 0 integer ( c_int ) :: source_image_ ! Local replacement for the corresponding intent(in) dummy argument type ( gfc_descriptor_t ), target :: a_descriptor source_image_ = merge ( source_image , default_source_image , present ( source_image )) a_descriptor = gfc_descriptor ( a ) call opencoarrays_co_broadcast ( c_loc ( a_descriptor ), source_image_ , stat , errmsg , len ( errmsg )) end subroutine ! ________ Assumed-rank get wrappers for each supported type and kind ________________ ! ________ (Incomplete, private and unsupported) _____________________________________ ! ____________________________________________________________________________________ subroutine get_c_int ( src , dest , image_index_ , offset , mrt ) use iso_fortran_env , only : error_unit ! Dummy arguments: integer ( c_int ), intent ( in ), target , contiguous :: src (..) integer ( c_int ), intent ( out ), target , contiguous , volatile :: dest (..) integer ( c_int ), intent ( in ) :: image_index_ integer ( c_ptrdiff_t ), intent ( in ) :: offset logical ( c_bool ), intent ( in ) :: mrt ! Local variables: type ( gfc_descriptor_t ), target , volatile :: dest_descriptor type ( gfc_descriptor_t ), target :: src_descriptor type ( caf_vector_t ) :: src_vector_unused type ( c_ptr ) :: token write ( error_unit , * ) \"Remote access of coarrays not yet supported\" call error_stop src_descriptor = gfc_descriptor ( src ) dest_descriptor = gfc_descriptor ( dest ) call opencoarrays_get ( & token , offset , image_index_ , src_descriptor , src_vector_unused , dest_descriptor , kind ( src ), kind ( dest ), mrt & ) end subroutine ! ________ Assumed-rank co_min wrappers for each supported type and kind _____________ ! ____________________________________________________________________________________ subroutine co_min_c_int ( a , result_image , stat , errmsg ) integer ( c_int ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: unused , result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_min ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , unused , len ( errmsg )) end subroutine subroutine co_min_c_double ( a , result_image , stat , errmsg ) real ( c_double ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: unused , result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_min ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , unused , len ( errmsg )) end subroutine ! ________ Assumed-rank co_max wrappers for each supported type and kind _____________ ! ____________________________________________________________________________________ subroutine co_max_c_int ( a , result_image , stat , errmsg ) integer ( c_int ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: unused , result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_max ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , unused , len ( errmsg )) end subroutine subroutine co_max_c_double ( a , result_image , stat , errmsg ) real ( c_double ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: unused , result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_max ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , unused , len ( errmsg )) end subroutine ! ________ Assumed-rank co_sum wrappers for each supported type and kind _____________ ! ____________________________________________________________________________________ subroutine co_sum_c_double ( a , result_image , stat , errmsg ) real ( c_double ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ), parameter :: default_result_image = 0 integer ( c_int ) :: result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_sum ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , len ( errmsg )) end subroutine subroutine co_sum_c_int ( a , result_image , stat , errmsg ) integer ( c_int ), intent ( inout ), volatile , target , contiguous :: a (..) integer ( c_int ), intent ( in ), optional :: result_image integer ( c_int ), intent ( out ), optional :: stat character ( kind = 1 , len =* ), intent ( out ), optional :: errmsg ! Local variables and constants: integer ( c_int ), parameter :: default_result_image = 0 type ( gfc_descriptor_t ), target :: a_descriptor integer ( c_int ) :: result_image_ ! Local replacement for the corresponding intent(in) dummy argument a_descriptor = gfc_descriptor ( a ) result_image_ = merge ( result_image , default_result_image , present ( result_image )) call opencoarrays_co_sum ( c_loc ( a_descriptor ), result_image_ , stat , errmsg , len ( errmsg )) end subroutine ! Return the image number (MPI rank + 1) function this_image () result ( image_num ) use mpi , only : MPI_Comm_rank integer ( c_int ) :: image_num , ierr !image_num = opencoarrays_this_image(unused) call MPI_Comm_rank ( CAF_COMM_WORLD , image_num , ierr ) if ( ierr /= 0 ) call error_stop image_num = image_num + 1 end function ! Return the total number of images function num_images () result ( num_images_ ) use mpi , only : MPI_Comm_size integer ( c_int ) :: num_images_ , ierr !num_images_ = opencoarrays_num_images(unused_coarray,unused_scalar) call MPI_Comm_size ( CAF_COMM_WORLD , num_images_ , ierr ) if ( ierr /= 0 ) call error_stop end function ! Halt the execution of all images subroutine error_stop ( stop_code ) integer ( c_int32_t ), intent ( in ), optional :: stop_code integer ( c_int32_t ), parameter :: default_code =- 1_c_int32_t integer ( c_int32_t ) :: code code = merge ( stop_code , default_code , present ( stop_code )) call opencoarrays_error_stop ( code ) end subroutine ! Impose a global execution barrier subroutine sync_all ( stat , errmsg , unused ) integer ( c_int ), intent ( out ), optional :: stat , unused character ( c_char ), intent ( out ), optional :: errmsg call opencoarrays_sync_all ( stat , errmsg , unused ) end subroutine #ifdef COMPILER_SUPPORTS_ATOMICS ! Proposed Fortran 2015 event_post procedure subroutine event_post ( this ) class ( event_type ), intent ( inout ) :: this if (. not . allocated ( this % atom )) this % atom = 0 call atomic_define ( this % atom , this % atom + 1_atomic_int_kind ) end subroutine #endif end module","tags":"","loc":"sourcefile/opencoarrays.f90.html","title":"opencoarrays.F90 – OpenCoarrays"},{"text":"e tests/coarrayHelloWorld/hello_multiverse.F90\n NAME\n   hello_multiverse\n SYNOPSIS\n   Demonstrate coarray communication via a scalar character coarray.\n INPUTS\n   None.\n OUTPUTS\n   Test pass or failure. *** Source Code ! Coarray \"Hello, world!\" test program ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! Robodoc header: !****e* tests/coarrayHelloWorld/hello_multiverse.F90 ! NAME !   hello_multiverse ! SYNOPSIS !   Demonstrate coarray communication via a scalar character coarray. ! INPUTS !   None. ! OUTPUTS !   Test pass or failure. !****** program hello_multiverse implicit none integer , parameter :: MAX_STRING = 100 character ( len = MAX_STRING ) :: greeting [ * ] ! Scalar coarray integer image write ( greeting , \"(2(a,i2))\" ) \"Greetings from image \" , this_image (), \" of \" , num_images () sync all ! Barrier if ( this_image () == 1 ) then do concurrent ( image = 1 : num_images ()) print * , greeting [ image ] end do block integer , parameter :: expected_location = 23 , max_single_digit = 9 do image = 2 , min ( num_images (), max_single_digit ) ! Verify that the greetings of images 1-9 have their image number at the expected location: if ( scan ( greeting [ image ], set = \"123456789\" ) /= expected_location ) error stop \"Test failed.\" end do end block print * , \"Test passed.\" end if end program","tags":"","loc":"sourcefile/hello_multiverse.f90.html","title":"hello_multiverse.F90 – OpenCoarrays"},{"text":"m dist_transpose/run_size\n NAME\n   run_size\n  SYNOPSIS\n   Encapsulate problem state, wall-clock timer interface, integer broadcasts, and a data copy. ==================  test transposes with integer x,y,z values  =============================== e* dist_transpose/coarray_distributed_transpose\n NAME\n   coarray_distributed_transpose\n SYNOPSIS\n   This program tests the transpose routines used in Fourier-spectral simulations of homogeneous turbulence.\n   The data is presented to the physics routines as groups of y-z or x-z planes distributed among the images.\n   The (out-of-place) transpose routines do the x <–> y transposes required and consist of transposes within\n   data blocks (intra-image) and a transpose of the distribution of these blocks among the images (inter-image). Two methods are tested here:\n   RECEIVE: receive block from other image and transpose it\n   SEND:    transpose block and send it to other image This code is the coarray analog of mpi_distributed_transpose. Source Code ! Coarray Distributed Transpose Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! ! Robodoc header: !****m* dist_transpose/run_size ! NAME !   run_size !  SYNOPSIS !   Encapsulate problem state, wall-clock timer interface, integer broadcasts, and a data copy. !****** !==================  test transposes with integer x,y,z values  =============================== module run_size use iso_fortran_env #ifndef HAVE_WALLTIME use MPI , only : WALLTIME => MPI_WTIME #endif implicit none integer ( int64 ), codimension [ * ] :: nx , ny , nz integer ( int64 ), codimension [ * ] :: my , mx , first_y , last_y , first_x , last_x integer ( int64 ) :: my_node , num_nodes real ( real64 ), codimension [ * ] :: tran_time #ifdef HAVE_WALLTIME interface function WALLTIME () bind ( C , name = \"WALLTIME\" ) use iso_fortran_env real ( real64 ) :: WALLTIME end function WALLTIME end interface #endif contains !****s* run_size/broadcast_int ! NAME !   broadcast_int !  SYNOPSIS !   Broadcast a scalar coarray integer from image 1 to all other images. !****** subroutine broadcast_int ( variable ) integer ( int64 ), codimension [ * ] :: variable integer ( int64 ) :: i if ( my_node == 1 ) then do i = 2 , num_nodes ; variable [ i ] = variable ; end do end if end subroutine broadcast_int subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3 end module run_size !****e* dist_transpose/coarray_distributed_transpose ! NAME !   coarray_distributed_transpose ! SYNOPSIS !   This program tests the transpose routines used in Fourier-spectral simulations of homogeneous turbulence. !   The data is presented to the physics routines as groups of y-z or x-z planes distributed among the images. !   The (out-of-place) transpose routines do the x <--> y transposes required and consist of transposes within !   data blocks (intra-image) and a transpose of the distribution of these blocks among the images (inter-image). ! !   Two methods are tested here: !   RECEIVE: receive block from other image and transpose it !   SEND:    transpose block and send it to other image ! !   This code is the coarray analog of mpi_distributed_transpose. !****** program coarray_distributed_transpose !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use run_size implicit none complex , allocatable :: u (:,:,:,:)[:] ! u(nz,4,first_x:last_x,ny)[*]    !(*-- ny = my * num_nodes --*) complex , allocatable :: ur (:,:,:,:)[:] !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- nx/2 = mx * num_nodes --*) complex , allocatable :: bufr_X_Y (:,:,:,:) complex , allocatable :: bufr_Y_X (:,:,:,:) integer ( int64 ) :: x , y , z , msg_size , iter num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then !write(6,*) \"nx,ny,nz : \";      read(5,*) nx, ny, nz nx = 32 ; ny = 32 ; nz = 32 call broadcast_int ( nx ); call broadcast_int ( ny ); call broadcast_int ( nz ); end if sync all !-- other nodes wait for broadcast! if ( mod ( ny , num_nodes ) == 0 ) then ; my = ny / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \" ny not multiple of num_nodes\" ; error stop end if if ( mod ( nx / 2 , num_nodes ) == 0 ) then ; mx = nx / 2 / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \"nx/2 not multiple of num_nodes\" ; error stop end if first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx allocate ( u ( nz , 4 , first_x : last_x , ny ) [ * ] ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 )[ * ] ) !(*-- x-z planes --*) allocate ( bufr_X_Y ( nz , 4 , mx , my ) ) allocate ( bufr_Y_X ( nz , 4 , my , mx ) ) msg_size = nz * 4 * mx * my !-- message size (complex data items) !---------  initialize data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz u ( z , 1 , x , y ) = x u ( z , 2 , x , y ) = y u ( z , 3 , x , y ) = z end do end do end do tran_time = 0 do iter = 1 , 2 !--- 2 transform pairs per second-order time step !---------  transpose data u -> ur (mx y-z planes to my x-z planes per image)  -------- ur = 0 call transpose_X_Y !--------- test data ur (my x-z planes per image) ---------- do x = 1 , nx / 2 do y = first_y , last_y do z = 1 , nz if ( real ( ur ( z , 1 , y , x )) /= x . or . real ( ur ( z , 2 , y , x )) /= y . or . real ( ur ( z , 3 , y , x )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_X_Y failed:  image \" , my_node & , \" X \" , real ( ur ( z , 1 , y , x )), x , \"  Y \" , real ( ur ( z , 2 , y , x )), y , \"  Z \" , real ( ur ( z , 3 , y , x )), z stop end if end do end do end do !---------  transpose data ur -> u (my x-z planes to mx y-z planes per image)  -------- u = 0 call transpose_Y_X !--------- test data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( real ( u ( z , 1 , x , y )) /= x . or . real ( u ( z , 2 , x , y )) /= y . or . real ( u ( z , 3 , x , y )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_Y_X failed:  image \" , my_node & , \" X \" , real ( u ( z , 1 , x , y )), x , \"  Y \" , real ( u ( z , 2 , x , y )), y , \"  Z \" , real ( u ( z , 3 , x , y )), z stop end if end do end do end do end do sync all if ( my_node == 1 ) write ( 6 , fmt = \"(A,f8.3)\" ) \"test passed:  tran_time \" , tran_time deallocate ( bufr_X_Y ); deallocate ( bufr_Y_X ) !=========================   end of main executable  ============================= contains !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ), bufr_Y_X & !-- intra-node transpose to buffer , nz * 3 , 1 _ 8 , 1 _ 8 & , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] = bufr_Y_X (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ), bufr_X_Y & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] = bufr_X_Y (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_Y_X end program coarray_distributed_transpose","tags":"","loc":"sourcefile/coarray_distributed_transpose.f90.html","title":"coarray_distributed_transpose.F90 – OpenCoarrays"},{"text":"Source Code module global_field_module use iso_fortran_env , only : real64 , int64 use co_object_interface , only : co_object use ForTrilinos_assertion_utility , only : assert , error_message use local_field_module , only : local_field implicit none private public :: global_field , initial_condition type , extends ( co_object ) :: global_field private real ( real64 ), allocatable :: values (:)[:] contains procedure :: set procedure :: state procedure :: x procedure :: xx procedure , nopass :: grid_spacing procedure , private :: assign_local_field procedure , private :: add_local_field procedure , private :: multiply generic :: operator ( * ) => multiply generic :: operator ( + ) => add_local_field generic :: assignment ( = ) => assign_local_field procedure :: output end type abstract interface pure function initial_condition ( x ) result ( initial_values ) import :: real64 real ( real64 ), intent ( in ) :: x real ( real64 ) :: initial_values end function end interface real ( real64 ), allocatable :: dx integer ( int64 ), allocatable :: num_global_points , num_local_points integer ( int64 ), parameter :: num_end_points = 2_int64 real ( real64 ) :: boundary_vals ( num_end_points ) contains function grid_spacing () result ( delta_x ) real ( real64 ) :: delta_x call assert ( allocated ( dx ), error_message ( \"global_field%grid_spacing: dx not allocated\" )) delta_x = dx end function pure function state ( this ) result ( local_values ) class ( global_field ), intent ( in ) :: this real ( real64 ), allocatable :: local_values (:) ! Requires if ( this % user_defined ()) then local_values = this % values end if end function subroutine synchronize () if ( num_images () > 1 ) then associate ( me => this_image ()) if ( me == 1 ) then sync images ( me + 1 ) else if ( me == num_images ()) then sync images ( me - 1 ) else sync images ([ me - 1 , me + 1 ]) end if end associate end if end subroutine subroutine set ( this , initial_function , num_points ) class ( global_field ), intent ( inout ) :: this integer , intent ( in ) :: num_points procedure ( initial_condition ), pointer :: initial_function integer ( int64 ) :: num_intervals , i real ( real64 ), parameter :: two_pi = 2. * 3.1415926535897932384626433832795028842_real64 real ( real64 ), allocatable :: local_grid (:) ! Requires call assert ( mod ( num_points , num_images ()) == 0 , error_message ( \"global_field%set: num_points not evenly divisible by num_images()\" )) num_global_points = num_points num_local_points = num_points / num_images () num_intervals = num_global_points ! right-side boundary point is redundant and therefore not counted or stored dx = two_pi / real ( num_intervals , real64 ) if (. not . allocated ( this % values )) allocate ( this % values ( num_local_points )[ * ]) local_grid = [(( this_image () - 1 ) * num_local_points + i - 1 , i = 1 , num_local_points )] * dx do concurrent ( i = 1 : num_local_points ) this % values ( i ) = initial_function ( local_grid ( i )) end do call synchronize () ! Ensures call this % mark_as_defined call assert ( allocated ( dx ), error_message ( \"global_field%set: dx has not been allocated\" )) call assert ( allocated ( num_global_points ), error_message ( \"global_field%set: num_global_points has not been allocated\" )) call assert ( allocated ( num_local_points ), error_message ( \"global_field%set: num_local_points has not been allocated\" )) end subroutine subroutine assign_local_field ( lhs , rhs ) class ( global_field ), intent ( inout ) :: lhs class ( local_field ), intent ( in ) :: rhs real ( real64 ), allocatable :: values (:) ! Requires if (. not . allocated ( num_local_points )) error stop \"global_field: no value established for memory allocation yet.\" if (. not . allocated ( lhs % values )) allocate ( lhs % values ( num_local_points )[ * ]) call assert ( rhs % user_defined (), error_message ( \"global_field%assign_local_field received uninitialized RHS.\" )) lhs % values (:) = rhs % state () call synchronize () ! Ensures call lhs % mark_as_defined end subroutine pure function add_local_field ( lhs , rhs ) result ( total ) class ( global_field ), intent ( in ) :: lhs type ( local_field ), intent ( in ) :: rhs type ( local_field ) :: total ! Requires if ( lhs % user_defined () . and . rhs % user_defined ()) then total = lhs % values + rhs % state () call total % mark_as_defined end if end function pure function multiply ( lhs , rhs ) result ( product_ ) class ( global_field ), intent ( in ) :: lhs , rhs type ( local_field ) :: product_ ! Requires if ( lhs % user_defined () . and . rhs % user_defined ()) then product_ = lhs % values * rhs % values call product_ % mark_as_defined end if end function pure function x ( this ) result ( this_x ) class ( global_field ), intent ( in ) :: this type ( local_field ) :: this_x real ( real64 ) :: local_this_x ( num_local_points ) integer ( int64 ) :: i , left_neighbor , right_neighbor ! Requires if ( this % user_defined () . and . allocated ( dx ) . and . allocated ( num_local_points )) then associate ( N => num_local_points , me => this_image ()) left_neighbor = merge ( num_images (), me - 1 , me == 1 ) local_this_x ( 1 ) = ( this % values ( 2 ) - this % values ( N )[ left_neighbor ]) / ( 2._real64 * dx ) do concurrent ( i = 2 : N - 1 ) local_this_x ( i ) = ( this % values ( i + 1 ) - this % values ( i - 1 )) / ( 2._real64 * dx ) end do right_neighbor = merge ( 1 , me + 1 , me == num_images ()) local_this_x ( N ) = ( this % values ( 1 )[ right_neighbor ] - this % values ( N - 1 )) / ( 2._real64 * dx ) end associate this_x = local_this_x ! Ensures call this_x % mark_as_defined end if end function !pure function xx(this) result(this_xx) function xx ( this ) result ( this_xx ) class ( global_field ), intent ( in ) :: this type ( local_field ) :: this_xx real ( real64 ) :: local_this_xx ( num_local_points ) integer ( int64 ) :: i , left_neighbor , right_neighbor ! Requires if ( this % user_defined () . and . allocated ( dx ) . and . allocated ( num_local_points )) then associate ( N => num_local_points , me => this_image ()) left_neighbor = merge ( num_images (), me - 1 , me == 1 ) local_this_xx ( 1 ) = ( this % values ( 2 ) - 2._real64 * this % values ( 1 ) + this % values ( N )[ left_neighbor ]) / dx ** 2 do concurrent ( i = 2 : N - 1 ) local_this_xx ( i ) = ( this % values ( i + 1 ) - 2._real64 * this % values ( i ) + this % values ( i - 1 )) / dx ** 2 end do right_neighbor = merge ( 1 , me + 1 , me == num_images ()) local_this_xx ( N ) = ( this % values ( 1 )[ right_neighbor ] - 2._real64 * this % values ( N ) + this % values ( N - 1 )) / dx ** 2 end associate this_xx = local_this_xx ! Ensures call this_xx % mark_as_defined !print *,\"On image \",this_image(),\", local_this_xx=\",local_this_xx !stop end if end function subroutine output ( this , unit , iotype , v_list , iostat , iomsg ) class ( global_field ), intent ( in ) :: this integer , intent ( in ) :: unit ! Unit on which output happens (negative for internal file) character ( * ), intent ( in ) :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg integer ( int64 ) :: i ! Requires call assert ( this % user_defined (), error_message ( \"global_field%output received uninitialized object\" )) do i = 1 , size ( this % values ) write ( unit , iostat = iostat ) ( this_image () - 1 ) * size ( this % values ) + i , this % values ( i ) end do end subroutine end module","tags":"","loc":"sourcefile/global_field.f90.html","title":"global_field.F90 – OpenCoarrays"},{"text":"Source Code module local_field_module use iso_fortran_env , only : real64 , int64 use ForTrilinos_assertion_utility , only : assert , error_message use object_interface , only : object implicit none private public :: local_field type , extends ( object ) :: local_field private real ( real64 ), allocatable :: values (:) contains procedure :: state procedure , private , pass ( rhs ) :: multiply procedure , private :: subtract procedure , private :: assign_array generic :: operator ( - ) => subtract generic :: operator ( * ) => multiply generic :: assignment ( = ) => assign_array procedure :: output end type contains pure subroutine assign_array ( lhs , rhs ) class ( local_field ), intent ( inout ) :: lhs real ( real64 ), intent ( in ) :: rhs (:) lhs % values = rhs ! Ensures call lhs % mark_as_defined end subroutine pure function subtract ( lhs , rhs ) result ( difference ) class ( local_field ), intent ( in ) :: lhs , rhs type ( local_field ) :: difference !Requires if ( lhs % user_defined () . and . rhs % user_defined ()) then difference % values = lhs % values - rhs % values ! Ensures call difference % mark_as_defined end if end function pure function multiply ( lhs , rhs ) result ( product_ ) class ( local_field ), intent ( in ) :: rhs type ( local_field ) :: product_ real ( real64 ), intent ( in ) :: lhs if ( rhs % user_defined ()) then product_ % values = lhs * rhs % values ! Ensures call product_ % mark_as_defined end if end function pure function state ( this ) result ( this_values ) class ( local_field ), intent ( in ) :: this real ( real64 ), allocatable :: this_values (:) this_values = this % values end function subroutine output ( this , unit , iotype , v_list , iostat , iomsg ) class ( local_field ), intent ( in ) :: this integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer ( int64 ) :: i ! Requires call assert ( this % user_defined (), error_message ( \"local_field%output received uninitialized object\" )) do i = 1 , size ( this % values ) write ( unit , iostat = iostat ) ( this_image () - 1 ) * size ( this % values ) + i , this % values ( i ) end do end subroutine end module","tags":"","loc":"sourcefile/local_field.f90.html","title":"local_field.F90 – OpenCoarrays"},{"text":"Source Code program main use iso_fortran_env , only : real64 , int64 , compiler_version , compiler_options use ieee_arithmetic , only : ieee_is_nan use global_field_module , only : global_field , initial_condition use ForTrilinos_assertion_utility , only : assert , error_message implicit none type ( global_field ) :: u , u_half , half_uu real ( real64 ), parameter :: nu = 1. , final_time = 0.6_real64 , tolerance = 1.E-3_real64 , safety_factor = 0.1_real64 real ( real64 ) :: time = 0. , dt , dx integer , parameter :: nodes = 16 procedure ( initial_condition ), pointer :: initial_u => ten_sin #ifdef TAU call TAU_PROFILE_SET_NODE ( this_image () - 1 ) ! Start TAU (Cray or GNU compiler) #else #ifdef TAU_INTEL call TAU_PROFILE_SET_NODE ( this_image ()) ! Start TAU (Intel compiler) #endif #endif call u % set ( initial_u , num_points = nodes ) dx = u % grid_spacing () dt = safety_factor * diffusion_stability_limit ( nu , dx , order_of_accuracy = 2 ) do while ( time < final_time ) half_uu = 0.5_real64 * ( u * u ) u_half = u + ( dt / 2._real64 ) * ( nu * u % xx () - half_uu % x ()) half_uu = 0.5_real64 * ( u_half * u_half ) u = u + dt * ( nu * u_half % xx () - half_uu % x ()) time = time + dt end do if ( this_image () == 1 ) print * , \"Time =\" , time print * , \"On image \" , this_image (), \"u =\" , u % state () call test ( u ) sync all if ( this_image () == 1 ) print * , \"Test passed.\" contains subroutine test ( burgers_solution ) type ( global_field ), intent ( in ) :: burgers_solution call assert (. not . any ( ieee_is_nan ( u % state ())), error_message ( \"Test failed: u is not a number.\" )) call assert ( sinusoid ( u ), error_message ( \"Test failed: improper shape.\" )) end subroutine function sinusoid ( u_solution ) result ( is_sinusoid ) type ( global_field ), intent ( in ) :: u_solution type ( global_field ) :: u_xx logical :: is_sinusoid real ( real64 ), parameter :: threshold =- 0.001 , cap = 0.001 real ( real64 ), allocatable :: u_xx_state (:) u_xx = u_solution % xx () u_xx_state = u_xx % state () if ( num_images () /= 1 ) then ! Ensure that the global midpoint is a local endpoint for whatever image contains the midpoint: call assert ( mod ( num_images (), 2 ) == 0 , error_message ( \"Test failed: uneven number of images.\" )) ! Ensure that the left and right halves of the solution are concave down and up, respectively: if ( this_image () <= num_images () / 2 ) then call assert ( all ( u_xx_state < cap ), error_message ( \"Test failed: right half not concave up.\" )) else call assert ( all ( u_xx_state > threshold ), error_message ( \"Test failed: left half not concave down.\" )) end if else block integer :: size_u_xx size_u_xx = size ( u_xx_state ) call assert ( all ( u_xx_state ( 1 : size_u_xx / 2 ) < cap ), error_message ( \"Test failed: left half not concave down.\" )) call assert ( all ( u_xx_state ( size_u_xx / 2 + 1 : size_u_xx ) > threshold ), error_message ( \"Test failed: right half not concave up.\" )) end block end if is_sinusoid = . true . end function pure function diffusion_stability_limit ( diffusivity , delta_x , order_of_accuracy ) result ( stable_time_step ) real ( real64 ), intent ( in ) :: diffusivity , delta_x integer , intent ( in ) :: order_of_accuracy real ( real64 ) :: stable_time_step real ( real64 ), parameter , dimension ( * ) :: stability_limit = [ 2. , 2. , 2.5 , 2.79 ] ! third value needs to be checked ! See Moin, P. (2010) Fundamentals of Engineering Numerical Analysis, 2nd ed., pp. 111-116. stable_time_step = safety_factor * stability_limit ( order_of_accuracy ) * ( delta_x ** 2 ) / ( 4._real64 * diffusivity ) end function pure function ten_sin ( x ) result ( ten_sin_x ) real ( real64 ), intent ( in ) :: x real ( real64 ) :: ten_sin_x ten_sin_x = 1 0._real64 * sin ( x ) end function end program","tags":"","loc":"sourcefile/main.f90.html","title":"main.F90 – OpenCoarrays"},{"text":"ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos\n     Copyright 2010 Sandia Corporation Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n the U.S. Government retains certain rights in this software. Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution. Neither the name of the Corporation nor the names of the\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Questions? Contact Karla Morris  (knmorri@sandia.gov)\n                    Damian Rouson (rouson@sandia.gov) Source Code !********************************************************************* ! ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos !     Copyright 2010 Sandia Corporation ! ! Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation, ! the U.S. Government retains certain rights in this software. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright !    notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright !    notice, this list of conditions and the following disclaimer in the !    documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the Corporation nor the names of the !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY ! EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR ! PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE ! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, ! EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, ! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR ! PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF ! LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING ! NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! Questions? Contact Karla Morris  (knmorri@sandia.gov) !                    Damian Rouson (rouson@sandia.gov) !********************************************************************* module ForTrilinos_assertion_utility #include \"compiler_capabilities.txt\" use iso_fortran_env , only : error_unit use object_interface , only : object implicit none !> @cond Private private !> @endcond public :: error_message , assert , assert_identical !> @cond Do not show max_string_length #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS integer , parameter :: max_string_length = 256 #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ !> @endcond type error_message private #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS character ( len = max_string_length ) :: string ! gfortran 4.7.0 workaround #else character (:) , allocatable :: string #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ integer , allocatable :: idata (:) real , allocatable :: rdata (:) complex , allocatable :: cdata (:) character , allocatable :: chdata (:) logical , allocatable :: ldata (:) class ( object ), allocatable :: odata end type !> @cond Interface interface error_message ! constructor module procedure new_message end interface interface assert module procedure scalar_assert , vector_assert end interface !> @endcond contains type ( error_message ) function new_message ( message , message_data ) use object_interface , only : object character ( len =* ), intent ( in ) :: message class ( * ), intent ( in ), optional :: message_data new_message % string = message if ( present ( message_data )) then select type ( message_data ) type is ( character ( len =* )) new_message % chdata = message_data type is ( real ) new_message % rdata = message_data type is ( integer ) new_message % idata = message_data type is ( logical ) new_message % ldata = message_data type is ( complex ) new_message % cdata = message_data class is ( object ) allocate ( new_message % odata , source = message_data ) class default #ifndef COMPILER_LACKS_ERROR_STOP error & #endif stop \"error_message constructor: unrecognized message_data type\" end select end if end function subroutine scalar_assert ( assertion , message ) logical , intent ( in ) :: assertion type ( error_message ) , intent ( in ) :: message integer io_status character ( len = 132 ) io_message if (. not . assertion ) then write ( error_unit , fmt = '(31a)' , advance = \"no\" ) 'Assertion failed with message: ' #ifndef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS if ( allocated ( message % string )) then #endif write ( error_unit , * ) message % string #ifndef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS else write ( error_unit , * ) '(no message provided).' end if #endif if ( allocated ( message % idata )) write ( error_unit , * ) 'Integer test data: ' , message % idata if ( allocated ( message % rdata )) write ( error_unit , * ) 'Real test data: ' , message % rdata if ( allocated ( message % odata )) then #ifdef COMPILER_LACKS_DERIVED_TYPE_IO call message % odata % output ( error_unit , v_list = [ 10 , 3 ], iotype = 'DT' , iostat = io_status , iomsg = io_message ) #else write ( error_unit , fmt = \"(dt(10,3))\" , iostat = io_status , iomsg = io_message ) message % odata #endif /* COMPILER_LACKS_DERIVED_TYPE_IO */ end if stop \"scalar_assert: assertion failure\" end if end subroutine subroutine vector_assert ( assertion , text ) logical , dimension (:) , intent ( in ) :: assertion type ( error_message ) , dimension (:) , intent ( in ) :: text integer :: i logical :: any_failures call assert_identical ( [ size ( assertion ), size ( text )] ) any_failures = . false . do i = 1 , size ( assertion ) if (. not . assertion ( i )) then any_failures = . true . write ( error_unit , fmt = '(31a)' , advance = \"no\" ) 'Assertion failed with message: ' !if (allocated(text(i)%string)) then write ( error_unit , * ) text ( i )% string !else !  write(error_unit,*) '(no message provided).' !end if end if end do if ( any_failures ) stop 'Execution halted on failed assertion(s)!' end subroutine subroutine assert_identical ( integers ) integer , dimension (:) , intent ( in ) :: integers integer :: i logical :: any_mismatches any_mismatches = . false . do i = 2 , size ( integers ) if ( integers ( i ) /= integers ( 1 )) then any_mismatches = . true . write ( error_unit , * ) & 'Value ' , i , ' does not match expected value ' , integers ( 1 ) end if end do if ( any_mismatches ) stop 'Execution halted on failed assertion!' end subroutine end module","tags":"","loc":"sourcefile/fortrilinos_assertion_utility.f90.html","title":"ForTrilinos_assertion_utility.F90 – OpenCoarrays"},{"text":"ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos\n                Copyright 2010 Sandia Corporation Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n the U.S. Government retains certain rights in this software. Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution. Neither the name of the Corporation nor the names of the\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Questions? Contact Karla Morris  (knmorri@sandia.gov) or\n                    Damian Rouson (rouson@sandia.gov) Source Code !********************************************************************* ! ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos !                Copyright 2010 Sandia Corporation ! ! Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation, ! the U.S. Government retains certain rights in this software. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright !    notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright !    notice, this list of conditions and the following disclaimer in the !    documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the Corporation nor the names of the !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY ! EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR ! PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE ! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, ! EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, ! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR ! PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF ! LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING ! NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! Questions? Contact Karla Morris  (knmorri@sandia.gov) or !                    Damian Rouson (rouson@sandia.gov) !********************************************************************* module ForTrilinos_error #include \"compiler_capabilities.txt\" implicit none private public :: error #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS integer , parameter :: max_string_length = 256 #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ type :: error private integer code class ( * ), allocatable :: data_ (:) #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS character ( len = max_string_length ) message ! gfortran 4.7.0 workaround #else character (:) , allocatable :: message #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ contains procedure :: error_code procedure :: define_error generic :: error => define_error end type contains subroutine define_error ( this , new_code , new_message , new_data ) class ( error ), intent ( out ) :: this integer , intent ( in ) :: new_code character ( len =* ) , intent ( in ) :: new_message class ( * ) , intent ( in ), optional :: new_data (:) this % code = new_code this % message = new_message if ( present ( new_data )) allocate ( this % data_ ( lbound ( new_data , 1 ): ubound ( new_data , 1 )), source = new_data ) end subroutine integer function error_code ( this ) class ( error ) , intent ( in ) :: this error_code = this % code end function function error_message ( this ) class ( error ) , intent ( in ) :: this character (:), allocatable :: error_message error_message = this % message end function end module ForTrilinos_error","tags":"","loc":"sourcefile/fortrilinos_error.f90.html","title":"ForTrilinos_error.F90 – OpenCoarrays"},{"text":"Source Code module co_object_interface implicit none private public :: co_object ! Define an abstract base class to ensure basic functionality expected to be provided by all concrete Morfeus classes. ! Each concrete class provides the functionality by extending this class and implementing its deferred binding(s).  This ! class resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other class. type , abstract :: co_object private logical :: defined = . false . ! Mark all co_objects as not-yet user-defined by default real , allocatable :: dummy_to_facilitate_extension [:] contains procedure :: mark_as_defined procedure :: user_defined procedure ( formatted_output_interface ), deferred :: output !generic :: write(unformatted) => output  ! Derived-type I/O not yet supported by most compilers end type ! Require child classes to write an \"output\" procedure that prints to the passed file unit abstract interface subroutine formatted_output_interface ( this , unit , iotype , v_list , iostat , iomsg ) import co_object class ( co_object ), intent ( in ) :: this integer , intent ( in ) :: unit ! Unit on which output happens (negative for internal file) character ( * ), intent ( in ) :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg end subroutine end interface contains ! Mark the co_object as user-defined pure subroutine mark_as_defined ( this ) class ( co_object ), intent ( inout ) :: this this % defined = . true . end subroutine ! Return a boolean result indicating whether this co_object has been initialized since its declaration logical pure function user_defined ( this ) class ( co_object ), intent ( in ) :: this user_defined = this % defined end function end module","tags":"","loc":"sourcefile/co_object_interface.f90.html","title":"co_object_interface.F90 – OpenCoarrays"},{"text":"Source Code module object_interface #include \"compiler_capabilities.txt\" implicit none private public :: object ! Define an abstract parent type to ensure basic functionality expected to be provided by all non-abstract types. ! Each non-abstract type provides the functionality by extending this type and implementing its deferred binding(s).  This ! type resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other type. type , abstract :: object private logical :: defined = . false . ! Mark all objects as not-yet user-defined by default contains procedure :: mark_as_defined procedure :: user_defined procedure ( output_interface ), deferred :: output #ifndef COMPILER_LACKS_DERIVED_TYPE_IO generic :: write ( formatted ) => output ! Derived-type I/O #endif /* COMPILER_LACKS_DERIVED_TYPE_IO */ end type ! Require child classes to write an \"output\" procedure that prints to the passed file unit abstract interface subroutine output_interface ( this , unit , iotype , v_list , iostat , iomsg ) import object class ( object ), intent ( in ) :: this integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg end subroutine end interface contains ! Mark the object as user-defined pure subroutine mark_as_defined ( this ) class ( object ), intent ( inout ) :: this this % defined = . true . end subroutine ! Return a boolean result indicating whether this object has been initialized since its declaration logical pure function user_defined ( this ) class ( object ), intent ( in ) :: this user_defined = this % defined end function end module","tags":"","loc":"sourcefile/object_interface.f90.html","title":"object_interface.F90 – OpenCoarrays"},{"text":"Source Code ! Coarray 1D Heat Equation Solver Test: global_field_module ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! module global_field_module use local_field_module , only : local_field implicit none private public :: global_field type global_field private real , allocatable :: values (:)[:] contains procedure :: set procedure :: only_allocate generic :: global_field_ => set , only_allocate procedure , private :: laplacian generic :: operator (. laplacian .) => laplacian procedure , private :: add_local_field generic :: operator ( + ) => add_local_field procedure , private :: assign_local_field generic :: assignment ( = ) => assign_local_field procedure :: state end type real :: dx integer , allocatable :: num_local_points integer , parameter :: num_end_points = 2 real :: boundary_vals ( num_end_points ) contains subroutine only_allocate ( this ) class ( global_field ), intent ( inout ) :: this if (. not . allocated ( num_local_points )) error stop \"global_field: no value established for memory allocation yet.\" allocate ( this % values ( num_local_points )[ * ]) ! Implicit synchronization point end subroutine subroutine set ( this , internal_values , boundary_values , domain , num_global_points ) class ( global_field ), intent ( inout ) :: this integer , intent ( in ) :: num_global_points real , intent ( in ) :: internal_values , domain ( num_end_points ), boundary_values ( num_end_points ) if ( mod ( num_global_points , num_images ()) /= 0 ) error stop \"set: num_global_points not evenly divisible by num_images()\" if ( this_image () == 1 . or . this_image () == num_images ()) boundary_vals = boundary_values if (. not . allocated ( num_local_points )) num_local_points = num_global_points / num_images () dx = ( domain ( 2 ) - domain ( 1 )) / num_global_points allocate ( this % values ( num_local_points )[ * ]) associate ( west => 1 , east => 2 ) this % values ( 1 ) = merge ( boundary_values ( west ), internal_values , this_image () == 1 ) this % values ( 2 : num_local_points - 1 ) = internal_values this % values ( num_local_points ) = merge ( boundary_values ( east ), internal_values , this_image () == num_images ()) end associate call synchronize () end subroutine subroutine synchronize () if ( num_images () > 1 ) then associate ( me => this_image ()) if ( me == 1 ) then sync images ( me + 1 ) else if ( me == num_images ()) then sync images ( me - 1 ) else sync images ([ me - 1 , me + 1 ]) end if end associate end if end subroutine pure function laplacian ( rhs ) result ( laplacian_rhs ) class ( global_field ), intent ( in ) :: rhs type ( local_field ) :: laplacian_rhs real :: local_laplacian ( num_local_points ) integer :: i associate ( N => num_local_points , me => this_image ()) if ( me == 1 ) then local_laplacian ( 1 ) = 0. else local_laplacian ( 1 ) = ( rhs % values ( 2 ) - 2. * rhs % values ( 1 ) + rhs % values ( N )[ me - 1 ]) / dx ** 2 end if do concurrent ( i = 2 : N - 1 ) local_laplacian ( i ) = ( rhs % values ( i + 1 ) - 2. * rhs % values ( i ) + rhs % values ( i - 1 )) / dx ** 2 end do if ( me == num_images ()) then local_laplacian ( N ) = 0. else local_laplacian ( N ) = ( rhs % values ( 1 )[ me + 1 ] - 2. * rhs % values ( N ) + rhs % values ( N - 1 )) / dx ** 2 end if end associate laplacian_rhs = local_laplacian end function pure function add_local_field ( lhs , rhs ) result ( total ) class ( global_field ), intent ( in ) :: lhs type ( local_field ), intent ( in ) :: rhs type ( local_field ) :: total total = lhs % values + rhs % state () end function subroutine assign_local_field ( lhs , rhs ) class ( global_field ), intent ( inout ) :: lhs class ( local_field ), intent ( in ) :: rhs lhs % values (:) = rhs % state () call synchronize () end subroutine pure function state ( this ) result ( this_values ) class ( global_field ), intent ( in ) :: this real :: this_values ( size ( this % values (:))) this_values = this % values end function end module","tags":"","loc":"sourcefile/global_field.f90.html","title":"global_field.f90 – OpenCoarrays"},{"text":"Source Code ! Coarray 1D Heat Equation Solver Test: local_field_module ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! module local_field_module implicit none private public :: local_field type local_field private real , allocatable :: values (:) contains procedure , private :: multiply generic :: operator ( * ) => multiply procedure :: state procedure , private :: assign_array generic :: assignment ( = ) => assign_array end type contains pure function multiply ( lhs , rhs ) result ( product_ ) class ( local_field ), intent ( in ) :: lhs type ( local_field ) :: product_ real , intent ( in ) :: rhs product_ % values = lhs % values * rhs end function pure function state ( this ) result ( this_values ) class ( local_field ), intent ( in ) :: this real :: this_values ( size ( this % values )) this_values = this % values end function pure subroutine assign_array ( lhs , rhs ) class ( local_field ), intent ( inout ) :: lhs real , intent ( in ) :: rhs (:) lhs % values = rhs end subroutine end module","tags":"","loc":"sourcefile/local_field.f90.html","title":"local_field.f90 – OpenCoarrays"},{"text":"Source Code ! Coarray 1D Heat Equation Solver Test: main ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program main use global_field_module , only : global_field implicit none type ( global_field ) :: T , laplacian_T , T_half real , parameter :: alpha = 1. , dt = 0.0001 , final_time = 1. , tolerance = 1.E-3 real :: time = 0. call T % global_field_ ( internal_values = 0. , boundary_values = [ 1. , 0. ], domain = [ 0. , 1. ], num_global_points = 16384 ) call T_half % global_field_ () do while ( time < final_time ) T_half = T + (. laplacian . T ) * ( alpha * dt / 2. ) T = T + (. laplacian . T_half ) * ( alpha * dt ) time = time + dt end do call laplacian_T % global_field_ () laplacian_T = . laplacian . T if ( any ( laplacian_T % state () > tolerance )) error stop \"Test failed.\" if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – OpenCoarrays"},{"text":"ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos\n     Copyright 2010 Sandia Corporation Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n the U.S. Government retains certain rights in this software. Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution. Neither the name of the Corporation nor the names of the\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Questions? Contact Karla Morris  (knmorri@sandia.gov)\n                    Damian Rouson (rouson@sandia.gov) Source Code !********************************************************************* ! ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos !     Copyright 2010 Sandia Corporation ! ! Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation, ! the U.S. Government retains certain rights in this software. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright !    notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright !    notice, this list of conditions and the following disclaimer in the !    documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the Corporation nor the names of the !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY ! EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR ! PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE ! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, ! EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, ! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR ! PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF ! LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING ! NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! Questions? Contact Karla Morris  (knmorri@sandia.gov) !                    Damian Rouson (rouson@sandia.gov) !********************************************************************* module ForTrilinos_assertion_utility #include \"compiler_capabilities.txt\" use iso_fortran_env , only : error_unit use object_interface , only : object implicit none !> @cond Private private !> @endcond public :: error_message , assert , assert_identical !> @cond Do not show max_string_length #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS integer , parameter :: max_string_length = 256 #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ !> @endcond type error_message private #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS character ( len = max_string_length ) :: string ! gfortran 4.7.0 workaround #else character (:) , allocatable :: string #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ integer , allocatable :: idata (:) real , allocatable :: rdata (:) complex , allocatable :: cdata (:) character , allocatable :: chdata (:) logical , allocatable :: ldata (:) class ( object ), allocatable :: odata end type !> @cond Interface interface error_message ! constructor module procedure new_message end interface interface assert module procedure scalar_assert , vector_assert end interface !> @endcond contains type ( error_message ) function new_message ( message , message_data ) use object_interface , only : object character ( len =* ), intent ( in ) :: message class ( * ), intent ( in ), optional :: message_data new_message % string = message if ( present ( message_data )) then select type ( message_data ) type is ( character ( len =* )) new_message % chdata = message_data type is ( real ) new_message % rdata = message_data type is ( integer ) new_message % rdata = message_data type is ( logical ) new_message % ldata = message_data type is ( complex ) new_message % cdata = message_data class is ( object ) allocate ( new_message % odata , source = message_data ) end select end if end function subroutine scalar_assert ( assertion , message ) logical , intent ( in ) :: assertion type ( error_message ) , intent ( in ) :: message integer io_status character ( len = 132 ) io_message if (. not . assertion ) then write ( error_unit , fmt = '(31a)' , advance = \"no\" ) 'Assertion failed with message: ' #ifndef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS if ( allocated ( message % string )) then #endif write ( error_unit , * ) message % string #ifndef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS else write ( error_unit , * ) '(no message provided).' end if #endif if ( allocated ( message % idata )) write ( error_unit , * ) 'Integer test data: ' , message % idata if ( allocated ( message % rdata )) write ( error_unit , * ) 'Real test data: ' , message % rdata if ( allocated ( message % odata )) then #ifdef COMPILER_LACKS_DERIVED_TYPE_IO call message % odata % output ( error_unit , v_list = [ 10 , 3 ], iotype = 'DT' , iostat = io_status , iomsg = io_message ) #else write ( error_unit , fmt = \"(dt(10,3))\" , iostat = io_status , iomsg = io_message ) message % odata #endif /* COMPILER_LACKS_DERIVED_TYPE_IO */ end if stop \"scalar_assert: assertion failure\" end if end subroutine subroutine vector_assert ( assertion , text ) logical , dimension (:) , intent ( in ) :: assertion type ( error_message ) , dimension (:) , intent ( in ) :: text integer :: i logical :: any_failures call assert_identical ( [ size ( assertion ), size ( text )] ) any_failures = . false . do i = 1 , size ( assertion ) if (. not . assertion ( i )) then any_failures = . true . write ( error_unit , fmt = '(31a)' , advance = \"no\" ) 'Assertion failed with message: ' !if (allocated(text(i)%string)) then write ( error_unit , * ) text ( i )% string !else !  write(error_unit,*) '(no message provided).' !end if end if end do if ( any_failures ) stop 'Execution halted on failed assertion(s)!' end subroutine subroutine assert_identical ( integers ) integer , dimension (:) , intent ( in ) :: integers integer :: i logical :: any_mismatches any_mismatches = . false . do i = 2 , size ( integers ) if ( integers ( i ) /= integers ( 1 )) then any_mismatches = . true . write ( error_unit , * ) & 'Value ' , i , ' does not match expected value ' , integers ( 1 ) end if end do if ( any_mismatches ) stop 'Execution halted on failed assertion!' end subroutine end module","tags":"","loc":"sourcefile/fortrilinos_assertion_utility.f90~2.html","title":"ForTrilinos_assertion_utility.F90 – OpenCoarrays"},{"text":"ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos\n                Copyright 2010 Sandia Corporation Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,\n the U.S. Government retains certain rights in this software. Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution. Neither the name of the Corporation nor the names of the\n    contributors may be used to endorse or promote products derived from\n    this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY\n EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE\n CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. Questions? Contact Karla Morris  (knmorri@sandia.gov) or\n                    Damian Rouson (rouson@sandia.gov) Source Code !********************************************************************* ! ForTrilinos: Object-Oriented Fortran 2003 interface to Trilinos !                Copyright 2010 Sandia Corporation ! ! Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation, ! the U.S. Government retains certain rights in this software. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: ! ! 1. Redistributions of source code must retain the above copyright !    notice, this list of conditions and the following disclaimer. ! ! 2. Redistributions in binary form must reproduce the above copyright !    notice, this list of conditions and the following disclaimer in the !    documentation and/or other materials provided with the distribution. ! ! 3. Neither the name of the Corporation nor the names of the !    contributors may be used to endorse or promote products derived from !    this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION \"AS IS\" AND ANY ! EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ! IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR ! PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE ! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, ! EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, ! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR ! PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF ! LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING ! NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! ! Questions? Contact Karla Morris  (knmorri@sandia.gov) or !                    Damian Rouson (rouson@sandia.gov) !********************************************************************* module ForTrilinos_error #include \"compiler_capabilities.txt\" implicit none private public :: error #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS integer , parameter :: max_string_length = 256 #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ type :: error private integer code class ( * ), allocatable :: data_ (:) #ifdef ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS character ( len = max_string_length ) message ! gfortran 4.7.0 workaround #else character (:) , allocatable :: message #endif /* ForTrilinos_DISABLE_DEFERRED_LENGTH_CHARACTERS */ contains procedure :: error_code procedure :: define_error generic :: error => define_error end type contains subroutine define_error ( this , new_code , new_message , new_data ) class ( error ), intent ( out ) :: this integer , intent ( in ) :: new_code character ( len =* ) , intent ( in ) :: new_message class ( * ) , intent ( in ), optional :: new_data (:) this % code = new_code this % message = new_message if ( present ( new_data )) allocate ( this % data_ ( lbound ( new_data , 1 ): ubound ( new_data , 1 )), source = new_data ) end subroutine integer function error_code ( this ) class ( error ) , intent ( in ) :: this error_code = this % code end function function error_message ( this ) class ( error ) , intent ( in ) :: this character (:), allocatable :: error_message error_message = this % message end function end module ForTrilinos_error","tags":"","loc":"sourcefile/fortrilinos_error.f90~2.html","title":"ForTrilinos_error.F90 – OpenCoarrays"},{"text":"Source Code ! MoFo library: co_object_interface ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module co_object_interface implicit none private public :: co_object ! Define an abstract base class to ensure basic functionality expected to be provided by all concrete Morfeus classes. ! Each concrete class provides the functionality by extending this class and implementing its deferred binding(s).  This ! class resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other class. type , abstract :: co_object private logical :: defined = . false . ! Mark all co_objects as not-yet user-defined by default real , allocatable :: dummy_to_facilitate_extension [:] contains procedure :: mark_as_defined procedure :: user_defined procedure ( formatted_output_interface ), deferred :: output !generic :: write(unformatted) => output  ! Derived-type I/O not yet supported by most compilers end type ! Require child classes to write an \"output\" procedure that prints to the passed file unit abstract interface subroutine formatted_output_interface ( this , unit , iotype , v_list , iostat , iomsg ) import co_object class ( co_object ), intent ( in ) :: this integer , intent ( in ) :: unit ! Unit on which output happens (negative for internal file) character ( * ), intent ( in ) :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg end subroutine end interface contains ! Mark the co_object as user-defined pure subroutine mark_as_defined ( this ) class ( co_object ), intent ( inout ) :: this this % defined = . true . end subroutine ! Return a boolean result indicating whether this co_object has been initialized since its declaration logical pure function user_defined ( this ) class ( co_object ), intent ( in ) :: this user_defined = this % defined end function end module","tags":"","loc":"sourcefile/co_object_interface.f90~2.html","title":"co_object_interface.F90 – OpenCoarrays"},{"text":"Source Code ! MoFo library: object_interface ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module object_interface #include \"compiler_capabilities.txt\" implicit none private public :: object ! Define an abstract base class to ensure basic functionality expected to be provided by all concrete Morfeus classes. ! Each concrete class provides the functionality by extending this class and implementing its deferred binding(s).  This ! class resembles java's Object class in the sense that it is intended to be the ultimate ancester of every other class. type , abstract :: object private logical :: defined = . false . ! Mark all objects as not-yet user-defined by default contains procedure :: mark_as_defined procedure :: user_defined procedure ( output_interface ), deferred :: output #ifndef COMPILER_LACKS_DERIVED_TYPE_IO generic :: write ( formatted ) => output ! Derived-type I/O #endif /* COMPILER_LACKS_DERIVED_TYPE_IO */ end type ! Require child classes to write an \"output\" procedure that prints to the passed file unit abstract interface subroutine output_interface ( this , unit , iotype , v_list , iostat , iomsg ) import object class ( object ), intent ( in ) :: this integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg end subroutine end interface contains ! Mark the object as user-defined pure subroutine mark_as_defined ( this ) class ( object ), intent ( inout ) :: this this % defined = . true . end subroutine ! Return a boolean result indicating whether this object has been initialized since its declaration logical pure function user_defined ( this ) class ( object ), intent ( in ) :: this user_defined = this % defined end function end module","tags":"","loc":"sourcefile/object_interface.f90~2.html","title":"object_interface.F90 – OpenCoarrays"},{"text":"Source Code ! MoFo library: parse_command_line ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module parse_command_line ! Utility for returning key-value pairs passed at the command line in the format ! command key1=value1  key2=value2 ... implicit none private public :: get_keyword_values contains subroutine assert ( test_passes ) logical , intent ( in ) :: test_passes if (. not . test_passes ) stop \"assertion failed\" end subroutine ! Return the command-line values associated with the passed keys. ! Arguments and result variables: ! keys = array of keywords ! default_values = values returned for like-positioned keyword if no command-line value specified ! actual_values = values returned for like-positioned keys ! Each elment in the keys and default_values arrays must be padded with trailing blanks if necessary to give the elements ! a uniform length.  The actual_values elements are similarly padded if necessary to give them a uniform length. function get_keyword_values ( keys , default_values ) result ( actual_values ) character ( len =* ), dimension (:), intent ( in ) :: keys character ( len =* ), dimension (:), intent ( in ) :: default_values character ( len = :), dimension (:), allocatable :: actual_values character ( len = :), allocatable :: key_value_pair , trimmed_argument , trimmed_value character ( len = 1 ), parameter :: divider = \"=\" integer divider_position , error_flag , i , j ! Requires call assert ( size ( keys ) == size ( default_values )) actual_values = default_values allocate ( key_value_pair , source = repeat ( \" \" , ncopies = max_argument_length ()) ) ! Read the text of the arguments passed on the command line do i = 1 , command_argument_count () call get_command_argument ( i , key_value_pair , status = error_flag ) call check ( error_flag ) divider_position = scan ( key_value_pair , divider ) if ( divider_position == 0 ) stop \"Invalid argument format (expected: 'argument=value').\" trimmed_argument = trim ( key_value_pair ( 1 : divider_position - 1 )) trimmed_value = trim ( key_value_pair ( divider_position + 1 :)) if ( len ( trimmed_value ) == 0 ) stop \"Invalid value format (expected: 'argument=value').\" do j = 1 , size ( keys ) if ( trim ( keys ( j )) == trimmed_argument ) actual_values ( j ) = trimmed_value end do end do ! Ensures call assert ( size ( actual_values ) == size ( keys )) contains function max_argument_length () integer max_argument_length , n , length_of_argument_n max_argument_length = 0 do n = 1 , command_argument_count () call get_command_argument ( n , key_value_pair , status = error_flag , length = length_of_argument_n ) call check ( error_flag ) if ( length_of_argument_n > max_argument_length ) max_argument_length = length_of_argument_n end do end function subroutine check ( flag ) integer , intent ( in ) :: flag select case ( flag ) case ( - 1 ) ! this should never occur because key_value_pair is dynamically sized to match the length of the longest argument print * , \"main: argument \" , i , \"exceeds maximum length of \" , max_argument_length () stop case ( 1 :) print * , \"main: error in reading the argument name (status=\" , flag , \")\" stop case ( 0 ) ! argument_text read successfully case default stop \"main: invalid status (compiler error)\" end select end subroutine end function end module","tags":"","loc":"sourcefile/parse_command_line.f90.html","title":"parse_command_line.f90 – OpenCoarrays"},{"text":"Source Code ! Coarray 3D Navier-Stokes Solver Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !(*---------------------------------------------------------------------------------------------------------------------- !         basic in-core shear code ( 7 words/node, not threaded, in-core, no file read/write ) !------------------------------------------------------------------------------------------------------------------------*) ! Define universal constants: ! In the case of exactly representable numbers, the definitions are useful ! to ensure subprogram argument type/kind/rank matching without having to ! repeat kind specifiers everywhere. module constants_module use iso_fortran_env , only : int64 implicit none private public :: one , zero integer ( int64 ), parameter :: one = 1_int64 , zero = 0_int64 end module ! Initialize the random seed with a varying seed to ensure a different ! random number sequence for each invocation of subroutine, e.g. for ! invocations on different images of a coarray parallel program. ! Setting any seed values to zero is deprecated because it can result ! in low-quality random number sequences. ! (Source: https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fSEED.html) module random_module implicit none private public :: init_random_seed contains subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed end module random_module module run_size use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use constants_module , only : one ! 64-bit unit to ensure argument kind match implicit none real , codimension [ * ] :: viscos , shear , b11 , b22 , b33 , b12 , velmax integer ( int64 ), codimension [ * ] :: nx , ny , nz , nsteps , output_step integer ( int64 ), codimension [ * ] :: my , mx , first_y , last_y , first_x , last_x real ( real64 ), codimension [ * ] :: cpu_time , tran_time , sync_time , total_time real ( real64 ), codimension [ * ] :: max_cpu_time , max_tran_time , max_sync_time , max_total_time real ( real64 ), codimension [ * ] :: min_cpu_time , min_tran_time , min_sync_time , min_total_time real :: time , cfl , dt integer ( int64 ) :: my_node , num_nodes real , parameter :: pi = 3.141592653589793 contains subroutine max_velmax () integer ( int64 ) :: i sync all if ( my_node == 1 ) then do i = 2 , num_nodes ; velmax = max ( velmax , velmax [ i ] ); end do end if sync all if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3 end module run_size program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface nx = 128 ; ny = 128 ; nz = 128 viscos = 0. ; shear = 0. b11 = 1. ; b22 = 1. ; b33 = 1. ; b12 = 0. nsteps = 10 ; output_step = 1 num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then !       write(6,*) \"nx,ny,nz : \";               read(5,*) nx, ny, nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if !       write(6,*) \"viscos, shear : \";          read(5,*) viscos, shear !       write(6,*) \"b11 b22 b33 b12 : \";        read(5,*) b11, b22, b33, b12 !       write(6,*) \"nsteps, output_step : \";    read(5,*) nsteps, output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes end program cshear !  (*********************************************************************************************************** !             n a v i e r - s t o k e s   s o l v e r !  ************************************************************************************************************) subroutine solve_navier_stokes use run_size implicit none !(*****************************   declarations     ****************************************) integer ( int64 ) :: stop , rflag , oflag , step , rkstep , nshells real :: k1 ( nx / 2 ), k2 ( ny ), k3 ( nz ), mk1 ( nx / 2 ), mk2 ( ny ), mk3 ( nz ) & , kx ( nx / 2 ), ky_ ( nx / 2 , ny ), ky ( nx / 2 , ny ), kz ( nz ) complex :: sx ( nx / 2 , 3 ), sy ( ny , 3 ), sz ( nz , 3 ) integer ( int64 ) :: trigx , trigy , trigz , trigxy complex , allocatable :: u (:,:,:,:)[:] ! u(nz,4,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: ur (:,:,:,:)[:] !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- x-z planes --*) complex , allocatable :: un (:,:,:,:) !un(nz,3,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: bufr_X_Y (:,:,:,:) complex , allocatable :: bufr_Y_X (:,:,:,:) interface !--------    note: integer(int64)'s required for FFT's and other assembly-coded externals   ------ function ctrig ( len ) bind ( C ) !(*-- define complex FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: ctrig !-- C pointer! end function ctrig function rtrig ( len ) bind ( C ) !(*-- define real FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: rtrig !-- C pointer! end function rtrig subroutine cfft ( len , lot , data , inc , jmp , ctrig , isign ) bind ( C ) !(*-- complex FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , ctrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine cfft subroutine rfft ( len , lot , data , inc , jmp , rtrig , isign ) bind ( C ) !(*-- real FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , rtrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine rfft function WALLTIME () bind ( C , name = \"WALLTIME\" ) import real64 real ( real64 ) :: WALLTIME end function WALLTIME end interface trigx = rtrig ( nx ) trigy = ctrig ( ny ) trigz = ctrig ( nz ) trigxy = ctrig ( nx + ny ) allocate ( u ( nz , 4 , first_x : last_x , ny )[ * ] ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 )[ * ] ) !(*-- x-z planes --*) allocate ( un ( nz , 3 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( bufr_X_Y ( nz , 4 , mx , my ) ) allocate ( bufr_Y_X ( nz , 4 , my , mx ) ) stop = 0 ; step = 0 ; rkstep = 2 ; rflag = 0 ; cfl = 1 ; dt = 0 nshells = max ( nx , ny , nz ) call define_kspace call define_field call enforce_conjugate_symmetry call copy_n_s call define_shifts total_time = - WALLTIME () !-- start the clock tran_time = 0 ; cpu_time = - WALLTIME () !(*********************************   begin execution loop   *****************************************) do while ( stop == 0 ) call phase1 rkstep = 1 call transpose_X_Y call phase2 call transpose_Y_X call define_step call define_shifts call phase3 call pressure if ( oflag /= 0 ) call spectra call advance call phase1 rkstep = 2 call transpose_X_Y call phase2 call transpose_Y_X call phase3 call advance call pressure if ( rflag /= 0 ) call remesh call copy_s_n step = step + 1 time = time + dt end do !(*********************************   end execution loop   ***********************************************) deallocate ( u , ur , un ) deallocate ( bufr_X_Y ); deallocate ( bufr_Y_X ) sync all !-- wait for all images to finish! total_time = total_time + WALLTIME () !-- stop the clock cpu_time = cpu_time + WALLTIME () !-- stop the clock call global_times if ( my_node == 1 ) write ( 6 , fmt = \"(3(10X,A,2f7.2))\" ) & , \"total_time \" , min_total_time / step , max_total_time / step & , \"cpu_time \" , min_cpu_time / step , max_cpu_time / step & , \"tran_time \" , min_tran_time / step , max_tran_time / step write ( 6 , fmt = \"(A,i4,3f7.2)\" ) \"image \" , my_node , total_time / step , cpu_time / step , tran_time / step contains !(*********************************************************************************************************** !                          transpose the Y and Z planes !***********************************************************************************************************) !-----                   u(nz,4,mx,my*num_nodes) [num_nodes] !-----                  ur(nz,4,my,mx*num_nodes) [num_nodes] !-----                bufr(nz,4,my,mx) or bufr(nz,4,mx,my) !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use constants_module , only : one use run_size implicit none integer ( int64 ) :: i , stage cpu_time = cpu_time + WALLTIME () sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use run_size implicit none integer ( int64 ) :: i , stage cpu_time = cpu_time + WALLTIME () sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , one , one & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , one , one & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_Y_X !(************************************************************************************************************* !           enforce conjugate symmetry for plane kx=0 of wavespace  (half of this plane is redundant) !***************************************************************************************************************) subroutine enforce_conjugate_symmetry integer ( int64 ) :: i , x , y , z !(*------------------------- un( K ) = conjg( un( -K ) ) ---------------------*) if ( my_node == 1 ) then !-- x=1 is in node=1 x = 1 do i = 1 , 3 z = 1 ; y = 1 ; un ( z , i , x , y ) = 0 z = 1 ; do y = 2 , ny / 2 ; un ( z , i , x , y ) = conjg ( un ( z , i , x , ny + 2 - y ) ); end do do z = 2 , nz / 2 ; y = 1 ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , y ) ); end do do z = 2 , nz / 2 ; do y = 2 , ny ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , ny + 2 - y ) ); end do ; end do end do end if end  subroutine enforce_conjugate_symmetry !(*********************************************************************************************************** !                spectra :  accumulate spectra and other statistics over flow field !***********************************************************************************************************) subroutine spectra use run_size implicit none integer ( int64 ) :: k , x , y , z real :: kk , ww , uw , uu , uv , duu , factor & , ek ( nshells ), dk ( nshells ), hk ( nshells ), tk ( nshells ), sample ( nshells ) real , save , codimension [ * ] :: sum_ek , sum_dk , sum_hk , sum_tk total_time = total_time + WALLTIME () !-- stop the clock!  time/step does not include spectra time oflag = 0 ek = 0 ; dk = 0 ; hk = 0 ; tk = 0 ; sample = 0 !(*---------------------   three dimensional spectra  -----------------------*) do x = first_x , last_x ; do y = 1 , ny ; do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; factor = 0 else if ( x == 1 ) then ; factor = 1 else ; factor = 2 end if kk = kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 k = 1 + int ( sqrt ( kk ) + 0.5 ) uu = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( un ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( un ( z , 3 , x , y ) ) ) ww = kk * uu uv = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) uw = factor * 2 * aimag ( kx ( x ) * un ( z , 2 , x , y ) * conjg ( un ( z , 3 , x , y ) ) & + ky ( x , y ) * un ( z , 3 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + kz ( z ) * un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) duu = factor * real ( un ( z , 1 , x , y ) * conjg ( u ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( u ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( u ( z , 3 , x , y ) ) ) / ( dt / 2 ) + shear * uv sample ( k ) = sample ( k ) + factor !(*-- shell sample --*) ek ( k ) = ek ( k ) + uu !(*-- 2 * energy sum --*) dk ( k ) = dk ( k ) + ww !(*-- enstrophy sum --*) hk ( k ) = hk ( k ) + uw !(*-- helicity sum --*) tk ( k ) = tk ( k ) + duu !(*-- transfer sum --*) end do ; end do ; end do !(************************     finished accumulation :  compute final statistics     *************************) sum_ek = 0 ; sum_dk = 0 ; sum_hk = 0 ; sum_tk = 0 do k = nshells , 1 , - 1 sum_ek = sum_ek + ek ( k ) sum_dk = sum_dk + dk ( k ) sum_hk = sum_hk + hk ( k ) sum_tk = sum_tk + tk ( k ) end do sync all if ( my_node == 1 ) then do k = 2 , num_nodes sum_ek = sum_ek + sum_ek [ k ] sum_dk = sum_dk + sum_dk [ k ] sum_hk = sum_hk + sum_hk [ k ] sum_tk = sum_tk + sum_tk [ k ] end do if ( step == 0 ) write ( 6 , * ) \"step   time     energy    enstrophy   helicity   transfer\" write ( 6 , fmt = \"(i3, 5e11.3)\" ) step , time , sum_ek , sum_dk , sum_hk , sum_tk end if total_time = total_time - WALLTIME () !-- restart the clock! end  subroutine spectra !(************************************************************************************************************ !        define_field  :   define initial flow field from scratch !************************************************************************************************************) subroutine define_field use constants_module , only : zero use run_size use random_module implicit none real :: k , k12 , f , phi , theta1 , theta2 complex :: alpha , beta integer ( int64 ) :: x , y , z real , parameter :: klo = 8 , khi = 16 call init_random_seed !(* seed a different pseudo-random number sequence for each image *) time = 0 do x = first_x , last_x do y = 1 , ny do z = 1 , nz call random_number ( theta1 ) call random_number ( theta2 ) call random_number ( phi ) k = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) k12 = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 ) if ( k == 0 . or . mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. . or . k < klo . or . k > khi ) & then ; f = 0 else ; f = sqrt ( 1. / ( 2 * pi ) ) / k end if alpha = f * exp ( ( 0 , 2 ) * pi * theta1 ) * cos ( 2 * pi * phi ) beta = f * exp ( ( 0 , 2 ) * pi * theta2 ) * sin ( 2 * pi * phi ) if ( k12 == 0 ) & then ; un ( z , 1 , x , y ) = alpha un ( z , 2 , x , y ) = beta un ( z , 3 , x , y ) = 0 else ; un ( z , 1 , x , y ) = ( beta * kz ( z ) * kx ( x ) + alpha * k * ky ( x , y ) ) / ( k * k12 ) un ( z , 2 , x , y ) = ( beta * kz ( z ) * ky ( x , y ) - alpha * k * kx ( x ) ) / ( k * k12 ) un ( z , 3 , x , y ) = - beta * k12 / k end if end do ; end do ; end do end  subroutine define_field !(*********************************************************************************************************** !          define_shifts  :    define coordinate shifts for control of 1-d alias errors ! ***********************************************************************************************************) subroutine define_shifts use constants_module , only : zero use run_size implicit none integer ( int64 ) :: x , y , z integer ( int64 ), save :: init = 0 real :: delta_x , delta_y , delta_z integer :: i , seed_size if ( init == 0 ) & !-- Note: delta's not carried over from previous run then ; init = 1 call random_seed ( size = seed_size ) call random_seed ( put = [( 1234567 , i = 1 , seed_size )]) !(* same random numbers for each image! *) do x = 1 , nx / 2 ; sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( pi / nx ) * k1 ( x ) ); end do do y = 1 , ny ; sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( pi / ny ) * k2 ( y ) ); end do do z = 1 , nz ; sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( pi / nz ) * k3 ( z ) ); end do else ; call random_number ( delta_x ); delta_x = 2 * pi / nx * delta_x do x = 1 , nx / 2 ; sx ( x , 1 ) = sx ( x , 3 ) sx ( x , 2 ) = exp ( ( 0 , 1 ) * delta_x * k1 ( x ) ) sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( delta_x + pi / nx ) * k1 ( x ) ); end do call random_number ( delta_y ); delta_y = 2 * pi / ny * delta_y do y = 1 , ny ; sy ( y , 1 ) = sy ( y , 3 ) sy ( y , 2 ) = exp ( ( 0 , 1 ) * delta_y * k2 ( y ) ) sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( delta_y + pi / ny ) * k2 ( y ) ); end do call random_number ( delta_z ); delta_z = 2 * pi / nz * delta_z do z = 1 , nz ; sz ( z , 1 ) = sz ( z , 3 ) sz ( z , 2 ) = exp ( ( 0 , 1 ) * delta_z * k3 ( z ) ) sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( delta_z + pi / nz ) * k3 ( z ) ); end do end if end  subroutine define_shifts !(*********************************************************************************************************** !       define_step  :   update time, metric, shifts for the next step !**********************************************************************************************************) subroutine define_step use run_size implicit none sync all if ( cfl /= 0 ) then cpu_time = cpu_time + WALLTIME () call max_velmax cpu_time = cpu_time - WALLTIME () dt = cfl / velmax end if if ( shear > 0 & . and . . 01 * b11 * shear * dt < b12 & . and . b12 <= b11 * shear * dt ) then dt = b12 / ( b11 * shear ) !(* limit dt, hit the orthognal mesh *) oflag = 1 else if ( mod ( step , output_step ) == 0 ) then oflag = 1 end if b12 = b12 - b11 * shear * dt if ( b12 < - b22 / 2 ) rflag = 1 !(* remesh at the end of the step? *) if ( step == nsteps ) stop = 1 !(* last step? *) end   subroutine define_step !(*********************************************************************************************************** !      define_kspace  :   define physical wavespace from computational wavespace and metric !**********************************************************************************************************) subroutine define_kspace use run_size implicit none integer ( int64 ) :: x , y , z do x = 1 , nx / 2 ; k1 ( x ) = x - 1 ; end do do y = 1 , ny / 2 + 1 ; k2 ( y ) = y - 1 ; end do do z = 1 , nz / 2 + 1 ; k3 ( z ) = z - 1 ; end do do y = ny / 2 + 2 , ny ; k2 ( y ) = y - 1 - ny ; end do do z = nz / 2 + 2 , nz ; k3 ( z ) = z - 1 - nz ; end do do x = 1 , nx / 2 ; mk1 ( x ) = ( k1 ( x ) / nx ) ** 2 ; kx ( x ) = b11 * k1 ( x ); end do do z = 1 , nz ; mk3 ( z ) = ( k3 ( z ) / nz ) ** 2 ; kz ( z ) = b33 * k3 ( z ); end do do y = 1 , ny ; mk2 ( y ) = ( k2 ( y ) / ny ) ** 2 do x = 1 , nx / 2 ; ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ); end do ; end do end   subroutine define_kspace !(*********************************************************************************************************** !   phase 1 :  on entry, data-plane contains velocity in wave space.  interpolate database, shifted mesh, !              and proceed to physical y space . !************************************************************************************************************) subroutine phase1 use run_size implicit none complex :: shift integer ( int64 ) :: i , x , y , z do x = first_x , last_x do y = 1 , ny ; do z = 1 , nz shift = sz ( z , rkstep + 1 ) * sy ( y , rkstep + 1 ) * sx ( x , rkstep + 1 ) u ( z , 1 , x , y ) = shift * u ( z , 1 , x , y ) u ( z , 2 , x , y ) = shift * u ( z , 2 , x , y ) u ( z , 3 , x , y ) = shift * u ( z , 3 , x , y ) end do ; end do !(*---------------------------   LEAVING FOURIER WAVE SPACE  --------------------------*) do i = 1 , 3 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , one ); end do end do end   subroutine phase1 !(********************************************************************************************************** !     phase 2 :  on entry, data-plane contains velocity in physical y space, and wave x,z space on shifted !                mesh.  Proceed to physical x,z space,  form nonlinear terms, and return to wave x,z space. !***********************************************************************************************************) subroutine phase2 use run_size implicit none complex :: s2 ( nz , nx / 2 ), vs ( nz , nx / 2 ) integer ( int64 ) :: i , x , y , z real :: v2r , v2i , s2r , s2i , u1r , u1i , u2r , u2i , u3r , u3i , u4r , u4i velmax = 0 do y = first_y , last_y do x = 1 , nx / 2 ; do z = 1 , nz ; vs ( z , x ) = ur ( z , 2 , y , x ); end do ; end do do i = 1 , 3 call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , one ) call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , one ) end do !(*----------------------------  WELCOME TO PHYSICAL SPACE  --------------------------*) do x = 1 , nx / 2 ; do z = 1 , nz u1r = real ( ur ( z , 1 , y , x )); u1i = aimag ( ur ( z , 1 , y , x )) u2r = real ( ur ( z , 2 , y , x )); u2i = aimag ( ur ( z , 2 , y , x )) u3r = real ( ur ( z , 3 , y , x )); u3i = aimag ( ur ( z , 3 , y , x )) if ( rkstep == 1 ) velmax = max ( velmax & , b11 * nx * abs ( u1r ) + b22 * ny * abs ( u2r ) + b33 * nz * abs ( u3r ) & , b11 * nx * abs ( u1i ) + b22 * ny * abs ( u2i ) + b33 * nz * abs ( u3i ) ) v2r = u2r * u2r ; v2i = u2i * u2i s2r = u1r * u3r ; s2i = u1i * u3i u4r = u2r * u3r ; u4i = u2i * u3i u3r = u3r * u3r - v2r ; u3i = u3i * u3i - v2i u2r = u1r * u2r ; u2i = u1i * u2i u1r = u1r * u1r - v2r ; u1i = u1i * u1i - v2i s2 ( z , x ) = cmplx ( s2r , s2i ) ur ( z , 1 , y , x ) = cmplx ( u1r , u1i ) ur ( z , 2 , y , x ) = cmplx ( u2r , u2i ) ur ( z , 3 , y , x ) = cmplx ( u3r , u3i ) ur ( z , 4 , y , x ) = cmplx ( u4r , u4i ) end do ; end do !(*----------------------------  LEAVING PHYSICAL SPACE  --------------------------*) do i = 1 , 4 call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , - one ) do z = 1 , nz ; ur ( z , i , y , 1 ) = cmplx ( real ( ur ( z , i , y , 1 )), 0 ); end do call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , - one ) end do call rfft ( nx , nz , s2 , nz , one , trigx , - one ) do z = 1 , nz ; s2 ( z , 1 ) = cmplx ( real ( s2 ( z , 1 )), 0 ); end do call cfft ( nz , nx / 2 , s2 , one , nz , trigz , - one ) do x = 1 , nx / 2 ; do z = 1 , nz ur ( z , 1 , y , x ) = kx ( x ) * ur ( z , 1 , y , x ) + kz ( z ) * s2 ( z , x ) - ( 0 , 1 ) * 2 * nx * nz * shear * vs ( z , x ) ur ( z , 3 , y , x ) = kx ( x ) * s2 ( z , x ) + kz ( z ) * ur ( z , 3 , y , x ) end do ; end do end do end  subroutine phase2 !(*********************************************************************************************************** !     phase 3 :  on entry, the data-plane contains the four stresses on a shifted mesh in physical y space, !                wave x,z space.   Return to y  wave space on unshifted mesh and complete time derivative of !                velocity ( not divergence free yet ) !***********************************************************************************************************) subroutine phase3 use run_size implicit none integer ( int64 ) :: i , x , y , z complex :: shift do x = first_x , last_x do i = 1 , 4 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , - one ) end do !(*---------------------------   WELCOME TO FOURIER WAVE SPACE  --------------------------*) do y = 1 , ny ; do z = 1 , nz shift = - dt / ( 4 * nx * ny * nz ) * ( 0 , 1 ) * conjg ( sy ( y , rkstep ) * sz ( z , rkstep ) * sx ( x , rkstep ) ) u ( z , 1 , x , y ) = shift * ( u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = shift * ( kx ( x ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 4 , x , y ) ) u ( z , 3 , x , y ) = shift * ( u ( z , 3 , x , y ) + ky ( x , y ) * u ( z , 4 , x , y ) ) end do ; end do end do end   subroutine phase3 !(*********************************************************************************************************** !   pressure :  add the gradient of a scalar, enforce continuity ( zero divergence ) !***********************************************************************************************************) subroutine pressure use run_size implicit none complex :: psi integer ( int64 ) :: x , y , z do x = first_x , last_x ; do y = 1 , ny if ( x /= 1 ) then do z = 1 , nz psi = ( kx ( x ) * u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 3 , x , y ) ) & / ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 1 , x , y ) = u ( z , 1 , x , y ) - kx ( x ) * psi u ( z , 2 , x , y ) = u ( z , 2 , x , y ) - ky ( x , y ) * psi u ( z , 3 , x , y ) = u ( z , 3 , x , y ) - kz ( z ) * psi end do else if ( y /= 1 ) then do z = 1 , nz psi = ( ky ( 1 , y ) * u ( z , 2 , 1 , y ) + kz ( z ) * u ( z , 3 , 1 , y ) ) & / ( ky ( 1 , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 2 , 1 , y ) = u ( z , 2 , 1 , y ) - ky ( 1 , y ) * psi u ( z , 3 , 1 , y ) = u ( z , 3 , 1 , y ) - kz ( z ) * psi end do else do z = 1 , nz ; u ( z , 3 , 1 , 1 ) = 0 ; end do end if end do ; end do end   subroutine pressure !(***************************************************************************************************************** !                                remesh  :  remesh the sheared coordinate system !*****************************************************************************************************************) subroutine remesh use constants_module , only : one use run_size implicit none complex :: u2 ( nx + ny , nz ), shift ( nx + ny ) integer ( int64 ) :: i , x , y , z write ( 6 , fmt = \"(A,i4)\" ) \"remesh image \" , my_node total_time = total_time + WALLTIME () !-- stop the clock! do x = first_x , last_x do y = 1 , nx + ny ; shift ( y ) = exp ( ( 0 , - 2 ) * pi / ( nx + ny ) * k1 ( x ) * ( y - 1 ) ) / ( nx + ny ); end do do i = 1 , 3 do z = 1 , nz do y = 1 , ny / 2 ; u2 ( y , z ) = u ( z , i , x , y ); end do do y = ny / 2 + 1 , nx + ny / 2 + 1 ; u2 ( y , z ) = 0 ; end do do y = nx + ny / 2 + 2 , nx + ny ; u2 ( y , z ) = u ( z , i , x , y - nx ); end do end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , one ) do z = 1 , nz ; do y = 1 , nx + ny ; u2 ( y , z ) = u2 ( y , z ) * shift ( y ); end do ; end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , - one ) do z = 1 , nz do y = 1 , ny / 2 if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y , z ) end if end do do y = ny / 2 + 1 , ny if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y + nx , z ) end if end do end do end do do y = 1 , ny ; ky ( x , y ) = ky ( x , y ) + b22 * k1 ( x ); end do !(* update ky for this x *) end do b12 = b12 + b22 ; rflag = 0 !(*   update metric, account for remesh    *) total_time = total_time - WALLTIME () !-- restart the clock! end subroutine remesh !(*********************************************************************************************************** !         copy_n_s,   copy_s_n :  copy data between data_s and data_n !***********************************************************************************************************) subroutine copy_n_s use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz u ( z , 1 , x , y ) = un ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_n_s subroutine copy_s_n use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz un ( z , 1 , x , y ) = u ( z , 1 , x , y ) un ( z , 2 , x , y ) = u ( z , 2 , x , y ) un ( z , 3 , x , y ) = u ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_s_n !(*********************************************************************************************************** !                         advance :     second-order runge-kutta time step algorithm !***********************************************************************************************************) subroutine advance use run_size implicit none integer ( int64 ) :: x , y , z real :: factor , xyfac , zfac ( nz ) !(* viscous integrating factors *) if ( rkstep == 1 ) then do z = 1 , nz ; zfac ( z ) = exp ( - viscos * dt * kz ( z ) ** 2 ); end do do x = first_x , last_x do y = 1 , ny ky_ ( x , y ) = ky ( x , y ) ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ) do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else factor = zfac ( z ) * exp ( - viscos * dt * ( kx ( x ) ** 2 + ( ky_ ( x , y ) ** 2 + ky_ ( x , y ) * ky ( x , y ) + ky ( x , y ) ** 2 ) / 3 ) ) un ( z , 1 , x , y ) = factor * ( un ( z , 1 , x , y ) + u ( z , 1 , x , y ) ) u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + factor * u ( z , 1 , x , y ) un ( z , 2 , x , y ) = factor * ( un ( z , 2 , x , y ) + u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + factor * u ( z , 2 , x , y ) un ( z , 3 , x , y ) = factor * ( un ( z , 3 , x , y ) + u ( z , 3 , x , y ) ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + factor * u ( z , 3 , x , y ) end if end do ; end do ; end do else if ( rkstep == 2 ) then do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + u ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + u ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + u ( z , 3 , x , y ) end if end do ; end do ; end do end if end  subroutine advance end   subroutine solve_navier_stokes","tags":"","loc":"sourcefile/coarray-shear.f90.html","title":"coarray-shear.f90 – OpenCoarrays"},{"text":"Source Code ! Coarray 3D Navier-Stokes Solver Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !(*---------------------------------------------------------------------------------------------------------------------- !         basic in-core shear code ( 7 words/node, not threaded, in-core, no file read/write ) !------------------------------------------------------------------------------------------------------------------------*) ! Define universal constants: ! In the case of exactly representable numbers, the definitions are useful ! to ensure subprogram argument type/kind/rank matching without having to ! repeat kind specifiers everywhere. module constants_module use iso_fortran_env , only : int64 implicit none private public :: one , zero integer ( int64 ), parameter :: one = 1_int64 , zero = 0_int64 end module ! Initialize the random seed with a varying seed to ensure a different ! random number sequence for each invocation of subroutine, e.g. for ! invocations on different images of a coarray parallel program. ! Setting any seed values to zero is deprecated because it can result ! in low-quality random number sequences. ! (Source: https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fSEED.html) module random_module implicit none private public :: init_random_seed contains subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed end module random_module module run_size use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use constants_module , only : one ! 64-bit unit to ensure argument kind match #ifndef HAVE_WALLTIME use MPI , only : WALLTIME => MPI_WTIME #endif implicit none real , codimension [ * ] :: viscos , shear , b11 , b22 , b33 , b12 , velmax integer ( int64 ), codimension [ * ] :: nx , ny , nz , nsteps , output_step integer ( int64 ), codimension [ * ] :: my , mx , first_y , last_y , first_x , last_x real ( real64 ), codimension [ * ] :: cpu_time_ , tran_time , sync_time , total_time real ( real64 ), codimension [ * ] :: max_cpu_time , max_tran_time , max_sync_time , max_total_time real ( real64 ), codimension [ * ] :: min_cpu_time , min_tran_time , min_sync_time , min_total_time real :: time , cfl , dt integer ( int64 ) :: my_node , num_nodes real , parameter :: pi = 3.141592653589793 contains subroutine max_velmax () integer ( int64 ) :: i ! sync all ! if( my_node == 1) then !     do i = 2, num_nodes;     velmax = max( velmax, velmax[i] );    end do ! end if ! sync all call co_max ( velmax , 1 ) if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time_ max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time_ min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time_ [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time_ [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3 end module run_size program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface num_nodes = num_images () my_node = this_image () nx = 128 ; ny = 128 ; nz = 128 viscos = 0. ; shear = 0. b11 = 1. ; b22 = 1. ; b33 = 1. ; b12 = 0. nsteps = 5 ; output_step = 1 if ( my_node == 1 ) then !write(6,*) \"nx,ny,nz : \";               read(5,*) nx, ny, nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if !write(6,*) \"viscos, shear : \";          read(5,*) viscos, shear !write(6,*) \"b11 b22 b33 b12 : \";        read(5,*) b11, b22, b33, b12 !write(6,*) \"nsteps, output_step : \";    read(5,*) nsteps, output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes if ( this_image () == 1 ) print * , \"Test passed.\" end program cshear !  (*********************************************************************************************************** !             n a v i e r - s t o k e s   s o l v e r !  ************************************************************************************************************) subroutine solve_navier_stokes use run_size implicit none !(*****************************   declarations     ****************************************) integer ( int64 ) :: stop , rflag , oflag , step , rkstep , nshells real :: k1 ( nx / 2 ), k2 ( ny ), k3 ( nz ), mk1 ( nx / 2 ), mk2 ( ny ), mk3 ( nz ) & , kx ( nx / 2 ), ky_ ( nx / 2 , ny ), ky ( nx / 2 , ny ), kz ( nz ) complex :: sx ( nx / 2 , 3 ), sy ( ny , 3 ), sz ( nz , 3 ) integer ( int64 ) :: trigx , trigy , trigz , trigxy complex , allocatable :: u (:,:,:,:)[:] ! u(nz,4,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: ur (:,:,:,:)[:] !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- x-z planes --*) complex , allocatable :: un (:,:,:,:) !un(nz,3,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: bufr_X_Y (:,:,:,:) complex , allocatable :: bufr_Y_X (:,:,:,:) real :: t_start , t_end interface !--------    note: integer(int64)'s required for FFT's and other assembly-coded externals   ------ function ctrig ( len ) bind ( C ) !(*-- define complex FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: ctrig !-- C pointer! end function ctrig function rtrig ( len ) bind ( C ) !(*-- define real FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: rtrig !-- C pointer! end function rtrig subroutine cfft ( len , lot , data , inc , jmp , ctrig , isign ) bind ( C ) !(*-- complex FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , ctrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine cfft subroutine rfft ( len , lot , data , inc , jmp , rtrig , isign ) bind ( C ) !(*-- real FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , rtrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine rfft #ifdef HAVE_WALLTIME function WALLTIME () bind ( C , name = \"WALLTIME\" ) import real64 real ( real64 ) :: WALLTIME end function WALLTIME #endif end interface trigx = rtrig ( nx ) trigy = ctrig ( ny ) trigz = ctrig ( nz ) trigxy = ctrig ( nx + ny ) allocate ( u ( nz , 4 , first_x : last_x , ny )[ * ] ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 )[ * ] ) !(*-- x-z planes --*) allocate ( un ( nz , 3 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( bufr_X_Y ( nz , 4 , mx , my ) ) allocate ( bufr_Y_X ( nz , 4 , my , mx ) ) stop = 0 ; step = 0 ; rkstep = 2 ; rflag = 0 ; cfl = 1 ; dt = 0 nshells = max ( nx , ny , nz ) call define_kspace call define_field call enforce_conjugate_symmetry call copy_n_s call define_shifts total_time = - WALLTIME () !-- start the clock tran_time = 0 ; cpu_time_ = - WALLTIME () !(*********************************   begin execution loop   *****************************************) do while ( stop == 0 ) call phase1 rkstep = 1 call transpose_X_Y call phase2 call transpose_Y_X call define_step call define_shifts call phase3 call pressure if ( oflag /= 0 ) call spectra call advance call phase1 rkstep = 2 call transpose_X_Y call phase2 call transpose_Y_X call phase3 call advance call pressure if ( rflag /= 0 ) call remesh call copy_s_n step = step + 1 time = time + dt end do !(*********************************   end execution loop   ***********************************************) deallocate ( u , ur , un ) deallocate ( bufr_X_Y ); deallocate ( bufr_Y_X ) sync all !-- wait for all images to finish! total_time = total_time + WALLTIME () !-- stop the clock cpu_time_ = cpu_time_ + WALLTIME () !-- stop the clock call global_times if ( my_node == 1 ) write ( 6 , fmt = \"(3(10X,A,2f7.2))\" ) & \"total_time \" , min_total_time / step , max_total_time / step & , \"cpu_time_ \" , min_cpu_time / step , max_cpu_time / step & , \"tran_time \" , min_tran_time / step , max_tran_time / step write ( 6 , fmt = \"(A,i4,3f7.2)\" ) \"image \" , my_node , total_time / step , cpu_time_ / step , tran_time / step contains !(*********************************************************************************************************** !                          transpose the Y and Z planes !***********************************************************************************************************) !-----                   u(nz,4,mx,my*num_nodes) [num_nodes] !-----                  ur(nz,4,my,mx*num_nodes) [num_nodes] !-----                bufr(nz,4,my,mx) or bufr(nz,4,mx,my) !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use constants_module , only : one use run_size implicit none integer ( int64 ) :: i , stage real :: t_start , t_end cpu_time_ = cpu_time_ + WALLTIME () sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time_ = cpu_time_ - WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use run_size implicit none integer ( int64 ) :: i , stage cpu_time_ = cpu_time_ + WALLTIME () sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , one , one & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , one , one & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time_ = cpu_time_ - WALLTIME () end  subroutine transpose_Y_X !(************************************************************************************************************* !           enforce conjugate symmetry for plane kx=0 of wavespace  (half of this plane is redundant) !***************************************************************************************************************) subroutine enforce_conjugate_symmetry integer ( int64 ) :: i , x , y , z !(*------------------------- un( K ) = conjg( un( -K ) ) ---------------------*) if ( my_node == 1 ) then !-- x=1 is in node=1 x = 1 do i = 1 , 3 z = 1 ; y = 1 ; un ( z , i , x , y ) = 0 z = 1 ; do y = 2 , ny / 2 ; un ( z , i , x , y ) = conjg ( un ( z , i , x , ny + 2 - y ) ); end do do z = 2 , nz / 2 ; y = 1 ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , y ) ); end do do z = 2 , nz / 2 ; do y = 2 , ny ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , ny + 2 - y ) ); end do ; end do end do end if end  subroutine enforce_conjugate_symmetry !(*********************************************************************************************************** !                spectra :  accumulate spectra and other statistics over flow field !***********************************************************************************************************) subroutine spectra use run_size implicit none integer ( int64 ) :: k , x , y , z real :: kk , ww , uw , uu , uv , duu , factor & , ek ( nshells ), dk ( nshells ), hk ( nshells ), tk ( nshells ), sample ( nshells ) real , save , codimension [ * ] :: sum_ek , sum_dk , sum_hk , sum_tk real , save :: sum_ek_initial , sum_dk_initial , sum_hk_initial , sum_tk_initial logical , save :: first_call = . true . real , parameter :: tolerance = 0.01 , negligible = 0.001 total_time = total_time + WALLTIME () !-- stop the clock!  time/step does not include spectra time oflag = 0 ek = 0 ; dk = 0 ; hk = 0 ; tk = 0 ; sample = 0 !(*---------------------   three dimensional spectra  -----------------------*) do x = first_x , last_x ; do y = 1 , ny ; do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; factor = 0 else if ( x == 1 ) then ; factor = 1 else ; factor = 2 end if kk = kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 k = 1 + int ( sqrt ( kk ) + 0.5 ) uu = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( un ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( un ( z , 3 , x , y ) ) ) ww = kk * uu uv = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) uw = factor * 2 * aimag ( kx ( x ) * un ( z , 2 , x , y ) * conjg ( un ( z , 3 , x , y ) ) & + ky ( x , y ) * un ( z , 3 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + kz ( z ) * un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) duu = factor * real ( un ( z , 1 , x , y ) * conjg ( u ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( u ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( u ( z , 3 , x , y ) ) ) / ( dt / 2 ) + shear * uv sample ( k ) = sample ( k ) + factor !(*-- shell sample --*) ek ( k ) = ek ( k ) + uu !(*-- 2 * energy sum --*) dk ( k ) = dk ( k ) + ww !(*-- enstrophy sum --*) hk ( k ) = hk ( k ) + uw !(*-- helicity sum --*) tk ( k ) = tk ( k ) + duu !(*-- transfer sum --*) end do ; end do ; end do !(************************     finished accumulation :  compute final statistics     *************************) sum_ek = 0 ; sum_dk = 0 ; sum_hk = 0 ; sum_tk = 0 do k = nshells , 1 , - 1 sum_ek = sum_ek + ek ( k ) sum_dk = sum_dk + dk ( k ) sum_hk = sum_hk + hk ( k ) sum_tk = sum_tk + tk ( k ) end do sync all call co_sum ( sum_ek , 1 ) call co_sum ( sum_dk , 1 ) call co_sum ( sum_hk , 1 ) call co_sum ( sum_tk , 1 ) if ( my_node == 1 ) then ! do k = 2, num_nodes !     sum_ek = sum_ek + sum_ek[k] !     sum_dk = sum_dk + sum_dk[k] !     sum_hk = sum_hk + sum_hk[k] !     sum_tk = sum_tk + sum_tk[k] ! end do if ( step == 0 ) write ( 6 , * ) \"step   time     energy    enstrophy   helicity   transfer\" write ( 6 , fmt = \"(i3, 5e11.3)\" ) step , time , sum_ek , sum_dk , sum_hk , sum_tk if ( first_call ) then first_call = . false . sum_ek_initial = sum_ek sum_dk_initial = sum_dk sum_hk_initial = sum_hk sum_tk_initial = sum_tk else if ( abs (( sum_ek_initial - sum_ek ) / sum_ek ) > tolerance ) error stop \"Test failed\" if ( abs (( sum_dk_initial - sum_dk ) / sum_dk ) > tolerance ) error stop \"Test failed\" if ( abs (( sum_hk_initial - sum_hk ) / sum_hk ) > tolerance ) error stop \"Test failed\" if ( abs (( sum_tk_initial - sum_tk ) / sum_ek ) > negligible ) error stop \"Test failed\" end if end if total_time = total_time - WALLTIME () !-- restart the clock! end  subroutine spectra !(************************************************************************************************************ !        define_field  :   define initial flow field from scratch !************************************************************************************************************) subroutine define_field use constants_module , only : zero use run_size use random_module implicit none real :: k , k12 , f , phi , theta1 , theta2 complex :: alpha , beta integer ( int64 ) :: x , y , z real , parameter :: klo = 8 , khi = 16 call init_random_seed !(* seed a different pseudo-random number sequence for each image *) time = 0 do x = first_x , last_x do y = 1 , ny do z = 1 , nz call random_number ( theta1 ) call random_number ( theta2 ) call random_number ( phi ) k = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) k12 = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 ) if ( k == 0 . or . mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. . or . k < klo . or . k > khi ) & then ; f = 0 else ; f = sqrt ( 1. / ( 2 * pi ) ) / k end if alpha = f * exp ( ( 0 , 2 ) * pi * theta1 ) * cos ( 2 * pi * phi ) beta = f * exp ( ( 0 , 2 ) * pi * theta2 ) * sin ( 2 * pi * phi ) if ( k12 == 0 ) & then ; un ( z , 1 , x , y ) = alpha un ( z , 2 , x , y ) = beta un ( z , 3 , x , y ) = 0 else ; un ( z , 1 , x , y ) = ( beta * kz ( z ) * kx ( x ) + alpha * k * ky ( x , y ) ) / ( k * k12 ) un ( z , 2 , x , y ) = ( beta * kz ( z ) * ky ( x , y ) - alpha * k * kx ( x ) ) / ( k * k12 ) un ( z , 3 , x , y ) = - beta * k12 / k end if end do ; end do ; end do end  subroutine define_field !(*********************************************************************************************************** !          define_shifts  :    define coordinate shifts for control of 1-d alias errors ! ***********************************************************************************************************) subroutine define_shifts use constants_module , only : zero use run_size implicit none integer ( int64 ) :: x , y , z integer ( int64 ), save :: init = 0 real :: delta_x , delta_y , delta_z integer :: i , seed_size if ( init == 0 ) & !-- Note: delta's not carried over from previous run then ; init = 1 call random_seed ( size = seed_size ) call random_seed ( put = [( 1234567 , i = 1 , seed_size )]) !(* same random numbers for each image! *) do x = 1 , nx / 2 ; sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( pi / nx ) * k1 ( x ) ); end do do y = 1 , ny ; sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( pi / ny ) * k2 ( y ) ); end do do z = 1 , nz ; sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( pi / nz ) * k3 ( z ) ); end do else ; call random_number ( delta_x ); delta_x = 2 * pi / nx * delta_x do x = 1 , nx / 2 ; sx ( x , 1 ) = sx ( x , 3 ) sx ( x , 2 ) = exp ( ( 0 , 1 ) * delta_x * k1 ( x ) ) sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( delta_x + pi / nx ) * k1 ( x ) ); end do call random_number ( delta_y ); delta_y = 2 * pi / ny * delta_y do y = 1 , ny ; sy ( y , 1 ) = sy ( y , 3 ) sy ( y , 2 ) = exp ( ( 0 , 1 ) * delta_y * k2 ( y ) ) sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( delta_y + pi / ny ) * k2 ( y ) ); end do call random_number ( delta_z ); delta_z = 2 * pi / nz * delta_z do z = 1 , nz ; sz ( z , 1 ) = sz ( z , 3 ) sz ( z , 2 ) = exp ( ( 0 , 1 ) * delta_z * k3 ( z ) ) sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( delta_z + pi / nz ) * k3 ( z ) ); end do end if end  subroutine define_shifts !(*********************************************************************************************************** !       define_step  :   update time, metric, shifts for the next step !**********************************************************************************************************) subroutine define_step use run_size implicit none sync all if ( cfl /= 0 ) then cpu_time_ = cpu_time_ + WALLTIME () call max_velmax cpu_time_ = cpu_time_ - WALLTIME () dt = cfl / velmax end if if ( shear > 0 & . and . . 01 * b11 * shear * dt < b12 & . and . b12 <= b11 * shear * dt ) then dt = b12 / ( b11 * shear ) !(* limit dt, hit the orthognal mesh *) oflag = 1 else if ( mod ( step , output_step ) == 0 ) then oflag = 1 end if b12 = b12 - b11 * shear * dt if ( b12 < - b22 / 2 ) rflag = 1 !(* remesh at the end of the step? *) if ( step == nsteps ) stop = 1 !(* last step? *) end   subroutine define_step !(*********************************************************************************************************** !      define_kspace  :   define physical wavespace from computational wavespace and metric !**********************************************************************************************************) subroutine define_kspace use run_size implicit none integer ( int64 ) :: x , y , z do x = 1 , nx / 2 ; k1 ( x ) = x - 1 ; end do do y = 1 , ny / 2 + 1 ; k2 ( y ) = y - 1 ; end do do z = 1 , nz / 2 + 1 ; k3 ( z ) = z - 1 ; end do do y = ny / 2 + 2 , ny ; k2 ( y ) = y - 1 - ny ; end do do z = nz / 2 + 2 , nz ; k3 ( z ) = z - 1 - nz ; end do do x = 1 , nx / 2 ; mk1 ( x ) = ( k1 ( x ) / nx ) ** 2 ; kx ( x ) = b11 * k1 ( x ); end do do z = 1 , nz ; mk3 ( z ) = ( k3 ( z ) / nz ) ** 2 ; kz ( z ) = b33 * k3 ( z ); end do do y = 1 , ny ; mk2 ( y ) = ( k2 ( y ) / ny ) ** 2 do x = 1 , nx / 2 ; ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ); end do ; end do end   subroutine define_kspace !(*********************************************************************************************************** !   phase 1 :  on entry, data-plane contains velocity in wave space.  interpolate database, shifted mesh, !              and proceed to physical y space . !************************************************************************************************************) subroutine phase1 use run_size implicit none complex :: shift integer ( int64 ) :: i , x , y , z do x = first_x , last_x do y = 1 , ny ; do z = 1 , nz shift = sz ( z , rkstep + 1 ) * sy ( y , rkstep + 1 ) * sx ( x , rkstep + 1 ) u ( z , 1 , x , y ) = shift * u ( z , 1 , x , y ) u ( z , 2 , x , y ) = shift * u ( z , 2 , x , y ) u ( z , 3 , x , y ) = shift * u ( z , 3 , x , y ) end do ; end do !(*---------------------------   LEAVING FOURIER WAVE SPACE  --------------------------*) do i = 1 , 3 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , one ); end do end do end   subroutine phase1 !(********************************************************************************************************** !     phase 2 :  on entry, data-plane contains velocity in physical y space, and wave x,z space on shifted !                mesh.  Proceed to physical x,z space,  form nonlinear terms, and return to wave x,z space. !***********************************************************************************************************) subroutine phase2 use run_size implicit none complex :: s2 ( nz , nx / 2 ), vs ( nz , nx / 2 ) integer ( int64 ) :: i , x , y , z real :: v2r , v2i , s2r , s2i , u1r , u1i , u2r , u2i , u3r , u3i , u4r , u4i velmax = 0 do y = first_y , last_y do x = 1 , nx / 2 ; do z = 1 , nz ; vs ( z , x ) = ur ( z , 2 , y , x ); end do ; end do do i = 1 , 3 call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , one ) call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , one ) end do !(*----------------------------  WELCOME TO PHYSICAL SPACE  --------------------------*) do x = 1 , nx / 2 ; do z = 1 , nz u1r = real ( ur ( z , 1 , y , x )); u1i = aimag ( ur ( z , 1 , y , x )) u2r = real ( ur ( z , 2 , y , x )); u2i = aimag ( ur ( z , 2 , y , x )) u3r = real ( ur ( z , 3 , y , x )); u3i = aimag ( ur ( z , 3 , y , x )) if ( rkstep == 1 ) velmax = max ( velmax & , b11 * nx * abs ( u1r ) + b22 * ny * abs ( u2r ) + b33 * nz * abs ( u3r ) & , b11 * nx * abs ( u1i ) + b22 * ny * abs ( u2i ) + b33 * nz * abs ( u3i ) ) v2r = u2r * u2r ; v2i = u2i * u2i s2r = u1r * u3r ; s2i = u1i * u3i u4r = u2r * u3r ; u4i = u2i * u3i u3r = u3r * u3r - v2r ; u3i = u3i * u3i - v2i u2r = u1r * u2r ; u2i = u1i * u2i u1r = u1r * u1r - v2r ; u1i = u1i * u1i - v2i s2 ( z , x ) = cmplx ( s2r , s2i ) ur ( z , 1 , y , x ) = cmplx ( u1r , u1i ) ur ( z , 2 , y , x ) = cmplx ( u2r , u2i ) ur ( z , 3 , y , x ) = cmplx ( u3r , u3i ) ur ( z , 4 , y , x ) = cmplx ( u4r , u4i ) end do ; end do !(*----------------------------  LEAVING PHYSICAL SPACE  --------------------------*) do i = 1 , 4 call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , - one ) do z = 1 , nz ; ur ( z , i , y , 1 ) = cmplx ( real ( ur ( z , i , y , 1 )), 0 ); end do call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , - one ) end do call rfft ( nx , nz , s2 , nz , one , trigx , - one ) do z = 1 , nz ; s2 ( z , 1 ) = cmplx ( real ( s2 ( z , 1 )), 0 ); end do call cfft ( nz , nx / 2 , s2 , one , nz , trigz , - one ) do x = 1 , nx / 2 ; do z = 1 , nz ur ( z , 1 , y , x ) = kx ( x ) * ur ( z , 1 , y , x ) + kz ( z ) * s2 ( z , x ) - ( 0 , 1 ) * 2 * nx * nz * shear * vs ( z , x ) ur ( z , 3 , y , x ) = kx ( x ) * s2 ( z , x ) + kz ( z ) * ur ( z , 3 , y , x ) end do ; end do end do end  subroutine phase2 !(*********************************************************************************************************** !     phase 3 :  on entry, the data-plane contains the four stresses on a shifted mesh in physical y space, !                wave x,z space.   Return to y  wave space on unshifted mesh and complete time derivative of !                velocity ( not divergence free yet ) !***********************************************************************************************************) subroutine phase3 use run_size implicit none integer ( int64 ) :: i , x , y , z complex :: shift do x = first_x , last_x do i = 1 , 4 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , - one ) end do !(*---------------------------   WELCOME TO FOURIER WAVE SPACE  --------------------------*) do y = 1 , ny ; do z = 1 , nz shift = - dt / ( 4 * nx * ny * nz ) * ( 0 , 1 ) * conjg ( sy ( y , rkstep ) * sz ( z , rkstep ) * sx ( x , rkstep ) ) u ( z , 1 , x , y ) = shift * ( u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = shift * ( kx ( x ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 4 , x , y ) ) u ( z , 3 , x , y ) = shift * ( u ( z , 3 , x , y ) + ky ( x , y ) * u ( z , 4 , x , y ) ) end do ; end do end do end   subroutine phase3 !(*********************************************************************************************************** !   pressure :  add the gradient of a scalar, enforce continuity ( zero divergence ) !***********************************************************************************************************) subroutine pressure use run_size implicit none complex :: psi integer ( int64 ) :: x , y , z do x = first_x , last_x ; do y = 1 , ny if ( x /= 1 ) then do z = 1 , nz psi = ( kx ( x ) * u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 3 , x , y ) ) & / ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 1 , x , y ) = u ( z , 1 , x , y ) - kx ( x ) * psi u ( z , 2 , x , y ) = u ( z , 2 , x , y ) - ky ( x , y ) * psi u ( z , 3 , x , y ) = u ( z , 3 , x , y ) - kz ( z ) * psi end do else if ( y /= 1 ) then do z = 1 , nz psi = ( ky ( 1 , y ) * u ( z , 2 , 1 , y ) + kz ( z ) * u ( z , 3 , 1 , y ) ) & / ( ky ( 1 , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 2 , 1 , y ) = u ( z , 2 , 1 , y ) - ky ( 1 , y ) * psi u ( z , 3 , 1 , y ) = u ( z , 3 , 1 , y ) - kz ( z ) * psi end do else do z = 1 , nz ; u ( z , 3 , 1 , 1 ) = 0 ; end do end if end do ; end do end   subroutine pressure !(***************************************************************************************************************** !                                remesh  :  remesh the sheared coordinate system !*****************************************************************************************************************) subroutine remesh use constants_module , only : one use run_size implicit none complex :: u2 ( nx + ny , nz ), shift ( nx + ny ) integer ( int64 ) :: i , x , y , z write ( 6 , fmt = \"(A,i4)\" ) \"remesh image \" , my_node total_time = total_time + WALLTIME () !-- stop the clock! do x = first_x , last_x do y = 1 , nx + ny ; shift ( y ) = exp ( ( 0 , - 2 ) * pi / ( nx + ny ) * k1 ( x ) * ( y - 1 ) ) / ( nx + ny ); end do do i = 1 , 3 do z = 1 , nz do y = 1 , ny / 2 ; u2 ( y , z ) = u ( z , i , x , y ); end do do y = ny / 2 + 1 , nx + ny / 2 + 1 ; u2 ( y , z ) = 0 ; end do do y = nx + ny / 2 + 2 , nx + ny ; u2 ( y , z ) = u ( z , i , x , y - nx ); end do end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , one ) do z = 1 , nz ; do y = 1 , nx + ny ; u2 ( y , z ) = u2 ( y , z ) * shift ( y ); end do ; end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , - one ) do z = 1 , nz do y = 1 , ny / 2 if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y , z ) end if end do do y = ny / 2 + 1 , ny if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y + nx , z ) end if end do end do end do do y = 1 , ny ; ky ( x , y ) = ky ( x , y ) + b22 * k1 ( x ); end do !(* update ky for this x *) end do b12 = b12 + b22 ; rflag = 0 !(*   update metric, account for remesh    *) total_time = total_time - WALLTIME () !-- restart the clock! end subroutine remesh !(*********************************************************************************************************** !         copy_n_s,   copy_s_n :  copy data between data_s and data_n !***********************************************************************************************************) subroutine copy_n_s use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz u ( z , 1 , x , y ) = un ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_n_s subroutine copy_s_n use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz un ( z , 1 , x , y ) = u ( z , 1 , x , y ) un ( z , 2 , x , y ) = u ( z , 2 , x , y ) un ( z , 3 , x , y ) = u ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_s_n !(*********************************************************************************************************** !                         advance :     second-order runge-kutta time step algorithm !***********************************************************************************************************) subroutine advance use run_size implicit none integer ( int64 ) :: x , y , z real :: factor , xyfac , zfac ( nz ) !(* viscous integrating factors *) if ( rkstep == 1 ) then do z = 1 , nz ; zfac ( z ) = exp ( - viscos * dt * kz ( z ) ** 2 ); end do do x = first_x , last_x do y = 1 , ny ky_ ( x , y ) = ky ( x , y ) ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ) do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else factor = zfac ( z ) * exp ( - viscos * dt * ( kx ( x ) ** 2 + ( ky_ ( x , y ) ** 2 + ky_ ( x , y ) * ky ( x , y ) + ky ( x , y ) ** 2 ) / 3 ) ) un ( z , 1 , x , y ) = factor * ( un ( z , 1 , x , y ) + u ( z , 1 , x , y ) ) u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + factor * u ( z , 1 , x , y ) un ( z , 2 , x , y ) = factor * ( un ( z , 2 , x , y ) + u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + factor * u ( z , 2 , x , y ) un ( z , 3 , x , y ) = factor * ( un ( z , 3 , x , y ) + u ( z , 3 , x , y ) ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + factor * u ( z , 3 , x , y ) end if end do ; end do ; end do else if ( rkstep == 2 ) then do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + u ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + u ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + u ( z , 3 , x , y ) end if end do ; end do ; end do end if end  subroutine advance end   subroutine solve_navier_stokes","tags":"","loc":"sourcefile/coarray-shear_coll.f90.html","title":"coarray-shear_coll.F90 – OpenCoarrays"},{"text":"Source Code ! Coarray 3D Navier-Stokes Solver Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !(*---------------------------------------------------------------------------------------------------------------------- !         basic in-core shear code ( 7 words/node, not threaded, in-core, no file read/write ) !------------------------------------------------------------------------------------------------------------------------*) ! Define universal constants: ! In the case of exactly representable numbers, the definitions are useful ! to ensure subprogram argument type/kind/rank matching without having to ! repeat kind specifiers everywhere. module constants_module use iso_fortran_env , only : int64 implicit none private public :: one , zero integer ( int64 ), parameter :: one = 1_int64 , zero = 0_int64 end module ! Initialize the random seed with a varying seed to ensure a different ! random number sequence for each invocation of subroutine, e.g. for ! invocations on different images of a coarray parallel program. ! Setting any seed values to zero is deprecated because it can result ! in low-quality random number sequences. ! (Source: https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fSEED.html) module random_module implicit none private public :: init_random_seed contains subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed end module random_module module run_size use iso_fortran_env ! 64-bit integer and real kind parameters use constants_module , only : one ! 64-bit unit to ensure argument kind match implicit none real , codimension [ * ] :: viscos , shear , b11 , b22 , b33 , b12 , velmax integer ( int64 ), codimension [ * ] :: nx , ny , nz , nsteps , output_step integer ( int64 ), codimension [ * ] :: my , mx , first_y , last_y , first_x , last_x real ( real64 ), codimension [ * ] :: cpu_time , tran_time , sync_time , total_time real ( real64 ), codimension [ * ] :: max_cpu_time , max_tran_time , max_sync_time , max_total_time real ( real64 ), codimension [ * ] :: min_cpu_time , min_tran_time , min_sync_time , min_total_time type ( lock_type ), save :: l_xy_buff [ * ] type ( lock_type ), save :: l_yx_buff [ * ] real :: time , cfl , dt integer ( int64 ) :: my_node , num_nodes real , parameter :: pi = 3.141592653589793 contains subroutine max_velmax () integer ( int64 ) :: i ! sync all ! if( my_node == 1) then !     do i = 2, num_nodes;     velmax = max( velmax, velmax[i] );    end do ! end if ! sync all call co_max ( velmax , 1 ) if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3 end module run_size program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then write ( 6 , * ) \"nx,ny,nz : \" ; read ( 5 , * ) nx , ny , nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if write ( 6 , * ) \"viscos, shear : \" ; read ( 5 , * ) viscos , shear write ( 6 , * ) \"b11 b22 b33 b12 : \" ; read ( 5 , * ) b11 , b22 , b33 , b12 write ( 6 , * ) \"nsteps, output_step : \" ; read ( 5 , * ) nsteps , output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes end program cshear !  (*********************************************************************************************************** !             n a v i e r - s t o k e s   s o l v e r !  ************************************************************************************************************) subroutine solve_navier_stokes use run_size implicit none !(*****************************   declarations     ****************************************) integer ( int64 ) :: stop , rflag , oflag , step , rkstep , nshells real :: k1 ( nx / 2 ), k2 ( ny ), k3 ( nz ), mk1 ( nx / 2 ), mk2 ( ny ), mk3 ( nz ) & , kx ( nx / 2 ), ky_ ( nx / 2 , ny ), ky ( nx / 2 , ny ), kz ( nz ) complex :: sx ( nx / 2 , 3 ), sy ( ny , 3 ), sz ( nz , 3 ) integer ( int64 ) :: trigx , trigy , trigz , trigxy complex , allocatable :: u (:,:,:,:)[:] ! u(nz,4,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: ur (:,:,:,:)[:] !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- x-z planes --*) complex , allocatable :: un (:,:,:,:) !un(nz,3,first_x:last_x,ny)[*]    !(*-- x-y planes --*) complex , allocatable :: bufr_X_Y (:,:,:,:) complex , allocatable :: bufr_Y_X (:,:,:,:) interface !--------    note: integer(int64)'s required for FFT's and other assembly-coded externals   ------ function ctrig ( len ) bind ( C ) !(*-- define complex FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: ctrig !-- C pointer! end function ctrig function rtrig ( len ) bind ( C ) !(*-- define real FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: rtrig !-- C pointer! end function rtrig subroutine cfft ( len , lot , data , inc , jmp , ctrig , isign ) bind ( C ) !(*-- complex FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , ctrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine cfft subroutine rfft ( len , lot , data , inc , jmp , rtrig , isign ) bind ( C ) !(*-- real FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , rtrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine rfft function WALLTIME () bind ( C , name = \"WALLTIME\" ) import real64 real ( real64 ) :: WALLTIME end function WALLTIME end interface trigx = rtrig ( nx ) trigy = ctrig ( ny ) trigz = ctrig ( nz ) trigxy = ctrig ( nx + ny ) allocate ( u ( nz , 4 , first_x : last_x , ny )[ * ] ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 )[ * ] ) !(*-- x-z planes --*) allocate ( un ( nz , 3 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( bufr_X_Y ( nz , 4 , mx , my ) ) allocate ( bufr_Y_X ( nz , 4 , my , mx ) ) stop = 0 ; step = 0 ; rkstep = 2 ; rflag = 0 ; cfl = 1 ; dt = 0 nshells = max ( nx , ny , nz ) call define_kspace call define_field call enforce_conjugate_symmetry call copy_n_s call define_shifts total_time = - WALLTIME () !-- start the clock tran_time = 0 ; cpu_time = - WALLTIME () !(*********************************   begin execution loop   *****************************************) do while ( stop == 0 ) call phase1 rkstep = 1 call transpose_X_Y call phase2 call transpose_Y_X call define_step call define_shifts call phase3 call pressure if ( oflag /= 0 ) call spectra call advance call phase1 rkstep = 2 call transpose_X_Y call phase2 call transpose_Y_X call phase3 call advance call pressure if ( rflag /= 0 ) call remesh call copy_s_n step = step + 1 time = time + dt end do !(*********************************   end execution loop   ***********************************************) deallocate ( u , ur , un ) deallocate ( bufr_X_Y ); deallocate ( bufr_Y_X ) sync all !-- wait for all images to finish! total_time = total_time + WALLTIME () !-- stop the clock cpu_time = cpu_time + WALLTIME () !-- stop the clock call global_times if ( my_node == 1 ) write ( 6 , fmt = \"(3(10X,A,2f7.2))\" ) & , \"total_time \" , min_total_time / step , max_total_time / step & , \"cpu_time \" , min_cpu_time / step , max_cpu_time / step & , \"tran_time \" , min_tran_time / step , max_tran_time / step write ( 6 , fmt = \"(A,i4,3f7.2)\" ) \"image \" , my_node , total_time / step , cpu_time / step , tran_time / step contains !(*********************************************************************************************************** !                          transpose the Y and Z planes !***********************************************************************************************************) !-----                   u(nz,4,mx,my*num_nodes) [num_nodes] !-----                  ur(nz,4,my,mx*num_nodes) [num_nodes] !-----                bufr(nz,4,my,mx) or bufr(nz,4,mx,my) !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use constants_module , only : one use run_size use iso_fortran_env implicit none integer ( int64 ) :: i , stage !    type(lock_type),save :: l_xy_buff[*] cpu_time = cpu_time + WALLTIME () lock ( l_xy_buff [ this_image ()]) sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) unlock ( l_xy_buff [ this_image ()]) !    write(*,*) this_image(), 'unlocks itself xy' do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) lock ( l_xy_buff [ i ]) !\twrite(*,*) this_image(),'locks xy', i bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer unlock ( l_xy_buff [ i ]) !\twrite(*,*) this_image(),'unlocks xy',i call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do !    sync all     !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use run_size use iso_fortran_env implicit none integer ( int64 ) :: i , stage !    type(lock_type),save :: l_yx_buff[*] cpu_time = cpu_time + WALLTIME () lock ( l_yx_buff [ this_image ()]) !    sync images(*) sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , one , one & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) unlock ( l_yx_buff [ this_image ()]) do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) lock ( l_yx_buff [ i ]) !write(*,*) this_image(),'locks yx', i bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer unlock ( l_yx_buff [ i ]) !write(*,*) this_image(),'unlocks yx', i call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , one , one & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do !sync all     !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_Y_X !(************************************************************************************************************* !           enforce conjugate symmetry for plane kx=0 of wavespace  (half of this plane is redundant) !***************************************************************************************************************) subroutine enforce_conjugate_symmetry integer ( int64 ) :: i , x , y , z !(*------------------------- un( K ) = conjg( un( -K ) ) ---------------------*) if ( my_node == 1 ) then !-- x=1 is in node=1 x = 1 do i = 1 , 3 z = 1 ; y = 1 ; un ( z , i , x , y ) = 0 z = 1 ; do y = 2 , ny / 2 ; un ( z , i , x , y ) = conjg ( un ( z , i , x , ny + 2 - y ) ); end do do z = 2 , nz / 2 ; y = 1 ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , y ) ); end do do z = 2 , nz / 2 ; do y = 2 , ny ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , ny + 2 - y ) ); end do ; end do end do end if end  subroutine enforce_conjugate_symmetry !(*********************************************************************************************************** !                spectra :  accumulate spectra and other statistics over flow field !***********************************************************************************************************) subroutine spectra use run_size implicit none integer ( int64 ) :: k , x , y , z real :: kk , ww , uw , uu , uv , duu , factor & , ek ( nshells ), dk ( nshells ), hk ( nshells ), tk ( nshells ), sample ( nshells ) real , save , codimension [ * ] :: sum_ek , sum_dk , sum_hk , sum_tk total_time = total_time + WALLTIME () !-- stop the clock!  time/step does not include spectra time oflag = 0 ek = 0 ; dk = 0 ; hk = 0 ; tk = 0 ; sample = 0 !(*---------------------   three dimensional spectra  -----------------------*) do x = first_x , last_x ; do y = 1 , ny ; do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; factor = 0 else if ( x == 1 ) then ; factor = 1 else ; factor = 2 end if kk = kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 k = 1 + int ( sqrt ( kk ) + 0.5 ) uu = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( un ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( un ( z , 3 , x , y ) ) ) ww = kk * uu uv = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) uw = factor * 2 * aimag ( kx ( x ) * un ( z , 2 , x , y ) * conjg ( un ( z , 3 , x , y ) ) & + ky ( x , y ) * un ( z , 3 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + kz ( z ) * un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) duu = factor * real ( un ( z , 1 , x , y ) * conjg ( u ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( u ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( u ( z , 3 , x , y ) ) ) / ( dt / 2 ) + shear * uv sample ( k ) = sample ( k ) + factor !(*-- shell sample --*) ek ( k ) = ek ( k ) + uu !(*-- 2 * energy sum --*) dk ( k ) = dk ( k ) + ww !(*-- enstrophy sum --*) hk ( k ) = hk ( k ) + uw !(*-- helicity sum --*) tk ( k ) = tk ( k ) + duu !(*-- transfer sum --*) end do ; end do ; end do !(************************     finished accumulation :  compute final statistics     *************************) sum_ek = 0 ; sum_dk = 0 ; sum_hk = 0 ; sum_tk = 0 do k = nshells , 1 , - 1 sum_ek = sum_ek + ek ( k ) sum_dk = sum_dk + dk ( k ) sum_hk = sum_hk + hk ( k ) sum_tk = sum_tk + tk ( k ) end do sync all call co_sum ( sum_ek , 1 ) call co_sum ( sum_dk , 1 ) call co_sum ( sum_hk , 1 ) call co_sum ( sum_tk , 1 ) if ( my_node == 1 ) then ! do k = 2, num_nodes !     sum_ek = sum_ek + sum_ek[k] !     sum_dk = sum_dk + sum_dk[k] !     sum_hk = sum_hk + sum_hk[k] !     sum_tk = sum_tk + sum_tk[k] ! end do if ( step == 0 ) write ( 6 , * ) \"step   time     energy    enstrophy   helicity   transfer\" write ( 6 , fmt = \"(i3, 5e11.3)\" ) step , time , sum_ek , sum_dk , sum_hk , sum_tk end if total_time = total_time - WALLTIME () !-- restart the clock! end  subroutine spectra !(************************************************************************************************************ !        define_field  :   define initial flow field from scratch !************************************************************************************************************) subroutine define_field use constants_module , only : zero use run_size use random_module implicit none real :: k , k12 , f , phi , theta1 , theta2 complex :: alpha , beta integer ( int64 ) :: x , y , z real , parameter :: klo = 8 , khi = 16 call init_random_seed !(* seed a different pseudo-random number sequence for each image *) time = 0 do x = first_x , last_x do y = 1 , ny do z = 1 , nz call random_number ( theta1 ) call random_number ( theta2 ) call random_number ( phi ) k = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) k12 = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 ) if ( k == 0 . or . mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. . or . k < klo . or . k > khi ) & then ; f = 0 else ; f = sqrt ( 1. / ( 2 * pi ) ) / k end if alpha = f * exp ( ( 0 , 2 ) * pi * theta1 ) * cos ( 2 * pi * phi ) beta = f * exp ( ( 0 , 2 ) * pi * theta2 ) * sin ( 2 * pi * phi ) if ( k12 == 0 ) & then ; un ( z , 1 , x , y ) = alpha un ( z , 2 , x , y ) = beta un ( z , 3 , x , y ) = 0 else ; un ( z , 1 , x , y ) = ( beta * kz ( z ) * kx ( x ) + alpha * k * ky ( x , y ) ) / ( k * k12 ) un ( z , 2 , x , y ) = ( beta * kz ( z ) * ky ( x , y ) - alpha * k * kx ( x ) ) / ( k * k12 ) un ( z , 3 , x , y ) = - beta * k12 / k end if end do ; end do ; end do end  subroutine define_field !(*********************************************************************************************************** !          define_shifts  :    define coordinate shifts for control of 1-d alias errors ! ***********************************************************************************************************) subroutine define_shifts use constants_module , only : zero use run_size implicit none integer ( int64 ) :: x , y , z integer ( int64 ), save :: init = 0 real :: delta_x , delta_y , delta_z integer :: i , seed_size if ( init == 0 ) & !-- Note: delta's not carried over from previous run then ; init = 1 call random_seed ( size = seed_size ) call random_seed ( put = [( 1234567 , i = 1 , seed_size )]) !(* same random numbers for each image! *) do x = 1 , nx / 2 ; sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( pi / nx ) * k1 ( x ) ); end do do y = 1 , ny ; sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( pi / ny ) * k2 ( y ) ); end do do z = 1 , nz ; sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( pi / nz ) * k3 ( z ) ); end do else ; call random_number ( delta_x ); delta_x = 2 * pi / nx * delta_x do x = 1 , nx / 2 ; sx ( x , 1 ) = sx ( x , 3 ) sx ( x , 2 ) = exp ( ( 0 , 1 ) * delta_x * k1 ( x ) ) sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( delta_x + pi / nx ) * k1 ( x ) ); end do call random_number ( delta_y ); delta_y = 2 * pi / ny * delta_y do y = 1 , ny ; sy ( y , 1 ) = sy ( y , 3 ) sy ( y , 2 ) = exp ( ( 0 , 1 ) * delta_y * k2 ( y ) ) sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( delta_y + pi / ny ) * k2 ( y ) ); end do call random_number ( delta_z ); delta_z = 2 * pi / nz * delta_z do z = 1 , nz ; sz ( z , 1 ) = sz ( z , 3 ) sz ( z , 2 ) = exp ( ( 0 , 1 ) * delta_z * k3 ( z ) ) sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( delta_z + pi / nz ) * k3 ( z ) ); end do end if end  subroutine define_shifts !(*********************************************************************************************************** !       define_step  :   update time, metric, shifts for the next step !**********************************************************************************************************) subroutine define_step use run_size implicit none sync all if ( cfl /= 0 ) then cpu_time = cpu_time + WALLTIME () call max_velmax cpu_time = cpu_time - WALLTIME () dt = cfl / velmax end if if ( shear > 0 & . and . . 01 * b11 * shear * dt < b12 & . and . b12 <= b11 * shear * dt ) then dt = b12 / ( b11 * shear ) !(* limit dt, hit the orthognal mesh *) oflag = 1 else if ( mod ( step , output_step ) == 0 ) then oflag = 1 end if b12 = b12 - b11 * shear * dt if ( b12 < - b22 / 2 ) rflag = 1 !(* remesh at the end of the step? *) if ( step == nsteps ) stop = 1 !(* last step? *) end   subroutine define_step !(*********************************************************************************************************** !      define_kspace  :   define physical wavespace from computational wavespace and metric !**********************************************************************************************************) subroutine define_kspace use run_size implicit none integer ( int64 ) :: x , y , z do x = 1 , nx / 2 ; k1 ( x ) = x - 1 ; end do do y = 1 , ny / 2 + 1 ; k2 ( y ) = y - 1 ; end do do z = 1 , nz / 2 + 1 ; k3 ( z ) = z - 1 ; end do do y = ny / 2 + 2 , ny ; k2 ( y ) = y - 1 - ny ; end do do z = nz / 2 + 2 , nz ; k3 ( z ) = z - 1 - nz ; end do do x = 1 , nx / 2 ; mk1 ( x ) = ( k1 ( x ) / nx ) ** 2 ; kx ( x ) = b11 * k1 ( x ); end do do z = 1 , nz ; mk3 ( z ) = ( k3 ( z ) / nz ) ** 2 ; kz ( z ) = b33 * k3 ( z ); end do do y = 1 , ny ; mk2 ( y ) = ( k2 ( y ) / ny ) ** 2 do x = 1 , nx / 2 ; ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ); end do ; end do end   subroutine define_kspace !(*********************************************************************************************************** !   phase 1 :  on entry, data-plane contains velocity in wave space.  interpolate database, shifted mesh, !              and proceed to physical y space . !************************************************************************************************************) subroutine phase1 use run_size implicit none complex :: shift integer ( int64 ) :: i , x , y , z do x = first_x , last_x do y = 1 , ny ; do z = 1 , nz shift = sz ( z , rkstep + 1 ) * sy ( y , rkstep + 1 ) * sx ( x , rkstep + 1 ) u ( z , 1 , x , y ) = shift * u ( z , 1 , x , y ) u ( z , 2 , x , y ) = shift * u ( z , 2 , x , y ) u ( z , 3 , x , y ) = shift * u ( z , 3 , x , y ) end do ; end do !(*---------------------------   LEAVING FOURIER WAVE SPACE  --------------------------*) do i = 1 , 3 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , one ); end do end do end   subroutine phase1 !(********************************************************************************************************** !     phase 2 :  on entry, data-plane contains velocity in physical y space, and wave x,z space on shifted !                mesh.  Proceed to physical x,z space,  form nonlinear terms, and return to wave x,z space. !***********************************************************************************************************) subroutine phase2 use run_size implicit none complex :: s2 ( nz , nx / 2 ), vs ( nz , nx / 2 ) integer ( int64 ) :: i , x , y , z real :: v2r , v2i , s2r , s2i , u1r , u1i , u2r , u2i , u3r , u3i , u4r , u4i velmax = 0 do y = first_y , last_y do x = 1 , nx / 2 ; do z = 1 , nz ; vs ( z , x ) = ur ( z , 2 , y , x ); end do ; end do do i = 1 , 3 call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , one ) call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , one ) end do !(*----------------------------  WELCOME TO PHYSICAL SPACE  --------------------------*) do x = 1 , nx / 2 ; do z = 1 , nz u1r = real ( ur ( z , 1 , y , x )); u1i = aimag ( ur ( z , 1 , y , x )) u2r = real ( ur ( z , 2 , y , x )); u2i = aimag ( ur ( z , 2 , y , x )) u3r = real ( ur ( z , 3 , y , x )); u3i = aimag ( ur ( z , 3 , y , x )) if ( rkstep == 1 ) velmax = max ( velmax & , b11 * nx * abs ( u1r ) + b22 * ny * abs ( u2r ) + b33 * nz * abs ( u3r ) & , b11 * nx * abs ( u1i ) + b22 * ny * abs ( u2i ) + b33 * nz * abs ( u3i ) ) v2r = u2r * u2r ; v2i = u2i * u2i s2r = u1r * u3r ; s2i = u1i * u3i u4r = u2r * u3r ; u4i = u2i * u3i u3r = u3r * u3r - v2r ; u3i = u3i * u3i - v2i u2r = u1r * u2r ; u2i = u1i * u2i u1r = u1r * u1r - v2r ; u1i = u1i * u1i - v2i s2 ( z , x ) = cmplx ( s2r , s2i ) ur ( z , 1 , y , x ) = cmplx ( u1r , u1i ) ur ( z , 2 , y , x ) = cmplx ( u2r , u2i ) ur ( z , 3 , y , x ) = cmplx ( u3r , u3i ) ur ( z , 4 , y , x ) = cmplx ( u4r , u4i ) end do ; end do !(*----------------------------  LEAVING PHYSICAL SPACE  --------------------------*) do i = 1 , 4 call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , - one ) do z = 1 , nz ; ur ( z , i , y , 1 ) = cmplx ( real ( ur ( z , i , y , 1 )), 0 ); end do call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , - one ) end do call rfft ( nx , nz , s2 , nz , one , trigx , - one ) do z = 1 , nz ; s2 ( z , 1 ) = cmplx ( real ( s2 ( z , 1 )), 0 ); end do call cfft ( nz , nx / 2 , s2 , one , nz , trigz , - one ) do x = 1 , nx / 2 ; do z = 1 , nz ur ( z , 1 , y , x ) = kx ( x ) * ur ( z , 1 , y , x ) + kz ( z ) * s2 ( z , x ) - ( 0 , 1 ) * 2 * nx * nz * shear * vs ( z , x ) ur ( z , 3 , y , x ) = kx ( x ) * s2 ( z , x ) + kz ( z ) * ur ( z , 3 , y , x ) end do ; end do end do end  subroutine phase2 !(*********************************************************************************************************** !     phase 3 :  on entry, the data-plane contains the four stresses on a shifted mesh in physical y space, !                wave x,z space.   Return to y  wave space on unshifted mesh and complete time derivative of !                velocity ( not divergence free yet ) !***********************************************************************************************************) subroutine phase3 use run_size implicit none integer ( int64 ) :: i , x , y , z complex :: shift do x = first_x , last_x do i = 1 , 4 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , - one ) end do !(*---------------------------   WELCOME TO FOURIER WAVE SPACE  --------------------------*) do y = 1 , ny ; do z = 1 , nz shift = - dt / ( 4 * nx * ny * nz ) * ( 0 , 1 ) * conjg ( sy ( y , rkstep ) * sz ( z , rkstep ) * sx ( x , rkstep ) ) u ( z , 1 , x , y ) = shift * ( u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = shift * ( kx ( x ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 4 , x , y ) ) u ( z , 3 , x , y ) = shift * ( u ( z , 3 , x , y ) + ky ( x , y ) * u ( z , 4 , x , y ) ) end do ; end do end do end   subroutine phase3 !(*********************************************************************************************************** !   pressure :  add the gradient of a scalar, enforce continuity ( zero divergence ) !***********************************************************************************************************) subroutine pressure use run_size implicit none complex :: psi integer ( int64 ) :: x , y , z do x = first_x , last_x ; do y = 1 , ny if ( x /= 1 ) then do z = 1 , nz psi = ( kx ( x ) * u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 3 , x , y ) ) & / ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 1 , x , y ) = u ( z , 1 , x , y ) - kx ( x ) * psi u ( z , 2 , x , y ) = u ( z , 2 , x , y ) - ky ( x , y ) * psi u ( z , 3 , x , y ) = u ( z , 3 , x , y ) - kz ( z ) * psi end do else if ( y /= 1 ) then do z = 1 , nz psi = ( ky ( 1 , y ) * u ( z , 2 , 1 , y ) + kz ( z ) * u ( z , 3 , 1 , y ) ) & / ( ky ( 1 , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 2 , 1 , y ) = u ( z , 2 , 1 , y ) - ky ( 1 , y ) * psi u ( z , 3 , 1 , y ) = u ( z , 3 , 1 , y ) - kz ( z ) * psi end do else do z = 1 , nz ; u ( z , 3 , 1 , 1 ) = 0 ; end do end if end do ; end do end   subroutine pressure !(***************************************************************************************************************** !                                remesh  :  remesh the sheared coordinate system !*****************************************************************************************************************) subroutine remesh use constants_module , only : one use run_size implicit none complex :: u2 ( nx + ny , nz ), shift ( nx + ny ) integer ( int64 ) :: i , x , y , z write ( 6 , fmt = \"(A,i4)\" ) \"remesh image \" , my_node total_time = total_time + WALLTIME () !-- stop the clock! do x = first_x , last_x do y = 1 , nx + ny ; shift ( y ) = exp ( ( 0 , - 2 ) * pi / ( nx + ny ) * k1 ( x ) * ( y - 1 ) ) / ( nx + ny ); end do do i = 1 , 3 do z = 1 , nz do y = 1 , ny / 2 ; u2 ( y , z ) = u ( z , i , x , y ); end do do y = ny / 2 + 1 , nx + ny / 2 + 1 ; u2 ( y , z ) = 0 ; end do do y = nx + ny / 2 + 2 , nx + ny ; u2 ( y , z ) = u ( z , i , x , y - nx ); end do end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , one ) do z = 1 , nz ; do y = 1 , nx + ny ; u2 ( y , z ) = u2 ( y , z ) * shift ( y ); end do ; end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , - one ) do z = 1 , nz do y = 1 , ny / 2 if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y , z ) end if end do do y = ny / 2 + 1 , ny if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y + nx , z ) end if end do end do end do do y = 1 , ny ; ky ( x , y ) = ky ( x , y ) + b22 * k1 ( x ); end do !(* update ky for this x *) end do b12 = b12 + b22 ; rflag = 0 !(*   update metric, account for remesh    *) total_time = total_time - WALLTIME () !-- restart the clock! end subroutine remesh !(*********************************************************************************************************** !         copy_n_s,   copy_s_n :  copy data between data_s and data_n !***********************************************************************************************************) subroutine copy_n_s use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz u ( z , 1 , x , y ) = un ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_n_s subroutine copy_s_n use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz un ( z , 1 , x , y ) = u ( z , 1 , x , y ) un ( z , 2 , x , y ) = u ( z , 2 , x , y ) un ( z , 3 , x , y ) = u ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_s_n !(*********************************************************************************************************** !                         advance :     second-order runge-kutta time step algorithm !***********************************************************************************************************) subroutine advance use run_size implicit none integer ( int64 ) :: x , y , z real :: factor , xyfac , zfac ( nz ) !(* viscous integrating factors *) if ( rkstep == 1 ) then do z = 1 , nz ; zfac ( z ) = exp ( - viscos * dt * kz ( z ) ** 2 ); end do do x = first_x , last_x do y = 1 , ny ky_ ( x , y ) = ky ( x , y ) ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ) do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else factor = zfac ( z ) * exp ( - viscos * dt * ( kx ( x ) ** 2 + ( ky_ ( x , y ) ** 2 + ky_ ( x , y ) * ky ( x , y ) + ky ( x , y ) ** 2 ) / 3 ) ) un ( z , 1 , x , y ) = factor * ( un ( z , 1 , x , y ) + u ( z , 1 , x , y ) ) u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + factor * u ( z , 1 , x , y ) un ( z , 2 , x , y ) = factor * ( un ( z , 2 , x , y ) + u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + factor * u ( z , 2 , x , y ) un ( z , 3 , x , y ) = factor * ( un ( z , 3 , x , y ) + u ( z , 3 , x , y ) ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + factor * u ( z , 3 , x , y ) end if end do ; end do ; end do else if ( rkstep == 2 ) then do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + u ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + u ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + u ( z , 3 , x , y ) end if end do ; end do ; end do end if end  subroutine advance end   subroutine solve_navier_stokes","tags":"","loc":"sourcefile/coarray-shear_coll_lock.f90.html","title":"coarray-shear_coll_lock.f90 – OpenCoarrays"},{"text":"Source Code ! MPI 3D Navier-Stokes Solver Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! !(*---------------------------------------------------------------------------------------------------------------------- !         basic in-core shear code ( 7 words/node, not threaded, in-core, no file read/write ) !------------------------------------------------------------------------------------------------------------------------*) ! Define universal constants: ! In the case of exactly representable numbers, the definitions are useful ! to ensure subprogram argument type/kind/rank matching without having to ! repind kind specifiers everywhere. module constants_module use iso_fortran_env , only : int64 implicit none private public :: one , zero integer ( int64 ), parameter :: one = 1_int64 , zero = 0_int64 end module ! Initialize the random seed with a varying seed to ensure a different ! random number sequence for each invocation of subroutine, e.g. for ! invocations on different images of a coarray parallel program. ! Setting any seed values to zero is depcretated because it can result ! in low-quality random number sequences. ! (Source: https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fSEED.html) module random_module implicit none private public :: init_random_seed contains subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( un ) seed close ( un ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed end module random_module module run_size use iso_fortran_env , only : int64 , real64 implicit none include 'mpif.h' real :: viscos , shear , b11 , b22 , b33 , b12 , velmax , max_velmax integer ( int64 ) :: nx , ny , nz , nsteps , output_step integer ( int64 ) :: my , mx , first_y , last_y , first_x , last_x integer ( int64 ) :: ierror real ( real64 ) :: cpu_time , tran_time , total_time real ( real64 ) :: max_cpu_time , max_tran_time , max_total_time real ( real64 ) :: min_cpu_time , min_tran_time , min_total_time real :: time , cfl , dt integer ( int64 ) :: my_node , num_nodes real , parameter :: pi = 3.141592653589793 contains subroutine global_times () call MPI_REDUCE ( total_time , max_total_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( total_time , min_total_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( tran_time , max_tran_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( tran_time , min_tran_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( cpu_time , max_cpu_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( cpu_time , min_cpu_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) end subroutine global_times subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3 end module run_size program mshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface call MPI_INIT ( ierror ) call MPI_COMM_RANK ( MPI_COMM_WORLD , my_node , ierror ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , num_nodes , ierror ) if ( my_node == 0 ) then write ( 6 , * ) \"nx,ny,nz : \" ; read ( 5 , * ) nx , ny , nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if write ( 6 , * ) \"viscos, shear : \" ; read ( 5 , * ) viscos , shear write ( 6 , * ) \"b11 b22 b33 b12 : \" ; read ( 5 , * ) b11 , b22 , b33 , b12 write ( 6 , * ) \"nsteps, output_step : \" ; read ( 5 , * ) nsteps , output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if call MPI_BCAST ( nx , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( ny , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nz , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( viscos , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( shear , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b11 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b22 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b33 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b12 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nsteps , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( output_step , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) mx = nx / 2 / num_nodes ; first_x = my_node * mx + 1 ; last_x = my_node * mx + mx my = ny / num_nodes ; first_y = my_node * my + 1 ; last_y = my_node * my + my call solve_navier_stokes end program mshear !  (*********************************************************************************************************** !             n a v i e r - s t o k e s   s o l v e r !  ************************************************************************************************************) subroutine solve_navier_stokes use run_size implicit none !(*****************************   declarations     ****************************************) integer ( int64 ) :: stop , rflag , oflag , step , rkstep , nshells , msg_size real :: k1 ( nx / 2 ), k2 ( ny ), k3 ( nz ), mk1 ( nx / 2 ), mk2 ( ny ), mk3 ( nz ) & , kx ( nx / 2 ), ky_ ( nx / 2 , ny ), ky ( nx / 2 , ny ), kz ( nz ) complex :: sx ( nx / 2 , 3 ), sy ( ny , 3 ), sz ( nz , 3 ) integer ( int64 ) :: trigx , trigy , trigz , trigxy complex , allocatable :: u (:,:,:,:) ! u(nz,4,first_x:last_x,ny)    !(*-- x-y planes --*) complex , allocatable :: ur (:,:,:,:) !ur(nz,4,first_y:last_y,nx/2)  !(*-- x-z planes --*) complex , allocatable :: un (:,:,:,:) !un(nz,3,first_x:last_x,ny)    !(*-- x-y planes --*) complex , allocatable :: bufr (:) interface !--------    note: integer(int64)'s required for FFT's and other assembly-coded externals   ------ function ctrig ( len ) bind ( C ) !(*-- define complex FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: ctrig !-- C pointer! end function ctrig function rtrig ( len ) bind ( C ) !(*-- define real FFT trig table --*) import int64 integer ( int64 ), value , intent ( in ) :: len integer ( int64 ) :: rtrig !-- C pointer! end function rtrig subroutine cfft ( len , lot , data , inc , jmp , ctrig , isign ) bind ( C ) !(*-- complex FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , ctrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine cfft subroutine rfft ( len , lot , data , inc , jmp , rtrig , isign ) bind ( C ) !(*-- real FFT --*) import int64 integer ( int64 ), value , intent ( in ) :: len , lot , inc , jmp , rtrig , isign complex , dimension ( 0 : 0 ), intent ( in ) :: data end subroutine rfft function WALLTIME () bind ( C , name = \"WALLTIME\" ) import real64 real ( real64 ) :: WALLTIME end function WALLTIME end interface trigx = rtrig ( nx ) trigy = ctrig ( ny ) trigz = ctrig ( nz ) trigxy = ctrig ( nx + ny ) msg_size = nz * 4 * mx * my !-- message size (complex data items) allocate ( u ( nz , 4 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 ) ) !(*-- x-z planes --*) allocate ( un ( nz , 3 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( bufr ( msg_size ) ) stop = 0 ; step = 0 ; rkstep = 2 ; rflag = 0 ; cfl = 1 ; dt = 0 nshells = max ( nx , ny , nz ) call define_kspace call define_field call enforce_conjugate_symmetry call copy_n_s call define_shifts total_time = - WALLTIME () !-- start the clock tran_time = 0 ; cpu_time = - WALLTIME () !(*********************************   begin execution loop   *****************************************) do while ( stop == 0 ) call phase1 rkstep = 1 call transpose_X_Y call phase2 call transpose_Y_X call define_step call define_shifts call phase3 call pressure if ( oflag /= 0 ) call spectra call advance call phase1 rkstep = 2 call transpose_X_Y call phase2 call transpose_Y_X call phase3 call advance call pressure if ( rflag /= 0 ) call remesh call copy_s_n step = step + 1 time = time + dt end do !(*********************************   end execution loop   ***********************************************) deallocate ( u , ur , un ) deallocate ( bufr ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !-- other nodes wait for broadcast! total_time = total_time + WALLTIME () !-- stop the clock cpu_time = cpu_time + WALLTIME () !-- stop the clock call global_times if ( my_node == 0 ) write ( 6 , fmt = \"(3(10X,A,2f7.2))\" ) & , \"total_time \" , min_total_time / step , max_total_time / step & , \"cpu_time \" , min_cpu_time / step , max_cpu_time / step & , \"tran_time \" , min_tran_time / step , max_tran_time / step !       write(6,fmt=\"(A,i4,3f7.2)\")  \"image \", my_node, total_time/step, cpu_time/step, tran_time/step contains !(*********************************************************************************************************** !                          transpose the Y and Z planes !***********************************************************************************************************) !-----                   u(nz,4,mx,my*num_nodes) [num_nodes] !-----                  ur(nz,4,my,mx*num_nodes) [num_nodes] !-----                bufr(nz,4,my,mx) or bufr(nz,4,mx,my) !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use constants_module , only : one use run_size implicit none integer ( int64 ) :: to , from , stage , idr ( 0 : num_nodes - 1 ), ids , send_tag , recv_tag integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) cpu_time = cpu_time + WALLTIME () call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( ur ( 1 , 1 , first_y , 1 + from * mx ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   transpose my image's block (no communication needed)  ------------------ call copy3 ( u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- no inter-node transpose needed , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call copy3 ( u ( 1 , 1 , first_x , 1 + to * my ), bufr & !-- intra-node transpose from buffer , nz * 3 , one , one & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose (not needed) tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use constants_module , only : one use run_size implicit none integer ( int64 ) :: to , from , stage , idr ( 0 : num_nodes - 1 ), ids , send_tag , recv_tag integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) cpu_time = cpu_time + WALLTIME () call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( u ( 1 , 1 , first_x , 1 + from * my ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   transpose my image's block (no communication needed)  ------------------ call copy3 ( ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- no inter-node transpose needed , nz * 4 , one , one & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call copy3 ( ur ( 1 , 1 , first_y , 1 + to * mx ), bufr & !-- intra-node transpose from buffer , nz * 4 , one , one & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () cpu_time = cpu_time - WALLTIME () end  subroutine transpose_Y_X !(************************************************************************************************************* !           enforce conjugate symmetry for plane kx=0 of wavespace  (half of this plane is redundant) !***************************************************************************************************************) subroutine enforce_conjugate_symmetry integer ( int64 ) :: i , x , y , z !(*------------------------- un( K ) = conjg( un( -K ) ) ---------------------*) if ( my_node == 0 ) then !-- x=1 is in node=1 x = 1 do i = 1 , 3 z = 1 ; y = 1 ; un ( z , i , x , y ) = 0 z = 1 ; do y = 2 , ny / 2 ; un ( z , i , x , y ) = conjg ( un ( z , i , x , ny + 2 - y ) ); end do do z = 2 , nz / 2 ; y = 1 ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , y ) ); end do do z = 2 , nz / 2 ; do y = 2 , ny ; un ( z , i , x , y ) = conjg ( un ( nz + 2 - z , i , x , ny + 2 - y ) ); end do ; end do end do end if end  subroutine enforce_conjugate_symmetry !(*********************************************************************************************************** !                spectra :  accumulate spectra and other statistics over flow field !***********************************************************************************************************) subroutine spectra use run_size implicit none integer ( int64 ) :: k , x , y , z real :: kk , ww , uw , uu , uv , duu , factor & , ek ( nshells ), dk ( nshells ), hk ( nshells ), tk ( nshells ), sample ( nshells ) real , save :: sum_ek , sum_dk , sum_hk , sum_tk , ek_sum , dk_sum , hk_sum , tk_sum total_time = total_time + WALLTIME () !-- stop the clock!  time/step does not include spectra time oflag = 0 ek = 0 ; dk = 0 ; hk = 0 ; tk = 0 ; sample = 0 !(*---------------------   three dimensional spectra  -----------------------*) do x = first_x , last_x ; do y = 1 , ny ; do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; factor = 0 else if ( x == 1 ) then ; factor = 1 else ; factor = 2 end if kk = kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 k = 1 + int ( sqrt ( kk ) + 0.5 ) uu = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( un ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( un ( z , 3 , x , y ) ) ) ww = kk * uu uv = factor * real ( un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) uw = factor * 2 * aimag ( kx ( x ) * un ( z , 2 , x , y ) * conjg ( un ( z , 3 , x , y ) ) & + ky ( x , y ) * un ( z , 3 , x , y ) * conjg ( un ( z , 1 , x , y ) ) & + kz ( z ) * un ( z , 1 , x , y ) * conjg ( un ( z , 2 , x , y ) ) ) duu = factor * real ( un ( z , 1 , x , y ) * conjg ( u ( z , 1 , x , y ) ) & + un ( z , 2 , x , y ) * conjg ( u ( z , 2 , x , y ) ) & + un ( z , 3 , x , y ) * conjg ( u ( z , 3 , x , y ) ) ) / ( dt / 2 ) + shear * uv sample ( k ) = sample ( k ) + factor !(*-- shell sample --*) ek ( k ) = ek ( k ) + uu !(*-- 2 * energy sum --*) dk ( k ) = dk ( k ) + ww !(*-- enstrophy sum --*) hk ( k ) = hk ( k ) + uw !(*-- helicity sum --*) tk ( k ) = tk ( k ) + duu !(*-- transfer sum --*) end do ; end do ; end do !(************************     finished accumulation :  compute final statistics     *************************) sum_ek = 0 ; sum_dk = 0 ; sum_hk = 0 ; sum_tk = 0 do k = nshells , 1 , - 1 sum_ek = sum_ek + ek ( k ) sum_dk = sum_dk + dk ( k ) sum_hk = sum_hk + hk ( k ) sum_tk = sum_tk + tk ( k ) end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( sum_ek , ek_sum , 1 , MPI_FLOAT , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ); sum_ek = ek_sum call MPI_REDUCE ( sum_dk , dk_sum , 1 , MPI_FLOAT , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ); sum_dk = dk_sum call MPI_REDUCE ( sum_hk , hk_sum , 1 , MPI_FLOAT , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ); sum_hk = hk_sum call MPI_REDUCE ( sum_tk , tk_sum , 1 , MPI_FLOAT , MPI_SUM , 0 , MPI_COMM_WORLD , ierror ); sum_tk = tk_sum if ( my_node == 0 ) then if ( step == 0 ) write ( 6 , * ) \"step   time     energy    enstrophy   helicity   transfer\" write ( 6 , fmt = \"(i3, 5e11.3)\" ) step , time , sum_ek , sum_dk , sum_hk , sum_tk end if total_time = total_time - WALLTIME () !-- restart the clock! end  subroutine spectra !(************************************************************************************************************ !        define_field  :   define initial flow field from scratch !************************************************************************************************************) subroutine define_field use random_module , only : init_random_seed use run_size implicit none real :: k , k12 , f , phi , theta1 , theta2 complex :: alpha , beta integer ( int64 ) :: x , y , z real , parameter :: klo = 8 , khi = 16 time = 0 call init_random_seed do x = first_x , last_x do y = 1 , ny do z = 1 , nz call random_number ( theta1 ) call random_number ( theta2 ) call random_number ( phi ) k = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) k12 = sqrt ( kx ( x ) ** 2 + ky ( x , y ) ** 2 ) if ( k == 0 . or . mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. . or . k < klo . or . k > khi ) & then ; f = 0 else ; f = sqrt ( 1. / ( 2 * pi ) ) / k end if alpha = f * exp ( ( 0 , 2 ) * pi * theta1 ) * cos ( 2 * pi * phi ) beta = f * exp ( ( 0 , 2 ) * pi * theta2 ) * sin ( 2 * pi * phi ) if ( k12 == 0 ) & then ; un ( z , 1 , x , y ) = alpha un ( z , 2 , x , y ) = beta un ( z , 3 , x , y ) = 0 else ; un ( z , 1 , x , y ) = ( beta * kz ( z ) * kx ( x ) + alpha * k * ky ( x , y ) ) / ( k * k12 ) un ( z , 2 , x , y ) = ( beta * kz ( z ) * ky ( x , y ) - alpha * k * kx ( x ) ) / ( k * k12 ) un ( z , 3 , x , y ) = - beta * k12 / k end if end do ; end do ; end do end  subroutine define_field !(*********************************************************************************************************** !          define_shifts  :    define coordinate shifts for control of 1-d alias errors ! ***********************************************************************************************************) subroutine define_shifts use run_size implicit none integer :: seed_size integer ( int64 ) :: x , y , z , i integer ( int64 ), save :: init = 0 real :: delta_x , delta_y , delta_z if ( init == 0 ) & !-- Note: delta's not carried over from previous run then ; init = 1 call random_seed ( size = seed_size ) call random_seed ( put = [( 1234567 , i = 1 , seed_size )]) !(* same random numbers for each image! *) do x = 1 , nx / 2 ; sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( pi / nx ) * k1 ( x ) ); end do do y = 1 , ny ; sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( pi / ny ) * k2 ( y ) ); end do do z = 1 , nz ; sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( pi / nz ) * k3 ( z ) ); end do else ; call random_number ( delta_x ); delta_x = 2 * pi / nx * delta_x do x = 1 , nx / 2 ; sx ( x , 1 ) = sx ( x , 3 ) sx ( x , 2 ) = exp ( ( 0 , 1 ) * delta_x * k1 ( x ) ) sx ( x , 3 ) = exp ( ( 0 , 1 ) * ( delta_x + pi / nx ) * k1 ( x ) ); end do call random_number ( delta_y ); delta_y = 2 * pi / ny * delta_y do y = 1 , ny ; sy ( y , 1 ) = sy ( y , 3 ) sy ( y , 2 ) = exp ( ( 0 , 1 ) * delta_y * k2 ( y ) ) sy ( y , 3 ) = exp ( ( 0 , 1 ) * ( delta_y + pi / ny ) * k2 ( y ) ); end do call random_number ( delta_z ); delta_z = 2 * pi / nz * delta_z do z = 1 , nz ; sz ( z , 1 ) = sz ( z , 3 ) sz ( z , 2 ) = exp ( ( 0 , 1 ) * delta_z * k3 ( z ) ) sz ( z , 3 ) = exp ( ( 0 , 1 ) * ( delta_z + pi / nz ) * k3 ( z ) ); end do end if end  subroutine define_shifts !(*********************************************************************************************************** !       define_step  :   update time, metric, shifts for the next step !**********************************************************************************************************) subroutine define_step use run_size implicit none call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) if ( cfl /= 0 ) then cpu_time = cpu_time + WALLTIME () call MPI_ALLREDUCE ( velmax , max_velmax , 1 , MPI_REAL , MPI_MAX , MPI_COMM_WORLD , ierror ) velmax = max_velmax cpu_time = cpu_time - WALLTIME () dt = cfl / velmax end if if ( shear > 0 & . and . . 01 * b11 * shear * dt < b12 & . and . b12 <= b11 * shear * dt ) then dt = b12 / ( b11 * shear ) !(* limit dt, hit the orthognal mesh *) oflag = 1 else if ( mod ( step , output_step ) == 0 ) then oflag = 1 end if b12 = b12 - b11 * shear * dt if ( b12 < - b22 / 2 ) rflag = 1 !(* remesh at the end of the step? *) if ( step == nsteps ) stop = 1 !(* last step? *) end   subroutine define_step !(*********************************************************************************************************** !      define_kspace  :   define physical wavespace from computational wavespace and metric !**********************************************************************************************************) subroutine define_kspace use run_size implicit none integer ( int64 ) :: x , y , z do x = 1 , nx / 2 ; k1 ( x ) = x - 1 ; end do do y = 1 , ny / 2 + 1 ; k2 ( y ) = y - 1 ; end do do z = 1 , nz / 2 + 1 ; k3 ( z ) = z - 1 ; end do do y = ny / 2 + 2 , ny ; k2 ( y ) = y - 1 - ny ; end do do z = nz / 2 + 2 , nz ; k3 ( z ) = z - 1 - nz ; end do do x = 1 , nx / 2 ; mk1 ( x ) = ( k1 ( x ) / nx ) ** 2 ; kx ( x ) = b11 * k1 ( x ); end do do z = 1 , nz ; mk3 ( z ) = ( k3 ( z ) / nz ) ** 2 ; kz ( z ) = b33 * k3 ( z ); end do do y = 1 , ny ; mk2 ( y ) = ( k2 ( y ) / ny ) ** 2 do x = 1 , nx / 2 ; ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ); end do ; end do end   subroutine define_kspace !(*********************************************************************************************************** !   phase 1 :  on entry, data-plane contains velocity in wave space.  interpolate database, shifted mesh, !              and proceed to physical y space . !************************************************************************************************************) subroutine phase1 use constants_module , only : one use run_size implicit none complex :: shift integer ( int64 ) :: i , x , y , z do x = first_x , last_x do y = 1 , ny ; do z = 1 , nz shift = sz ( z , rkstep + 1 ) * sy ( y , rkstep + 1 ) * sx ( x , rkstep + 1 ) u ( z , 1 , x , y ) = shift * u ( z , 1 , x , y ) u ( z , 2 , x , y ) = shift * u ( z , 2 , x , y ) u ( z , 3 , x , y ) = shift * u ( z , 3 , x , y ) end do ; end do !(*---------------------------   LEAVING FOURIER WAVE SPACE  --------------------------*) do i = 1 , 3 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , one ); end do end do end   subroutine phase1 !(********************************************************************************************************** !     phase 2 :  on entry, data-plane contains velocity in physical y space, and wave x,z space on shifted !                mesh.  Proceed to physical x,z space,  form nonlinear terms, and return to wave x,z space. !***********************************************************************************************************) subroutine phase2 use constants_module , only : one use run_size implicit none complex :: s2 ( nz , nx / 2 ), vs ( nz , nx / 2 ) integer ( int64 ) :: i , x , y , z real :: v2r , v2i , s2r , s2i , u1r , u1i , u2r , u2i , u3r , u3i , u4r , u4i velmax = 0 do y = first_y , last_y do x = 1 , nx / 2 ; do z = 1 , nz ; vs ( z , x ) = ur ( z , 2 , y , x ); end do ; end do do i = 1 , 3 call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , one ) call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , one ) end do !(*----------------------------  WELCOME TO PHYSICAL SPACE  --------------------------*) do x = 1 , nx / 2 ; do z = 1 , nz u1r = real ( ur ( z , 1 , y , x )); u1i = aimag ( ur ( z , 1 , y , x )) u2r = real ( ur ( z , 2 , y , x )); u2i = aimag ( ur ( z , 2 , y , x )) u3r = real ( ur ( z , 3 , y , x )); u3i = aimag ( ur ( z , 3 , y , x )) if ( rkstep == 1 ) velmax = max ( velmax & , b11 * nx * abs ( u1r ) + b22 * ny * abs ( u2r ) + b33 * nz * abs ( u3r ) & , b11 * nx * abs ( u1i ) + b22 * ny * abs ( u2i ) + b33 * nz * abs ( u3i ) ) v2r = u2r * u2r ; v2i = u2i * u2i s2r = u1r * u3r ; s2i = u1i * u3i u4r = u2r * u3r ; u4i = u2i * u3i u3r = u3r * u3r - v2r ; u3i = u3i * u3i - v2i u2r = u1r * u2r ; u2i = u1i * u2i u1r = u1r * u1r - v2r ; u1i = u1i * u1i - v2i s2 ( z , x ) = cmplx ( s2r , s2i ) ur ( z , 1 , y , x ) = cmplx ( u1r , u1i ) ur ( z , 2 , y , x ) = cmplx ( u2r , u2i ) ur ( z , 3 , y , x ) = cmplx ( u3r , u3i ) ur ( z , 4 , y , x ) = cmplx ( u4r , u4i ) end do ; end do !(*----------------------------  LEAVING PHYSICAL SPACE  --------------------------*) do i = 1 , 4 call rfft ( nx , nz , ur ( 1 , i , y , 1 ), nz * 4 * my , one , trigx , - one ) do z = 1 , nz ; ur ( z , i , y , 1 ) = cmplx ( real ( ur ( z , i , y , 1 )), 0 ); end do call cfft ( nz , nx / 2 , ur ( 1 , i , y , 1 ), one , nz * 4 * my , trigz , - one ) end do call rfft ( nx , nz , s2 , nz , one , trigx , - one ) do z = 1 , nz ; s2 ( z , 1 ) = cmplx ( real ( s2 ( z , 1 )), 0 ); end do call cfft ( nz , nx / 2 , s2 , one , nz , trigz , - one ) do x = 1 , nx / 2 ; do z = 1 , nz ur ( z , 1 , y , x ) = kx ( x ) * ur ( z , 1 , y , x ) + kz ( z ) * s2 ( z , x ) - ( 0 , 1 ) * 2 * nx * nz * shear * vs ( z , x ) ur ( z , 3 , y , x ) = kx ( x ) * s2 ( z , x ) + kz ( z ) * ur ( z , 3 , y , x ) end do ; end do end do end  subroutine phase2 !(*********************************************************************************************************** !     phase 3 :  on entry, the data-plane contains the four stresses on a shifted mesh in physical y space, !                wave x,z space.   Return to y  wave space on unshifted mesh and complete time derivative of !                velocity ( not divergence free yet ) !***********************************************************************************************************) subroutine phase3 use constants_module , only : one use run_size implicit none integer ( int64 ) :: i , x , y , z complex :: shift do x = first_x , last_x do i = 1 , 4 call cfft ( ny , nz , u ( 1 , i , x , 1 ), nz * 4 * mx , one , trigy , - one ) end do !(*---------------------------   WELCOME TO FOURIER WAVE SPACE  --------------------------*) do y = 1 , ny ; do z = 1 , nz shift = - dt / ( 4 * nx * ny * nz ) * ( 0 , 1 ) * conjg ( sy ( y , rkstep ) * sz ( z , rkstep ) * sx ( x , rkstep ) ) u ( z , 1 , x , y ) = shift * ( u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = shift * ( kx ( x ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 4 , x , y ) ) u ( z , 3 , x , y ) = shift * ( u ( z , 3 , x , y ) + ky ( x , y ) * u ( z , 4 , x , y ) ) end do ; end do end do end   subroutine phase3 !(*********************************************************************************************************** !   pressure :  add the gradient of a scalar, enforce continuity ( zero divergence ) !***********************************************************************************************************) subroutine pressure use run_size implicit none complex :: psi integer ( int64 ) :: x , y , z do x = first_x , last_x ; do y = 1 , ny if ( x /= 1 ) then do z = 1 , nz psi = ( kx ( x ) * u ( z , 1 , x , y ) + ky ( x , y ) * u ( z , 2 , x , y ) + kz ( z ) * u ( z , 3 , x , y ) ) & / ( kx ( x ) ** 2 + ky ( x , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 1 , x , y ) = u ( z , 1 , x , y ) - kx ( x ) * psi u ( z , 2 , x , y ) = u ( z , 2 , x , y ) - ky ( x , y ) * psi u ( z , 3 , x , y ) = u ( z , 3 , x , y ) - kz ( z ) * psi end do else if ( y /= 1 ) then do z = 1 , nz psi = ( ky ( 1 , y ) * u ( z , 2 , 1 , y ) + kz ( z ) * u ( z , 3 , 1 , y ) ) & / ( ky ( 1 , y ) ** 2 + kz ( z ) ** 2 ) u ( z , 2 , 1 , y ) = u ( z , 2 , 1 , y ) - ky ( 1 , y ) * psi u ( z , 3 , 1 , y ) = u ( z , 3 , 1 , y ) - kz ( z ) * psi end do else do z = 1 , nz ; u ( z , 3 , 1 , 1 ) = 0 ; end do end if end do ; end do end   subroutine pressure !(***************************************************************************************************************** !                                remesh  :  remesh the sheared coordinate system !*****************************************************************************************************************) subroutine remesh use constants_module , only : one use run_size implicit none complex :: u2 ( nx + ny , nz ), shift ( nx + ny ) integer ( int64 ) :: i , x , y , z write ( 6 , fmt = \"(A,i4)\" ) \"remesh image \" , my_node total_time = total_time + WALLTIME () !-- stop the clock! do x = first_x , last_x do y = 1 , nx + ny ; shift ( y ) = exp ( ( 0 , - 2 ) * pi / ( nx + ny ) * k1 ( x ) * ( y - 1 ) ) / ( nx + ny ); end do do i = 1 , 3 do z = 1 , nz do y = 1 , ny / 2 ; u2 ( y , z ) = u ( z , i , x , y ); end do do y = ny / 2 + 1 , nx + ny / 2 + 1 ; u2 ( y , z ) = 0 ; end do do y = nx + ny / 2 + 2 , nx + ny ; u2 ( y , z ) = u ( z , i , x , y - nx ); end do end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , one ) do z = 1 , nz ; do y = 1 , nx + ny ; u2 ( y , z ) = u2 ( y , z ) * shift ( y ); end do ; end do call cfft ( nx + ny , nz , u2 , one , nx + ny , trigxy , - one ) do z = 1 , nz do y = 1 , ny / 2 if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y , z ) end if end do do y = ny / 2 + 1 , ny if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) & then ; u ( z , i , x , y ) = 0 else ; u ( z , i , x , y ) = u2 ( y + nx , z ) end if end do end do end do do y = 1 , ny ; ky ( x , y ) = ky ( x , y ) + b22 * k1 ( x ); end do !(* update ky for this x *) end do b12 = b12 + b22 ; rflag = 0 !(*   update metric, account for remesh    *) total_time = total_time - WALLTIME () !-- restart the clock! end subroutine remesh !(*********************************************************************************************************** !         copy_n_s,   copy_s_n :  copy data between data_s and data_n !***********************************************************************************************************) subroutine copy_n_s use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz u ( z , 1 , x , y ) = un ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_n_s subroutine copy_s_n use run_size implicit none integer ( int64 ) :: x , y , z do y = 1 , ny ; do x = first_x , last_x ; do z = 1 , nz un ( z , 1 , x , y ) = u ( z , 1 , x , y ) un ( z , 2 , x , y ) = u ( z , 2 , x , y ) un ( z , 3 , x , y ) = u ( z , 3 , x , y ) end do ; end do ; end do end  subroutine copy_s_n !(*********************************************************************************************************** !                         advance :     second-order runge-kutta time step algorithm !***********************************************************************************************************) subroutine advance use run_size implicit none integer ( int64 ) :: x , y , z real :: factor , xyfac , zfac ( nz ) !(* viscous integrating factors *) if ( rkstep == 1 ) then do z = 1 , nz ; zfac ( z ) = exp ( - viscos * dt * kz ( z ) ** 2 ); end do do x = first_x , last_x do y = 1 , ny ky_ ( x , y ) = ky ( x , y ) ky ( x , y ) = b22 * k2 ( y ) + b12 * k1 ( x ) do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else factor = zfac ( z ) * exp ( - viscos * dt * ( kx ( x ) ** 2 + ( ky_ ( x , y ) ** 2 + ky_ ( x , y ) * ky ( x , y ) + ky ( x , y ) ** 2 ) / 3 ) ) un ( z , 1 , x , y ) = factor * ( un ( z , 1 , x , y ) + u ( z , 1 , x , y ) ) u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + factor * u ( z , 1 , x , y ) un ( z , 2 , x , y ) = factor * ( un ( z , 2 , x , y ) + u ( z , 2 , x , y ) ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + factor * u ( z , 2 , x , y ) un ( z , 3 , x , y ) = factor * ( un ( z , 3 , x , y ) + u ( z , 3 , x , y ) ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + factor * u ( z , 3 , x , y ) end if end do ; end do ; end do else if ( rkstep == 2 ) then do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( mk1 ( x ) + mk2 ( y ) + mk3 ( z ) > 2. / 9. ) then u ( z , 1 , x , y ) = 0 ; u ( z , 2 , x , y ) = 0 ; u ( z , 3 , x , y ) = 0 else u ( z , 1 , x , y ) = un ( z , 1 , x , y ) + u ( z , 1 , x , y ) u ( z , 2 , x , y ) = un ( z , 2 , x , y ) + u ( z , 2 , x , y ) u ( z , 3 , x , y ) = un ( z , 3 , x , y ) + u ( z , 3 , x , y ) end if end do ; end do ; end do end if end  subroutine advance end   subroutine solve_navier_stokes","tags":"","loc":"sourcefile/mpi-shear.f90.html","title":"mpi-shear.f90 – OpenCoarrays"},{"text":"Source Code ! MPI 1D Burgers equation solver: input_file ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! module input_file !scalable module for sharing input data about mesh/numerical scheme use kind_parameters , only : ikind implicit none integer ( ikind ) , parameter :: grid_resolution = 819200 !134217728 end module","tags":"","loc":"sourcefile/input_file.f90.html","title":"input_file.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2011, Damian Rouson, Jim Xia, and Xiaofeng Xu. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the names of Damian Rouson, Jim Xia, and Xiaofeng Xu nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL DAMIAN ROUSON, JIM XIA, and XIAOFENG XU BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module kind_parameters ! Type kind parameter implicit none private public :: rkind , ikind , ckind integer , parameter :: digits = 8 ! num. digits of kind integer , parameter :: decades = 9 ! num. representable decades integer , parameter :: rkind = selected_real_kind ( digits ) integer , parameter :: ikind = selected_int_kind ( decades ) integer , parameter :: ckind = selected_char_kind ( 'default' ) end module","tags":"","loc":"sourcefile/kind_parameters.f90.html","title":"kind_parameters.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2011, Damian Rouson, Jim Xia, and Xiaofeng Xu. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the names of Damian Rouson, Jim Xia, and Xiaofeng Xu nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL DAMIAN ROUSON, JIM XIA, and XIAOFENG XU BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module initializer use kind_parameters , only : rkind implicit none contains real ( rkind ) pure function u_initial ( x ) real ( rkind ) , intent ( in ) :: x u_initial = 1 0._rkind * sin ( x ) end function real ( rkind ) pure function zero ( x ) real ( rkind ) , intent ( in ) :: x zero = 0. end function end module program main use iso_fortran_env , only : output_unit use kind_parameters , only : rkind use periodic_2nd_order_module , only : periodic_2nd_order , initial_field use initializer , only : u_initial , zero use input_file , only : grid_resolution !CZC use shared use mpi_share , only : mpi_object !CZC implicit none type ( periodic_2nd_order ), save :: u , half_uu , u_half real ( rkind ) :: dt , half = 0.5 , t = 0. , t_final = 3.08 , nu = 1. integer , parameter :: base_output_unit = output_unit + 10 integer :: step , iostat , steps , num_steps = 100000 character (:), allocatable :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ character (:), allocatable :: iomsg integer , allocatable :: v_list (:) procedure ( initial_field ) , pointer :: initial real ( rkind ), parameter :: time_initial = 0. real ( rkind ), allocatable :: u_surface (:,:) real ( rkind ) :: t_1 , t_2 , t_3 ! Test parameters real ( rkind ), parameter :: pi = acos ( - 1._rkind ), expected_zero_location = pi call mpi_object % mpi_begin !initiate MPI functionality, CZC local_grid_resolution = grid_resolution / num_procs !calculate how processors are shared, CZC #ifdef USING_TAU call TAU_PROFILE_SET_NODE ( my_id ) #endif call cpu_time ( t_1 ) initial => u_initial call u % construct ( initial , grid_resolution ) initial => zero call half_uu % construct ( initial , grid_resolution ) call u_half % construct ( initial , grid_resolution ) call u % set_time ( time_initial ) step = 1 call u % set_time (( step - 1 ) * dt ) !numerical scheme call cpu_time ( t_2 ) dt = u % runge_kutta_2nd_step ( nu , grid_resolution ) #ifdef BENCHMARK do steps = 1 , num_steps #else do while ( t < t_final ) #endif half_uu = u * u * half u_half = u + ( u % xx () * nu - half_uu % x ()) * dt * half ! first substep half_uu = u_half * u_half * half u = u + ( u_half % xx () * nu - half_uu % x ()) * dt ! second substep t = t + dt step = step + 1 end do call cpu_time ( t_3 ) if ( my_id == 0 ) print * , t_2 - t_1 , t_3 - t_2 , t_3 - t_1 !print *, 'this image = ', my_id, ' f_global = ',u%global_f(1:local_grid_resolution) iomsg = \"Output result: success.\" !call u%output(70 + my_id,iotype,v_list,iostat,iomsg) if ( u % this_image_contains ( expected_zero_location )) then if (. not . u % has_a_zero_at ( expected_zero_location )) error stop \"Test failed.\" print * , 'Test passed.' end if call mpi_object % mpi_end !end MPI processes end program","tags":"","loc":"sourcefile/main.f90~2.html","title":"main.F90 – OpenCoarrays"},{"text":"Source Code ! MPI 1D Burgers equation solver test: mpi_module ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module mpi_module !declare what other modules are being used use kind_parameters , only : rkind , ikind use object_interface , only : object use ForTrilinos_assertion_utility , only : assert , error_message use shared implicit none !everything in this module aside from mpi_class is private private public :: mpi_class integer ( ikind ) :: program_status = 0 !integer for keeping track of whether mpi has !started or not !extend object class so can make use of assertions type , extends ( object ) :: mpi_class contains procedure :: output !mandatory extension of object procedure , nopass :: mpi_begin ! initiate mpi procedure , nopass :: mpi_end ! end mpi procedure , nopass :: barrier procedure , nopass :: oned_message !communicate with neighboors for a 1d pde end type contains subroutine output ( this , unit , iotype , v_list , iostat , iomsg ) class ( mpi_class ), intent ( in ) :: this integer , intent ( in ) :: unit ! Unit on which output happens (negative for internal file) character ( * ), intent ( in ) :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg integer ( ikind ) i ! Requires call assert ( this % user_defined (), error_message ( \"mpi_object%output recieved unitialized object.\" )) write ( unit = unit , iostat = iostat , fmt = \"(i8,3(f12.4,2x))\" ) end subroutine subroutine mpi_begin integer :: dims ( 1 ), periods ( 1 ), reorder if ( program_status . eq . 0 ) then !prevent accidentally starting mpi when !already has been initiated call MPI_INIT ( ierr ) !initiate MPI call MPI_COMM_SIZE ( MPI_COMM_WORLD , num_procs , ierr ) !retrieve processer count call MPI_COMM_RANK ( MPI_COMM_WORLD , my_id , ierr ) !retrive processor rank dims = num_procs reorder = 1 periods = 1 call MPI_CART_CREATE ( MPI_COMM_WORLD , 1 , dims , periods , reorder , MPI_COMM_CART , ierr ) call MPI_COMM_RANK ( MPI_COMM_CART , my_id , ierr ) call MPI_CART_SHIFT ( MPI_COMM_CART , 0 , 1 , left_id , right_id , ierr ) program_status = 1 endif end subroutine subroutine mpi_end if ( program_status == 1 ) then !prevent ending mpi if it is not running call MPI_FINALIZE ( ierr ) program_status = 0 endif end subroutine subroutine barrier call mpi_barrier ( mpi_comm_world , ierr ) end subroutine subroutine oned_message ( periodic , local_grid_resolution , left_sub , right_sub ) integer ( ikind ), intent ( in ) :: local_grid_resolution real ( rkind ), intent ( in ), dimension (:) :: periodic ! keep track of global f real ( rkind ), intent ( inout ) :: left_sub , right_sub !images from nearby processors DOUBLE PRECISION left , right !intermediate variable for storing messages !  assertions to ensure that proper input provided to subroutine call assert ( size ( periodic ) >= local_grid_resolution , error_message ( \"size of local function too small.\" )) call assert ( local_grid_resolution > 0 , error_message ( \"invalid local grid spacing.\" )) if ( num_procs > 1 ) then !no need to communicate if only 1 processor call MPI_SENDRECV ( periodic ( 1 ), 1 , MPI_DOUBLE_PRECISION , left_id , 0 , & right , 1 , MPI_DOUBLE_PRECISION , right_id , 0 , MPI_COMM_CART , status , ierr ) call MPI_SENDRECV ( periodic ( local_grid_resolution ), 1 , MPI_DOUBLE_PRECISION , right_id , 0 , & left , 1 , MPI_DOUBLE_PRECISION , left_id , 0 , MPI_COMM_CART , status , ierr ) left_sub = left right_sub = right else !incase only one processor left_sub = periodic ( local_grid_resolution ) right_sub = periodic ( 1 ) endif end subroutine end module","tags":"","loc":"sourcefile/mpi_module.f90.html","title":"mpi_module.F90 – OpenCoarrays"},{"text":"Source Code ! MPI 1D Burgers equation solver test: mpi_share ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module mpi_share !module exclusively for initiating and sharing an mpi_object use mpi_module , only : mpi_class type ( mpi_class ) :: mpi_object end module","tags":"","loc":"sourcefile/mpi_share.f90.html","title":"mpi_share.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2011, Damian Rouson, Jim Xia, and Xiaofeng Xu. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the names of Damian Rouson, Jim Xia, and Xiaofeng Xu nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL DAMIAN ROUSON, JIM XIA, and XIAOFENG XU BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module periodic_2nd_order_module !note co-object and field modules no longer necessary so they are not used use kind_parameters , only : rkind , ikind use ForTrilinos_assertion_utility , only : assert , error_message use object_interface , only : object use input_file , only : grid_resolution !added input file so that multiple modules/main can access grid_resolution,CZC use mpi_module , only : mpi_class !CZC use mpi_share , only : mpi_object !CZC use shared !CZC implicit none private public :: periodic_2nd_order , initial_field type , extends ( object ) :: periodic_2nd_order !   private !Make arrays larger than necessary as they must have an explicit intialization real ( rkind ), allocatable :: global_f (:) !object MPI variable for storing function, CZC contains procedure :: construct procedure :: assign_field procedure :: add => add_field procedure :: multiply => multiply_field procedure :: multiply_real !CZC procedure :: subtract !CZC procedure :: x => df_dx procedure :: xx => d2f_dx2 procedure :: runge_kutta_2nd_step => rk2_dt procedure , nopass :: this_image_contains procedure :: has_a_zero_at procedure :: local_state procedure , nopass :: set_time procedure , nopass :: get_time generic :: assignment ( = ) => assign_field generic :: operator ( + ) => add generic :: operator ( * ) => multiply generic :: operator ( * ) => multiply_real !added functionality, taken from field class, CZC generic :: operator ( - ) => subtract !added functionality, taken from field class, CZC procedure :: output !generic :: write=>output ! Fortran 2003 derived-type output end type real ( rkind ) , parameter :: pi = acos ( - 1._rkind ) real ( rkind ), allocatable :: local_grid (:) real ( rkind ) :: time = 0. abstract interface real ( rkind ) pure function initial_field ( x ) import :: rkind real ( rkind ) , intent ( in ) :: x end function end interface contains pure function local_state ( this ) result ( local_state_vector ) class ( periodic_2nd_order ), intent ( in ) :: this real ( rkind ), allocatable :: local_state_vector (:) integer ( ikind ) :: i local_state_vector = this % global_f end function subroutine output ( this , unit , iotype , v_list , iostat , iomsg ) class ( periodic_2nd_order ), intent ( in ) :: this integer , intent ( in ) :: unit ! Unit on which output happens (negative for internal file) character ( * ), intent ( in ) :: iotype ! Allowable values: ’LISTDIRECTED’,’NAMELIST’, or ’DT’ integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg integer ( ikind ) i ! Requires call assert ( this % user_defined (), error_message ( \"periodic_2nd_order%output recieved unitialized object.\" )) do i = 1 , local_grid_resolution write ( unit = unit , iostat = iostat , fmt = \"(i8,3(f12.4,2x))\" ) & ( my_id ) * local_grid_resolution + i , local_grid ( i ), time , this % global_f ( i ) !modified earlier code to work with MPI, CZC end do end subroutine subroutine set_time ( time_stamp ) real ( rkind ), intent ( in ) :: time_stamp time = time_stamp end subroutine pure function get_time () result ( t ) real ( rkind ) :: t t = time end function pure function has_a_zero_at ( this , expected_location ) result ( zero_at_expected_location ) class ( periodic_2nd_order ) , intent ( in ) :: this real ( rkind ) , intent ( in ) :: expected_location real ( rkind ), parameter :: tolerance = 1.0E-06_rkind integer :: nearest_grid_point logical :: zero_at_expected_location ! Requires if ( this % user_defined ()) then nearest_grid_point = minloc ( abs ( local_grid - expected_location ), dim = 1 ) zero_at_expected_location = merge (. true .,. false ., abs ( this % global_f ( nearest_grid_point )) < tolerance ) end if end function pure function this_image_contains ( location ) result ( within_bounds ) implicit none real ( rkind ), intent ( in ) :: location logical within_bounds within_bounds = merge (. true .,. false ., ( location >= minval ( local_grid ) . and . location <= maxval ( local_grid )) ) end function subroutine construct ( this , initial , num_grid_pts ) implicit none class ( periodic_2nd_order ), intent ( inout ) :: this procedure ( initial_field ) , pointer , intent ( in ) :: initial integer ( ikind ) , intent ( in ) :: num_grid_pts integer :: i !local variables for storing nearby nodes DOUBLE PRECISION left , right !CZC DOUBLE PRECISION left_sub , right_sub !CZC ! Requires call assert ( mod ( num_grid_pts , num_procs ) == 0 , error_message ( \"periodic_2nd_order%construct: invalid number of grid points.\" )) local_grid = grid () allocate ( this % global_f ( local_grid_resolution )) do concurrent ( i = 1 : local_grid_resolution ) this % global_f ( i ) = initial ( local_grid ( i )) end do ! Ensures call mpi_object % oned_message ( this % global_f ( 1 : local_grid_resolution ), local_grid_resolution , left_sub , right_sub ) !communicate with neighbors, call this % mark_as_defined contains pure function grid () implicit none integer ( ikind ) :: i real ( rkind ) , dimension (:) , allocatable :: grid allocate ( grid ( local_grid_resolution )) do concurrent ( i = 1 : local_grid_resolution ) grid ( i ) = 2. * pi * ( local_grid_resolution * ( my_id ) + i - 1 ) & / real ( num_grid_pts , rkind ) end do end function end subroutine real ( rkind ) function rk2_dt ( this , nu , num_grid_pts ) implicit none class ( periodic_2nd_order ) , intent ( in ) :: this real ( rkind ) , intent ( in ) :: nu integer ( ikind ) , intent ( in ) :: num_grid_pts real ( rkind ) :: dx , CFL , k_max ! Requires if ( this % user_defined ()) then dx = 2.0 * pi / num_grid_pts k_max = num_grid_pts / 2.0_rkind CFL = 1.0 / ( 1.0 - cos ( k_max * dx )) rk2_dt = CFL * dx ** 2 / nu end if end function ! this is the assignment subroutine assign_field ( lhs , rhs ) implicit none class ( periodic_2nd_order ) , intent ( inout ) :: lhs type ( periodic_2nd_order ) , intent ( in ) :: rhs DOUBLE PRECISION left , right !CZC DOUBLE PRECISION left_sub , right_sub !CZC ! Requires call assert ( rhs % user_defined (), error_message ( \"periodic_2nd_order%copy received undefind RHS.\" )) ! update global field lhs % global_f = rhs % global_f !CZC ! Ensures call lhs % mark_as_defined end subroutine function add_field ( this , rhs ) implicit none class ( periodic_2nd_order ), intent ( in ) :: this class ( periodic_2nd_order ), intent ( in ) :: rhs type ( periodic_2nd_order ) :: add_field ! Requires allocate ( add_field % global_f ( local_grid_resolution )) if ( rhs % user_defined () . and . this % user_defined ()) then add_field % global_f ( 1 : local_grid_resolution ) = rhs % global_f ( 1 : local_grid_resolution ) + this % global_f ( 1 : local_grid_resolution ) ! Ensures call add_field % mark_as_defined end if end function function multiply_field ( this , rhs ) implicit none class ( periodic_2nd_order ), intent ( in ) :: this , rhs type ( periodic_2nd_order ) :: multiply_field ! Requires allocate ( multiply_field % global_f ( local_grid_resolution )) if ( this % user_defined () . and . rhs % user_defined ()) then multiply_field % global_f ( 1 : local_grid_resolution ) = this % global_f ( 1 : local_grid_resolution ) * rhs % global_f ( 1 : local_grid_resolution ) ! Ensures call multiply_field % mark_as_defined end if end function !New procedure, functionality taken from field, CZC function multiply_real ( lhs , rhs ) result ( product_ ) class ( periodic_2nd_order ) , intent ( in ) :: lhs real ( rkind ) , intent ( in ) :: rhs type ( periodic_2nd_order ) :: product_ ! Requires allocate ( product_ % global_f ( local_grid_resolution )) if ( lhs % user_defined ()) then product_ % global_f ( 1 : local_grid_resolution ) = lhs % global_f ( 1 : local_grid_resolution ) * rhs !multiply array with scalar ! Ensures call product_ % mark_as_defined end if end function !new procedure, functionality taken from field, CZC pure function subtract ( lhs , rhs ) result ( difference ) class ( periodic_2nd_order ) , intent ( in ) :: lhs class ( periodic_2nd_order ) , intent ( in ) :: rhs type ( periodic_2nd_order ) :: difference ! Requires allocate ( difference % global_f ( local_grid_resolution )) if ( lhs % user_defined () . and . rhs % user_defined ()) then difference % global_f ( 1 : local_grid_resolution ) = lhs % global_f ( 1 : local_grid_resolution ) - rhs % global_f ( 1 : local_grid_resolution ) !subtract arrays ! Ensures call difference % mark_as_defined end if end function function df_dx ( this ) implicit none class ( periodic_2nd_order ), intent ( in ) :: this type ( periodic_2nd_order ) :: df_dx integer ( ikind ) :: i , nx real ( rkind ) :: dx , left_image , right_image real ( rkind ), dimension (:), allocatable , save :: tmp_field_array ! Requires if ( this % user_defined ()) then nx = local_grid_resolution if (. not . allocated ( tmp_field_array )) allocate ( tmp_field_array ( nx )) dx = 2. * pi / ( real ( nx , rkind ) * num_procs ) if ( num_procs > 1 ) then call MPI_SENDRECV ( this % global_f ( 1 ), 1 , MPI_DOUBLE_PRECISION , left_id , 0 , & right_image , 1 , MPI_DOUBLE_PRECISION , right_id , 0 , MPI_COMM_CART , status , ierr ) call MPI_SENDRECV ( this % global_f ( local_grid_resolution ), 1 , MPI_DOUBLE_PRECISION , right_id , 0 , & left_image , 1 , MPI_DOUBLE_PRECISION , left_id , 0 , MPI_COMM_CART , status , ierr ) else left_image = this % global_f ( nx ) right_image = this % global_f ( 1 ) end if tmp_field_array ( 1 ) = & 0.5 * ( this % global_f ( 2 ) - left_image ) / dx tmp_field_array ( nx ) = & 0.5 * ( right_image - this % global_f ( nx - 1 )) / dx do concurrent ( i = 2 : nx - 1 ) tmp_field_array ( i ) = & 0.5 * ( this % global_f ( i + 1 ) - this % global_f ( i - 1 )) / dx end do df_dx % global_f = tmp_field_array ! Ensures call df_dx % mark_as_defined end if end function function d2f_dx2 ( this ) implicit none class ( periodic_2nd_order ), intent ( in ) :: this type ( periodic_2nd_order ) :: d2f_dx2 integer ( ikind ) :: i , nx real ( rkind ) :: dx , left_image , right_image real ( rkind ), dimension (:), allocatable , save :: tmp_field_array ! Requires if ( this % user_defined ()) then nx = local_grid_resolution if (. not . allocated ( tmp_field_array )) allocate ( tmp_field_array ( nx )) dx = 2. * pi / ( real ( nx , rkind ) * num_procs ) if ( num_procs > 1 ) then call MPI_SENDRECV ( this % global_f ( 1 ), 1 , MPI_DOUBLE_PRECISION , left_id , 0 , & right_image , 1 , MPI_DOUBLE_PRECISION , right_id , 0 , MPI_COMM_CART , status , ierr ) call MPI_SENDRECV ( this % global_f ( local_grid_resolution ), 1 , MPI_DOUBLE_PRECISION , right_id , 0 , & left_image , 1 , MPI_DOUBLE_PRECISION , left_id , 0 , MPI_COMM_CART , status , ierr ) else left_image = this % global_f ( nx ) right_image = this % global_f ( 1 ) end if tmp_field_array ( 1 ) = & ( this % global_f ( 2 ) - 2.0 * this % global_f ( 1 ) + left_image )& / dx ** 2 tmp_field_array ( nx ) = & ( right_image - 2.0 * this % global_f ( nx ) + this % global_f ( nx - 1 ))& / dx ** 2 do concurrent ( i = 2 : nx - 1 ) tmp_field_array ( i ) = & ( this % global_f ( i + 1 ) - 2.0 * this % global_f ( i ) + this % global_f ( i - 1 ))& / dx ** 2 end do d2f_dx2 % global_f = tmp_field_array ! Ensures call d2f_dx2 % mark_as_defined end if end function end module","tags":"","loc":"sourcefile/periodic_2nd_order.f90.html","title":"periodic_2nd_order.F90 – OpenCoarrays"},{"text":"Source Code ! MPI 1D Burgers equation solver test: shared ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS module shared !module for sharing mpi functionality/variables with other modules/main use mpi !non-native mpi functionality integer :: tag , status ( MPI_STATUS_SIZE ) integer :: MPI_COMM_CART integer :: my_id , num_procs , ierr , local_grid_resolution , left_id , right_id integer , parameter :: send_data_tag = 2001 , return_data_tag = 2002 !tags for sending information integer , parameter :: root_process = 0 integer , parameter :: max_local_resolution = 10000 end module","tags":"","loc":"sourcefile/shared.f90.html","title":"shared.F90 – OpenCoarrays"},{"text":"m dist_transpose/mpi_run_size\n NAME\n   mpi_run_size\n SYNOPSIS\n   Encapsulate the problem state, wall-clock timer interface, integer broadcasts, and a data copy\n   for a distributed tranpsose kernel extracted from a program for the Fourier-spectral simulation\n   of statistically homogeneous. ==================  test transposes with integer x,y,z values  =============================== e* dist_transose/mpi_distributed_transpose\n NAME\n   mpi_distributed_transpose\n SYNOPSIS\n   This program is the MPI analogue of coarray_distributed_transpose. It tests the transpose routines used\n   in Fourier-spectral simulations of homogeneous turbulence. * Source Code ! MPI Distributed Transpose Test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! Robodoc header: !****m* dist_transpose/mpi_run_size ! NAME !   mpi_run_size ! SYNOPSIS !   Encapsulate the problem state, wall-clock timer interface, integer broadcasts, and a data copy !   for a distributed tranpsose kernel extracted from a program for the Fourier-spectral simulation !   of statistically homogeneous. !****** !==================  test transposes with integer x,y,z values  =============================== module mpi_run_size use iso_fortran_env #ifndef HAVE_WALLTIME use MPI , only : WALLTIME => MPI_WTIME #endif implicit none integer ( int64 ) :: nx , ny , nz integer ( int64 ) :: my , mx , first_y , last_y , first_x , last_x integer ( int64 ) :: my_node , num_nodes real ( real64 ) :: tran_time #ifdef HAVE_WALLTIME interface function WALLTIME () bind ( C , name = \"WALLTIME\" ) use iso_fortran_env real ( real64 ) :: WALLTIME end function WALLTIME end interface #endif contains subroutine mpi_copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) use iso_fortran_env implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine mpi_copy3 end module mpi_run_size !****e* dist_transose/mpi_distributed_transpose ! NAME !   mpi_distributed_transpose ! SYNOPSIS !   This program is the MPI analogue of coarray_distributed_transpose. It tests the transpose routines used !   in Fourier-spectral simulations of homogeneous turbulence. !****** program mpi_distributed_transpose !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use mpi_run_size implicit none include 'mpif.h' complex , allocatable :: u (:,:,:,:) ! u(nz,4,first_x:last_x,ny)    !(*-- ny = my * num_nodes --*) complex , allocatable :: ur (:,:,:,:) !ur(nz,4,first_y:last_y,nx/2)  !(*-- nx/2 = mx * num_nodes --*) complex , allocatable :: bufr (:) integer ( int64 ) :: x , y , z , msg_size , iter integer ( int64 ) :: ierror call MPI_INIT ( ierror ) call MPI_COMM_RANK ( MPI_COMM_WORLD , my_node , ierror ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , num_nodes , ierror ) if ( my_node == 0 ) then !write(6,fmt=\"(A)\") \"nx,ny,nz : \" !read(5,*) nx, ny, nz nx = 32 ; ny = 32 ; nz = 32 end if call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !-- other nodes wait for broadcast! call MPI_BCAST ( nx , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( ny , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nz , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) if ( mod ( ny , num_nodes ) == 0 ) then ; my = ny / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \" ny not multiple of num_nodes\" ; stop end if if ( mod ( nx / 2 , num_nodes ) == 0 ) then ; mx = nx / 2 / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \"nx/2 not multiple of num_nodes\" ; stop end if first_y = my_node * my + 1 ; last_y = my_node * my + my first_x = my_node * mx + 1 ; last_x = my_node * mx + mx msg_size = nz * 4 * mx * my !-- message size (complex data items allocate ( u ( nz , 4 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 ) ) !(*-- x-z planes --*) allocate ( bufr ( msg_size ) ) !---------  initialize data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz u ( z , 1 , x , y ) = x u ( z , 2 , x , y ) = y u ( z , 3 , x , y ) = z end do end do end do tran_time = 0 do iter = 1 , 2 !--- 2 transform pairs per second-order time step !---------  transpose data u -> ur (mx y-z planes to my x-z planes per image)  -------- ur = 0 call transpose_X_Y !--------- test data ur (my x-z planes per image) ---------- do x = 1 , nx / 2 do y = first_y , last_y do z = 1 , nz if ( real ( ur ( z , 1 , y , x )) /= x . or . real ( ur ( z , 2 , y , x )) /= y . or . real ( ur ( z , 3 , y , x )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_X_Y failed:  image \" , my_node & , \" X \" , real ( ur ( z , 1 , y , x )), x , \"  Y \" , real ( ur ( z , 2 , y , x )), y , \"  Z \" , real ( ur ( z , 3 , y , x )), z stop end if end do end do end do !---------  transpose data ur -> u (my x-z planes to mx y-z planes per image)  -------- u = 0 call transpose_Y_X !--------- test data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( real ( u ( z , 1 , x , y )) /= x . or . real ( u ( z , 2 , x , y )) /= y . or . real ( u ( z , 3 , x , y )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_Y_X failed:  image \" , my_node & , \" X \" , real ( u ( z , 1 , y , x )), x , \"  Y \" , real ( u ( z , 2 , y , x )), y , \"  Z \" , real ( u ( z , 3 , y , x )), z stop end if end do end do end do end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) if ( my_node == 0 ) write ( 6 , fmt = \"(A,f8.3)\" ) \"test passed:  tran_time \" , tran_time deallocate ( bufr , ur , u ) !=========================   end of main executable  ============================= contains !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) character * ( MPI_MAX_ERROR_STRING ) errs call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( u ( 1 , 1 , first_x , 1 + to * my ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   receive and transpose other image's block  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , ur ( 1 , 1 , first_y , 1 + from * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( ur ( 1 , 1 , first_y , 1 + from * mx ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + to * my ), bufr & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () ! deallocate(ids,idr) end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) character * ( MPI_MAX_ERROR_STRING ) errs integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( ur ( 1 , 1 , first_y , 1 + to * mx ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   transpose other image's block (get block then transpose it)  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , u ( 1 , 1 , first_x , 1 + from * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( u ( 1 , 1 , first_x , 1 + from * my ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + to * mx ), bufr & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () !   deallocate(ids,idr) end  subroutine transpose_Y_X end program mpi_distributed_transpose","tags":"","loc":"sourcefile/mpi_distributed_transpose.f90.html","title":"mpi_distributed_transpose.F90 – OpenCoarrays"},{"text":"Source Code ! P-SNAP test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS !  Fortran translation of !/* ! * P-SNAP v1.2 -- PAL System Noise Activity Program -- LA-CC-06-025 ! *        <http://www.c3.lanl.gov/pal/software/psnap/> ! * ! * Copyright (C) 2006, The Regents of the University of California ! * ! *                PAL -- Performance and Architecture Laboratory ! *                  <http://www.c3.lanl.gov/pal/> ! *                Los Alamos National Laboratory ! *                  <http://www.lanl.gov/> ! */ !  by Dan Nagle ! * This program is free software; you can redistribute it and/or modify ! * it under the terms of the GNU General Public License as published by ! * the Free Software Foundation; either version 2 of the License, or ! * (at your option) any later version. ! * ! * This program is distributed in the hope that it will be useful, ! * but WITHOUT ANY WARRANTY; without even the implied warranty of ! * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the ! * GNU General Public License for more details. ! * ! * You should have received a copy of the GNU General Public License ! * along with this program; if not, write to the Free Software ! * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA ! * 02110-1301 USA. program psnap !  #define VERSION_STR \"v1.2\" use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , int64 , real64 , int32 use , intrinsic :: iso_c_binding character ( len = * ), parameter :: psnap_rcs_id = & '$Id$' character ( len = * ), parameter :: string_fmt = '( a)' type , bind ( c ) :: counters integer ( c_long ) :: val integer ( c_int ) :: index end type counters !  int rank, np; // globals integer :: rank integer :: np integer :: np_half !integer( int64), save :: n = 100000 integer ( int64 ), codimension [ * ], save :: n = 1000 integer ( int64 ), codimension [ * ], save :: w = 1000 integer ( int64 ), dimension ( :), allocatable :: r integer ( int64 ) :: i integer ( int64 ), codimension [ * ], save :: iteration_count = 0 integer ( int64 ), codimension [ * ] :: localmax , globalmax integer ( int64 ), codimension [ * ] :: localsum integer ( int64 ), dimension ( :), allocatable :: sum_all integer ( int64 ), dimension ( :), allocatable , codimension [ :] :: localhist integer ( int64 ), codimension [ * ], save :: granularity = 1000 integer ( int64 ), codimension [ * ], save :: barrier = 0 !character( kind= c_char, len= 1024), codimension[ *] :: hostname interface subroutine start_timer () bind ( C , name = \"start_timer\" ) use iso_c_binding end subroutine subroutine stop_timer () bind ( C , name = \"stop_timer\" ) use iso_c_binding end subroutine function elapsed_time () bind ( c , name = \"elapsed_time\" ) result ( res ) use iso_c_binding !use, intrinsic :: iso_fortran_env, only: int64 integer ( c_int ) :: res end function end interface type ( counters ), codimension [ * ] :: count_loc , globalminloc , globalmaxloc integer ( int64 ) :: j integer :: astat character ( len = 32 ) :: cl_arg ! ---------------------------------------------------------------------- !  psnap text continue rank = this_image () np = num_images () np_half = np / 2 j = 0 if ( rank == 1 ) then cl_args : do j = j + 1 if ( j >= command_argument_count () ) exit cl_args call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) which_arg : select case ( cl_arg ( 2 : 2 )) case ( 'b' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = barrier , fmt = * ) cl_arg do i = 2 , np barrier [ i ] = barrier end do case ( 'n' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = n , fmt = * ) cl_arg w = n / 10 do i = 2 , np n [ i ] = n w [ i ] = w end do case ( 'w' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = w , fmt = * ) cl_arg do i = 2 , np w [ i ] = w end do case ( 'c' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = iteration_count , fmt = * ) cl_arg do i = 2 , np iteration_count [ i ] = iteration_count end do case ( 'g' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = granularity , fmt = * ) cl_arg do i = 2 , np granularity [ i ] = granularity end do case ( 'h' ) call usage () stop 'normal exit in psnap' case default call usage () stop 'normal exit in psnap' end select which_arg end do cl_args end if !  distribute sizes before allocating sync all !call get_environment_variable( name= 'HOSTNAME', value= hostname) allocate ( r ( 1 : n + w ), stat = astat ) alloc_r_error : if ( astat > 0 ) then stop 'error allocating r' end if alloc_r_error allocate ( sum_all ( 1 : np ), stat = astat ) alloc_sum_error : if ( astat > 0 ) then stop 'error allocating sum_all' end if alloc_sum_error only_rank_0 : if ( rank == 1 ) then call print_banner () end if only_rank_0 ! ---------------------------------------------------------------------- !  warmup loop here; calibration follows if ( w > 0 ) call warmup_loop ( w ) if ( iteration_count == 0 ) then iteration_count = calibrate_loop ( granularity ) !write(*,*) 'Iteration after calibrate', iteration_count,'proc',rank count_loc % val = iteration_count count_loc % index = rank globalminloc = count_loc globalmaxloc = count_loc !  compute global counts before communicating them sync all do i = 2 , np if ( globalminloc [ i ]% val < globalminloc % val ) then globalminloc = globalminloc [ i ] end if if ( globalmaxloc [ i ]% val > globalmaxloc % val ) then globalmaxloc = globalmaxloc [ i ] end if end do if ( rank == 1 ) then write ( unit = output_unit , fmt = '( a, i0/ a, i0, a, i0/ a, i0, a, i0)' ) \"my_count= \" , iteration_count , & \"global_min= \" , globalminloc % val , \" min_loc= \" , globalminloc % index , & \"global_max= \" , globalmaxloc % val , \" max_loc= \" , globalmaxloc % index write ( unit = output_unit , fmt = string_fmt ) \"Using Global max for calibration\" end if iteration_count = globalmaxloc % val end if r = 0 ! ---------------------------------------------------------------------- !  measurement loop sync all do i = 1 , n + w r ( i ) = loop ( iteration_count ) if ( barrier /= 0 ) then if ( mod ( i , barrier ) == 0 ) sync all end if end do sync all ! ---------------------------------------------------------------------- !   build histograms localsum = sum ( r ( w + 1 : ) ) if ( rank == 1 ) then sum_all ( 1 ) = localsum do i = 2 , np sync images ( i ) sum_all ( i ) = localsum [ i ] end do else sync images ( 1 ) end if localmax = maxval ( r ( w + 1 : )) if ( rank == 1 ) then globalmax = localmax do i = 2 , np sync images ( i ) globalmax = max ( globalmax , localmax [ i ]) end do else sync images ( 1 ) end if if ( rank == 1 ) then do i = 2 , np globalmax [ i ] = globalmax end do end if sync all allocate ( localhist ( 0 : globalmax )[ * ], stat = astat ) alloc_localhist_error : if ( astat > 0 ) then stop 'error allocating localhist' end if alloc_localhist_error localhist = 0 make_hist : do i = 1 + w , n + w localhist ( r ( i )) = localhist ( r ( i )) + 1 end do make_hist final_print : if ( rank == 1 ) then !  print rank 0's histogram if ( n > 0 ) then write ( unit = output_unit , fmt = '(a, i9, 9x, i9, 3x)' ) \"#\" , 1 , sum_all ( 1 ) !, trim( hostname) do i = 0 , globalmax if ( localhist ( i ) > 0 ) then write ( unit = output_unit , fmt = '(1x, i9, i9, i9, 3x)' ) rank , i , localhist ( i ) !, trim( hostname) end if end do end if !  print rank i's histogram do i = 2 , np sync images ( i ) !localhist(:) = localhist(:)[ i] do j = lbound ( localhist , dim = 1 ), ubound ( localhist , dim = 1 ) localhist ( j ) = localhist ( j )[ i ] end do !hostname = hostname[ i] if ( n > 0 ) then write ( unit = output_unit , fmt = '(a, i9, 9x, i9, 3x)' ) \"#\" , i , sum_all ( i ) !, trim( hostname) do j = 0 , globalmax if ( localhist ( j ) > 0 ) then write ( unit = output_unit , fmt = '(1x, i9, i9, i9, 3x)' ) i , j , localhist ( j ) !, trim( hostname) end if end do end if end do else final_print sync images ( 1 ) end if final_print stop 'normal exit in psnap' contains ! --------------------------------------------------------------------- function get_usecs () result ( usecs ) !integer( int64) :: usecs !  usec per sec !integer( int64), parameter :: c = 1000000 !   integer( int64) :: t !   integer( int64) :: r integer ( kind = 8 ) :: t , r real ( real64 ) :: usecs integer ( kind = 8 ), parameter :: c = 1000000 continue !call system_clock( count= t, count_rate= r) call cpu_time ( usecs ) usecs = usecs * 1. d6 !if( r /= c ) usecs = int( real( t, 8) / real( r, 8) * real( c, 8)) !if( r /= c ) usecs = int( t/r * c) return end function get_usecs ! --------------------------------------------------------------------- function loop ( iterations ) result ( dt ) integer ( int64 ) :: dt integer ( int64 ), intent ( in ) :: iterations integer ( int64 ) :: i integer ( int64 ) :: usecs_init , usecs_final integer :: next_rank , prev_rank integer , codimension [ * ], save :: coarray continue !   usecs_init = get_usecs() call start_timer () next_rank = to_upper_half ( rank ) prev_rank = from_lower_half ( rank ) !   write(*,*) 'Proc',rank,'Next rank',next_rank,'Prev rank',prev_rank counter : do i = 1 , iterations even_odd : if ( sending_half ( rank ) ) then !  send rank to next then fetch rank coarray [ next_rank ] = coarray sync images ( next_rank ) else even_odd !  stay calm coarray [ prev_rank ] = coarray sync images ( prev_rank ) end if even_odd end do counter !   usecs_final = get_usecs() call stop_timer () !   write(*,*) 'usec_init',usec_init,'usec_final',usec_final dt = elapsed_time () !write(*,*) 'usec_init',usec_init,'usec_final',usec_final,'dt',dt return end function loop ! --------------------------------------------------------------------- subroutine warmup_loop ( wa ) integer ( int64 ), intent ( in ) :: wa !integer( int64), parameter :: counter = 1000000 integer ( int64 ), parameter :: counter = 10000 integer ( int64 ) :: min_time_usecs integer ( int64 ) :: loop_time integer :: i continue min_time_usecs = huge ( 0_int64 ) reloop : do i = 1 , wa loop_time = loop ( counter ) min_time_usecs = min ( loop_time , min_time_usecs ) end do reloop return end subroutine warmup_loop ! --------------------------------------------------------------------- function calibrate_loop ( usecs ) result ( cl ) integer ( int64 ) :: cl integer ( int64 ), intent ( in ) :: usecs integer ( int64 ), parameter :: calibrate_useconds = 100000000 !real( real64), parameter :: preset_tolerance = 0.001_real64 real ( real64 ), parameter :: preset_tolerance = 1.0_real64 integer ( int64 ), parameter :: initial_ntrial = 1000 !integer( int64), parameter :: initial_counter = 1000000 integer ( int64 ), parameter :: initial_counter = 100000 integer ( int64 ) :: counter integer ( int64 ) :: min_time_usecs integer ( int64 ) :: tolerance integer ( int64 ) :: difference integer ( int64 ) :: total_time integer ( int64 ) :: ntrial integer ( int64 ) :: i integer ( int64 ) :: loop_time continue counter = initial_counter !write(*,*) 'Counter after initial counter',counter !  if usecs / granularity is less than 1/preset_tolerance then use zero tolerance = int ( real ( usecs , real64 ) * preset_tolerance , int64 ) total_time = 0 trials : do ntrial = initial_ntrial min_time_usecs = huge ( 0_int64 ) get_min : do i = 1 , ntrial loop_time = loop ( counter ) !write(*,*) 'loop_time',loop_time min_time_usecs = min ( min_time_usecs , loop_time ) end do get_min !  keep an estimate of total calibration time total_time = total_time + min_time_usecs * ntrial counter = int ( real ( counter , real64 ) * real ( usecs , real64 ) / real ( min_time_usecs , real64 ), int64 ) !write(*,*) 'Counter after assignment',counter difference = abs ( min_time_usecs - usecs ) if ( difference <= tolerance . or . total_time >= calibrate_useconds ) exit trials end do trials cl = counter write ( unit = output_unit , fmt = '( a, i2, a, i10, a, i10, a, i10, a, i10)' ) \"#rank= \" , rank , & \" count= \" , counter , \" time= \" , min_time_usecs , & \" difference= \" , difference , \" tolerance= \" , tolerance time_out : if ( total_time > calibrate_useconds ) then write ( unit = output_unit , fmt = '( a, i2, a, f10.4, a, f10.4, a, f10.4, a, i0)' ) \"PSNAP: WARNING rank \" , rank , & \" didn't converge in 10 seconds tolerance = \" , & real ( difference ) / real ( usecs ), & \" should be \" , preset_tolerance , \" approx \" , & preset_tolerance * 10 0.0 , \" percent, granularity= \" , usecs end if time_out return end function calibrate_loop ! --------------------------------------------------------------------- subroutine print_banner () continue write ( unit = output_unit , fmt = string_fmt ) '########' write ( unit = output_unit , fmt = string_fmt ) '##P-SNAP: PAL System Noise Activity Program' write ( unit = output_unit , fmt = string_fmt ) '##' // psnap_rcs_id write ( unit = output_unit , fmt = string_fmt ) '##This is a Fortran translation of P-SNAP v 1.2 from' write ( unit = output_unit , fmt = string_fmt ) '##http://www.c3.lanl.gov/pal/software/psnap/' write ( unit = output_unit , fmt = string_fmt ) '##This program is the coarray ping-pong version' write ( unit = output_unit , fmt = string_fmt ) '########' return end subroutine print_banner ! --------------------------------------------------------------------- subroutine usage () character ( len = * ), dimension ( 17 ), parameter :: msg = & [ \"Usage: psnap [OPTIONS]                                             \" , & \"                                                                   \" , & \"  -n <reps>   number of repetitions                                \" , & \"                default: 100000                                    \" , & \"  -w <reps>   number of warm-up repetitions                        \" , & \"                default: 10%% of the number of reps                \" , & \"  -c <count>  calibration count                                    \" , & \"                default: perform a calibration to match granularity\" , & \"  -g <usecs>  granularity of the test in microseconds              \" , & \"                default: 1000                                      \" , & \"  -b <N>      perform a barrier between every N loops              \" , & \"                default: no                                        \" , & \"  -h          this message                                         \" , & \"                                                                   \" , & \"  Example: psnap -n 1000000 -w 10 > psnap.out                      \" , & \"    runs a test with 1000000 repetitions and 10 warm-up reps.      \" , & \"                                                                   \" ] integer :: i continue write ( unit = error_unit , fmt = string_fmt ) ( trim ( msg ( i )), i = 1 , size ( msg , 1 )) stop 'normal exit in usage' end subroutine usage ! --------------------------------------------------------------------- function sending_half ( i ) result ( l ) integer , intent ( in ) :: i logical :: l continue !  this must process np == even values only l = i <= np_half return end function sending_half ! --------------------------------------------------------------------- function to_upper_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process lower half ranks only l = i + np_half return end function to_upper_half ! --------------------------------------------------------------------- function from_lower_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process upper half ranks only l = i - np_half return end function from_lower_half ! --------------------------------------------------------------------- end program psnap","tags":"","loc":"sourcefile/cafpsnap.f90.html","title":"cafpsnap.f90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2012-2016, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! Unit tests for co_broadcast and co_sum program main use iso_fortran_env , only : error_unit use iso_c_binding , only : c_int , c_double , c_char #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none integer ( c_int ) :: me ! Set test failure as the default result logical :: c_char_test_passes = . false ., c_int_test_passes = . false ., c_double_test_passes = . false . ! Store the executing image number me = this_image () #ifdef USE_EXTENSIONS if ( me == 1 ) print * , \"Using the extensions from the opencoarrays module.\" #endif ! Verify broadcasting of character data from image 1 c_char_co_broadcast : block character ( kind = c_char , len = 14 ), save :: string_received [ * ] character ( kind = c_char , len =* ), parameter :: string_sent = c_char_ \"Hello, world!\" ! Character test message if ( me == 1 ) string_received = string_sent sync all call co_broadcast ( string_received , source_image = 1 ) if ( string_received /= string_sent ) then write ( error_unit , * ) \"Incorrect co_broadcast(\" , string_received , \") on image\" , me else c_char_test_passes = . true . end if end block c_char_co_broadcast ! Verify broadcasting of integer data from image 1 c_int_co_broadcast : block integer ( c_int ), save :: integer_received [ * ] integer ( c_int ), parameter :: integer_sent = 12345_c_int ! Integer test message if ( me == 1 ) integer_received = integer_sent sync all call co_broadcast ( integer_received , source_image = 1 ) if ( integer_received /= integer_sent ) then write ( error_unit , * ) \"Incorrect co_broadcast(\" , integer_received , \") on image\" , me else c_int_test_passes = . true . end if end block c_int_co_broadcast ! Verify broadcasting of real data from image 1 c_double_co_broadcast : block real ( c_double ), save :: real_received [ * ] real ( c_double ), parameter :: real_sent = 2.7182818459045_c_double ! Real test message if ( me == 1 ) real_received = real_sent sync all call co_broadcast ( real_received , source_image = 1 ) if ( real_received /= real_sent ) then write ( error_unit , * ) \"Incorrect co_broadcast(\" , real_received , \") on image\" , me else c_double_test_passes = . true . end if end block c_double_co_broadcast if (. not . all ([ c_char_test_passes , c_int_test_passes , c_double_test_passes ])) error stop ! Wait for everyone to pass the tests sync all if ( me == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/co_broadcast.f90.html","title":"co_broadcast.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2012-2016, Sourcery, Inc. ! All rights reserved. ! ! Unit tests for co_max: verify parallel, collective maximum ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program main use iso_fortran_env , only : error_unit use iso_c_binding , only : c_int , c_double #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none #ifdef USE_EXTENSIONS if ( this_image () == 1 ) print * , \"Using the extensions from the opencoarrays module.\" #endif ! Verify that 1 is the lowest image number c_int_co_min : block integer ( c_int ) :: me me = this_image () sync all call co_max ( me ) if ( me /= num_images ()) then write ( error_unit , \"(2(a,i2))\" ) \"Wrong result (\" , me , \") on image\" , this_image () error stop end if ! Wait for all images to pass the test sync all if ( me == 1 ) print * , \"Correct integer(c_int) co_min\" end block c_int_co_min ! Verify that the maximum real conversion of an image number is real(num_images()) c_double_co_max : block real ( c_double ) :: me me = real ( this_image (), c_double ) sync all call co_max ( me ) if ( me /= real ( num_images (), c_double )) then write ( error_unit , \"(2(a,i2))\" ) \"Wrong result (\" , me , \") on image\" , this_image () error stop end if ! Wait for all images to pass the test sync all if ( this_image () == 1 ) print * , \"Correct real(c_double) co_max\" end block c_double_co_max if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/co_max.f90.html","title":"co_max.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2012-2016, Sourcery, Inc. ! All rights reserved. ! ! Unit tests for co_min: verify parallel, collective minimum ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program main use iso_fortran_env , only : error_unit use iso_c_binding , only : c_int , c_double #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none logical :: co_min_c_int_verified = . false ., co_min_c_double_verified = . false . #ifdef USE_EXTENSIONS if ( this_image () == 1 ) print * , \"Using the extensions from the opencoarrays module.\" #endif ! Verify that 1 is the lowest image number c_int_co_min : block integer ( c_int ) :: me me = this_image () sync all call co_min ( me ) if ( me == 1 ) then co_min_c_int_verified = . true . else write ( error_unit , \"(2(a,i2))\" ) \"co_min fails for integer(c_int) argument with result (\" , me , \") on image\" , this_image () end if end block c_int_co_min ! Verify that 1.0 is the minimum real conversion of an image number c_double_co_min : block real ( c_double ) :: me me = real ( this_image (), c_double ) sync all call co_min ( me ) if ( me == 1._c_double ) then co_min_c_double_verified = . true . else write ( error_unit , \"(2(a,i2))\" ) \"co_min fails for integer(c_double) argument with result (\" , me , \") on image\" , this_image () end if end block c_double_co_min if (. not . all ([ co_min_c_int_verified , co_min_c_double_verified ])) error stop ! Wait for all images to pass the tests sync all if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/co_min.f90.html","title":"co_min.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2012-2016, Sourcery, Inc. ! All rights reserved. ! ! Unit tests for co_min: verify parallel, collective minimum ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. module co_intrinsics_module #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none private public :: co_all public :: co_product interface co_all module procedure co_all_logical end interface interface co_product module procedure co_product_c_int , co_product_c_double end interface contains subroutine co_all_logical ( a ) logical , intent ( inout ) :: a (:) call co_reduce ( a , and ) contains pure function and ( lhs , rhs ) result ( lhs_and_rhs ) bind ( C , name = \"and\" ) logical , intent ( in ) :: lhs , rhs logical :: lhs_and_rhs lhs_and_rhs = lhs . and . rhs end function end subroutine subroutine co_product_c_int ( a ) use iso_c_binding , only : c_int integer ( c_int ), intent ( inout ) :: a call co_reduce ( a , product_ ) contains pure function product_ ( lhs , rhs ) result ( lhs_x_rhs ) bind ( C , name = \"product_\" ) integer ( c_int ), intent ( in ) :: lhs , rhs integer ( c_int ) :: lhs_x_rhs lhs_x_rhs = lhs * rhs end function end subroutine subroutine co_product_c_double ( a ) use iso_c_binding , only : c_double real ( c_double ), intent ( inout ) :: a call co_reduce ( a , product_ ) contains pure function product_ ( lhs , rhs ) result ( lhs_x_rhs ) real ( c_double ), intent ( in ) :: lhs , rhs real ( c_double ) :: lhs_x_rhs lhs_x_rhs = lhs * rhs end function end subroutine end module program main use iso_fortran_env , only : error_unit use iso_c_binding , only : c_int , c_double use co_intrinsics_module , only : co_all , co_product #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none logical :: logical_passes = . false ., c_int_passes = . false . #ifdef USE_EXTENSIONS if ( this_image () == 1 ) print * , \"Using the extensions from the opencoarrays module.\" #endif ! Verify that every image has a \"true\" variable with the value .true. verify_co_reduce_logical : block logical , dimension ( 10 ) :: true = . true . sync all call co_all ( true ) if ( all ( true . eqv . . true .)) then logical_passes = . true . else write ( error_unit , \"(2(a,i2))\" ) \"co_reduce fails for logical argument with result (\" , true , \") on image\" , this_image () end if end block verify_co_reduce_logical ! Verify the product of image number verify_co_reduce_c_int : block integer ( c_int ) :: me , i me = this_image () sync all call co_product ( me ) if ( me == product ( int ([( i , i = 1 , num_images ())], c_int ))) then c_int_passes = . true . else write ( error_unit , \"(2(a,i2))\" ) \"co_reduce fails integer(c_int) argument with result (\" , me , \") on image\" , this_image () end if end block verify_co_reduce_c_int ! Verify that this image's tests passed if (. not . all ([ logical_passes , c_int_passes ])) error stop ! Wait for verification that all images to pass the tests sync all if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/co_reduce.f90.html","title":"co_reduce.F90 – OpenCoarrays"},{"text":"Source Code ! Copyright (c) 2012-2016, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of Sourcery, Inc., nor the !       names of any other contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE ! FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! Unit tests for co_sum program main use iso_fortran_env , only : error_unit use iso_c_binding , only : c_int , c_double #ifdef USE_EXTENSIONS use opencoarrays #endif implicit none logical :: co_sum_c_int_verified = . false ., co_sum_c_double_verified = . false . #ifdef USE_EXTENSIONS if ( this_image () == 1 ) print * , \"Using the extensions from the opencoarrays module.\" #endif ! Verify collective sum of integer data by tallying image numbers c_int_co_sum : block integer ( c_int ) :: i , me me = this_image () sync all call co_sum ( me ) if ( me == sum ([( i , i = 1 , num_images ())])) then co_sum_c_int_verified = . true . else write ( error_unit , \"(2(a,i2))\" ) \"co_broadcast with integer(c_int) argument fails with result (\" , me , \") on image\" , this_image () end if end block c_int_co_sum ! Verify collective sum by calculuating pi c_double_co_sum : block real ( c_double ), parameter :: four = 4._c_double , one = 1._c_double , half = 0.5_c_double real ( c_double ), save :: pi integer ( c_int ) :: i , points_per_image integer ( c_int ), parameter :: resolution = 1024_c_int ! Number of points used in pi calculation integer ( c_int ) :: me me = this_image () ! Partition the calculation evenly across all images if ( mod ( resolution , num_images ()) /= 0 ) then write ( error_unit , \"(a)\" ) \"number of images doesn't evenly divide into number of points\" error stop end if points_per_image = resolution / num_images () associate ( n => resolution , my_first => points_per_image * ( me - 1 ) + 1 , my_last => points_per_image * me ) pi = sum ([ ( four / ( one + (( i - half ) / n ) ** 2 ), i = my_first , my_last ) ]) / n end associate sync all ! Replace pi on each image with the sum of the pi contributions from all images call co_sum ( pi ) associate ( pi_ref => acos ( - 1._c_double ), allowable_fractional_error => 0.000001_c_double ) if ( abs (( pi - pi_ref ) / pi_ref ) <= allowable_fractional_error ) then co_sum_c_double_verified = . true . else write ( error_unit , * ) \"co_broadcast with real(c_double) argument fails with result (\" , pi , \") result on image \" , me end if end associate end block c_double_co_sum if (. not . all ([ co_sum_c_int_verified , co_sum_c_double_verified ])) error stop ! Wait for every image to pass sync all if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/co_sum.f90.html","title":"co_sum.F90 – OpenCoarrays"},{"text":"Source Code ! This test checks if allocate on coarray variables acts as a barrier. program alloc_as_barrier implicit none integer :: me [ * ] integer , allocatable :: a (:)[:] me = this_image () if ( me == 1 ) call sleep ( 1 ) allocate ( a ( 10 )[ * ]) if ( me > 1 ) then a = me [ me - 1 ] if ( any ( a /= me - 1 )) then write ( * , * ) \"Test failed.\" else write ( * , * ) \"Test passed.\" endif endif end program","tags":"","loc":"sourcefile/allocate_as_barrier.f90.html","title":"allocate_as_barrier.f90 – OpenCoarrays"},{"text":"Source Code ! This test checks if allocate on coarray variables acts as a barrier. program alloc_as_barrier implicit none integer :: me call test_alloc ( me ) if ( this_image () == 2 ) then if ( me /= 1 ) then write ( * , * ) \"Test failed.\" , me else write ( * , * ) \"Test passed.\" endif endif contains subroutine test_alloc ( me ) integer , intent ( out ) :: me integer , allocatable :: a (:)[:] me = this_image () if ( me == 1 ) call sleep ( 1 ) allocate ( a ( 10 )[ * ], source = me ) if ( me > 1 ) me = a ( 2 )[ this_image () - 1 ] deallocate ( a ) end subroutine end program","tags":"","loc":"sourcefile/allocate_as_barrier_proc.f90.html","title":"allocate_as_barrier_proc.f90 – OpenCoarrays"},{"text":"Source Code ! Unit test for initializion of MPI by LIBCAF_MPI. ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! program initialize_mpi use mpi , only : MPI_COMM_SIZE , MPI_COMM_WORLD implicit none ! Set invalid default image number and number of ranks integer :: me =- 1 , np =- 1 , ierr ! Get image number me = this_image () ! Get number of ranks (np) call MPI_COMM_SIZE ( MPI_COMM_WORLD , np , ierr ) ! Everybody verifies that they have a valid image number and rank if ( me < 1 . or . np < 1 ) error stop \"Test failed.\" ! Image 1 reports test success if ( me == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/initialize_mpi.f90.html","title":"initialize_mpi.f90 – OpenCoarrays"},{"text":"Source Code ! Unit test for register procedure. Testing static coarrays. ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program register implicit none integer , parameter :: invalid_image_number =- 1 integer , save :: me [ * ] = invalid_image_number if ( num_images () < 2 ) error stop \"This test requires at least 2 images.\" me = this_image () sync all if ( me == 1 ) then block integer :: image2number image2number = me [ 2 ] if ( image2number /= 2 ) error stop \"Test failed.\" print * , \"Test passed.\" end block end if end program","tags":"","loc":"sourcefile/register.f90.html","title":"register.f90 – OpenCoarrays"},{"text":"Source Code ! Unit test for register procedure. Testing static arrays coarrays. ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program register2 implicit none integer , parameter :: array_size = 10 integer :: np , arr1 ( array_size )[ * ] np = num_images () arr1 = this_image () sync all if ( this_image () == 1 ) then if ( size ( arr1 ) /= array_size ) error stop 'Test failed.' print * , 'Test passed.' endif end program","tags":"","loc":"sourcefile/register_rename_me.f90.html","title":"register_rename_me.f90 – OpenCoarrays"},{"text":"Source Code ! Unit test for register procedure. Testing allocatable arrays coarrays. ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. program register3 implicit none integer , parameter :: invalid_rank =- 2 integer :: np = invalid_rank , array_size = 10 integer , allocatable :: array (:)[:] np = num_images () allocate ( array ( array_size )[ * ], source = this_image ()) block logical :: res = . true . if ( this_image () == 1 ) then if ( size ( array ) /= array_size ) error stop \"Test failed.\" endif deallocate ( array ) if ( allocated ( array )) error stop \"Test failed.\" if ( this_image () == 1 ) print * , \"Test passed.\" end block end program","tags":"","loc":"sourcefile/register_rename_me_too.f90.html","title":"register_rename_me_too.f90 – OpenCoarrays"},{"text":"Source Code ! ! This program does a correctness check for ! ... = ARRAY[idx] and ... = SCALAR[idx] ! program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays !  call two() !  call three() write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:), c (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & c ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = b caf = - 42 c = caf sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) call abort () endif ! Whole array: ARRAY = ARRAY caf = - 42 a = b c = caf if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 1:' , any ( a /= c ) print * , a print * , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Scalar assignment a = - 42 caf = - 42 c = caf sync all do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 2:' , any ( a /= c ) print * , this_image (), ': ' , a print * , this_image (), ': ' , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 42 caf = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if ! ARRAY = ARRAY caf = - 42 a = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"sourcefile/get_array_test.f90.html","title":"get_array_test.f90 – OpenCoarrays"},{"text":"Source Code program get_offset_1d implicit none integer , allocatable :: a (:)[:], b (:) integer :: me , np , i me = this_image () np = num_images () allocate ( a ( 100 )[ * ], b ( 10 )) a = ( / ( i , i = 1 , 100 ) / ) do i = 1 , 100 a ( i ) = a ( i ) + me enddo sync all if ( me < np ) then b (:) = a ( 21 : 30 )[ me + 1 ] endif if ( me == 1 ) then do i = 1 , 10 if ( b ( i ) /= 20 + i + me + 1 ) call abort () enddo write ( * , * ) 'Test passed.' endif end program","tags":"","loc":"sourcefile/get_with_offset_1d.f90.html","title":"get_with_offset_1d.f90 – OpenCoarrays"},{"text":"Source Code ! ! This program does a correctness check for ! ARRAY = SCALAR and ARRAY = ARRAY ! program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays call two () call three () write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] print * , this_image (), '//' , a , '//' , b ( lb1 , lb2 ) print * , '>>>' , any ( a /= b ( lb1 , lb2 )) if ( any ( a /= b ( lb1 , lb2 ))) then ! FIXME: ABORTS UNLESS THERE IS SOME OTHER CODE print * , 'HELLO!!!!!!!!!!!!!!!!!' call abort () end if end if ! Whole array: ARRAY = ARRAY a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] if ( any ( a /= b )) & !FIXME print * , a print * , b print * , 'WRONG:' , any ( a /= b ) call abort () end if end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !\t\t      b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !\t\t\t   = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY b = - 32 a = - 12 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            =caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                      if (any (a /= b)) then !                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                             lb2,\":\",m+lb2-1 !                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                        print *, i !                        print *, a !                        print *, caf !                        print *, a-caf !                        call abort() !                      endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"sourcefile/old_get_array_test.f90.html","title":"old_get_array_test.f90 – OpenCoarrays"},{"text":"Source Code ! This program tests the capability of copying data on the ! same memory location and within the same image from ! different memory locations. ! NOTE: ! In order to run this test successfully the efficient ! strided transfer support must be disabled. program sameloc implicit none integer , codimension [ * ] :: a integer , dimension ( 10 ), codimension [ * ] :: b , c integer , dimension ( 9 , 10 ), codimension [ * ] :: m integer , dimension ( 10 ) :: t integer :: i , j a = 10 b ( 1 : 5 ) = 1 b ( 6 : 10 ) = - 1 c ( 1 : 5 ) = 1 c ( 6 : 10 ) = - 1 t (:) = b (:) t ( 1 : 5 ) = b ( 2 : 6 ) do i = 1 , 9 m ( i ,:) = ( / ( j , j = 1 , 10 ) / ) enddo sync all a = a [ 1 ] if ( this_image () == 1 ) write ( * , * ) 'OK' , a t = ( / ( j , j = 1 , 10 ) / ) if ( this_image () == 1 ) then c = m ( 1 ,:)[ 1 ] if ( any ( c (:) /= t (:))) then call abort () else write ( * , * ) 'ok get row' endif endif sync all if ( this_image () == 1 ) then do i = 1 , 10 if ( m ( 9 , i )[ 1 ] /= t ( i )) then write ( * , * ) 'pos' , i , 'value get' , m ( 9 , i )[ 1 ], 'value t' , t ( i ) call abort () endif enddo endif if ( this_image () == 1 ) write ( * , * ) 'Ok get element from matrix' sync all m ( 9 ,:) = 1 if ( this_image () == 1 ) then do i = 1 , 10 m ( 9 , i )[ 1 ] = i if ( m ( 9 , i )[ 1 ] /= t ( i )) then write ( * , * ) 'pos' , i , 'value get' , m ( 9 , i )[ 1 ], 'value t' , t ( i ) call abort () endif enddo endif if ( this_image () == 1 ) write ( * , * ) 'Ok put element from matrix' t (:) = b (:) t ( 1 : 5 ) = b ( 2 : 6 ) c ( 1 : 5 ) = 1 c ( 6 : 10 ) = - 1 sync all if ( this_image () == 1 ) then b ( 1 : 5 )[ 1 ] = b ( 2 : 6 ) if ( any ( b (:) /= t (:))) then call abort () else write ( * , * ) 'OK put overlapped' endif endif b ( 1 : 5 ) = 1 b ( 6 : 10 ) = - 1 sync all if ( this_image () == 1 ) then b ( 1 : 5 )[ 1 ] = b ( 2 : 6 )[ 1 ] if ( any ( b (:) /= t (:))) then call abort () else write ( * , * ) 'OK putget overlapped' endif endif t (:) = c (:) t ( 10 : 1 : - 1 ) = t (:) sync all if ( this_image () == 1 ) then c ( 10 : 1 : - 1 )[ 1 ] = c (:) if ( any ( t (:) /= c (:))) then write ( * , * ) 'Error in put reversed' write ( * , * ) c write ( * , * ) t call abort () else write ( * , * ) 'OK put reversed' endif endif c ( 1 : 5 ) = 1 c ( 6 : 10 ) = - 1 t (:) = c (:) t ( 10 : 1 : - 1 ) = t (:) if ( this_image () == 1 ) then c (:) = c ( 10 : 1 : - 1 )[ 1 ] if ( any ( t (:) /= c (:))) then write ( * , * ) c write ( * , * ) t call abort () else write ( * , * ) 'OK get reversed' endif endif end program","tags":"","loc":"sourcefile/sameloc.f90.html","title":"sameloc.f90 – OpenCoarrays"},{"text":"Source Code ! ! This program does a correctness check for ! ARRAY[idx] = SCALAR, ARRAY[idx] = ARRAY and SCALAR[idx] = SCALAR ! program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays call two () call three () write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"sourcefile/send_array_test.f90.html","title":"send_array_test.f90 – OpenCoarrays"},{"text":"Source Code program strided_get use iso_c_binding , only : DPC => c_double implicit none integer :: i , me , np integer , allocatable :: a (:,:,:,:)[:], b (:,:,:,:) complex ( kind = DPC ), allocatable :: ac (:,:,:,:)[:], bc (:,:,:,:) me = this_image () np = num_images () allocate ( ac ( 0 : 11 , - 10 : - 5 , - 1 : 0 , - 1 : 5 )[ * ], bc ( 6 , 6 , 2 , 7 )) ac = me bc = me sync all if ( me == 2 ) then bc ( 1 : 2 ,:,:,:) = ac ( 0 : 1 ,:,:,:)[ me - 1 ] if ( any ( bc ( 1 : 2 ,:,:,:) /= 1 )) call abort () write ( * , * ) 'Test passed.' endif end program","tags":"","loc":"sourcefile/strided_get.f90.html","title":"strided_get.f90 – OpenCoarrays"},{"text":"Source Code program whole_array_get implicit none integer , allocatable :: x1 (:)[:], y1 (:) integer , allocatable :: x2 (:,:)[:], y2 (:,:) integer , allocatable :: x3 (:,:,:)[:], y3 (:,:,:) integer , parameter :: n = 10 integer :: me , np , i , j , k me = this_image () np = num_images () allocate ( x1 ( n )[ * ], y1 ( n )) x1 = me y1 = 0 sync all if ( me == 1 ) then y1 = x1 (:)[ me + 1 ] if ( any ( y1 /= 2 )) then write ( * , * ) 'Test 1 fails' call abort () end if end if deallocate ( x1 ) allocate ( x2 ( 1 : n , 0 : n - 1 )[ * ], y2 ( n , n )) x2 = me y1 = 0 ; y2 = 0 sync all if ( me == 1 ) then y2 = x2 (:,:)[ np ] if ( any ( y2 /= np )) then write ( * , * ) 'Test 2 fails' call abort () end if end if sync all x2 (:, n / 2 ) = x2 (:, n / 2 ) + n / 2 sync all if ( me == 1 ) then y1 = x2 (:, n / 2 )[ me + 1 ] if ( any ( y1 /= 2 + n / 2 )) then write ( * , * ) 'Test 3 fails' call abort () end if end if deallocate ( y1 , x2 , y2 ) allocate ( x3 ( 0 : n - 1 , 1 : n , - 1 : n - 2 )[ * ], y3 ( n , n , n )) x3 = me ; y3 = 0 sync all if ( me == 1 ) then y3 = x3 (:,:,:)[ me + 1 ] if ( any ( y3 /= me + 1 )) then write ( * , * ) 'Test 4 fails' call abort () end if endif sync all x3 (:,:, n / 2 ) = me + n / 2 y3 = 0 sync all if ( me == 1 ) then y3 (:, n / 2 ,:) = x3 (:,:, n / 2 )[ me + 1 ] if ( any ( y3 (:, n / 2 ,:) /= me + 1 + n / 2 )) then write ( * , * ) 'Test 5 fails' call abort () end if endif if ( me == 1 ) write ( * , * ) 'Test passed.' end program whole_array_get","tags":"","loc":"sourcefile/whole_get_array.f90.html","title":"whole_get_array.f90 – OpenCoarrays"},{"text":"Source Code ! syncimages test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program syncimages implicit none integer :: me , ne , i integer :: p [ * ] = 0 logical :: test [ * ] = . true . me = this_image () ne = num_images () if ( me == 1 ) then p = 1 else sync images ( me - 1 ) p = p [ me - 1 ] + 1 endif if ( me < ne ) sync images ( me + 1 ) if ( me /= p ) test = . false . sync all if ( me == 1 ) then do i = 1 , ne if ( test [ i ]. eqv .. false .) error stop \"Test failed.\" enddo endif if ( me == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/syncimages.f90.html","title":"syncimages.f90 – OpenCoarrays"},{"text":"Source Code ! syncimages2 test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! ! The test passes if it terminates ! If the test fails you will get an error or a non-termination. program syncimages2 implicit none if ( this_image () == 1 ) then sync images ( * ) else sync images ( 1 ) endif sync all if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/syncimages2.f90.html","title":"syncimages2.f90 – OpenCoarrays"},{"text":"Source Code ! test1caf test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program test1caf implicit none integer , parameter :: num_local_elems = 3 , a_initial = 1 , b_initial = 2 integer :: a ( num_local_elems )[ * ] = a_initial , b ( num_local_elems )[ * ] = b_initial integer :: i , me , np , left , right me = this_image () np = num_images () left = merge ( np , me - 1 , me == 1 ) right = merge ( 1 , me + 1 , me == np ) if ( mod ( me , 2 ). eq . 0 ) then a (:)[ right ] = a (:)[ right ] + me else b (:)[ left ] = b (:)[ left ] + me end if if ( me == 1 ) then write ( * , * ) me , a , b else sync images ( me - 1 ) write ( * , * ) me , a , b end if if ( me < np ) sync images ( me + 1 ) if ( mod ( me , 2 ). eq . 0 ) then if ( any ( a (:)[ right ] /= a_initial + me )) error stop \"Test failed.\" else if ( any ( b (:)[ left ] /= b_initial + me )) error stop \"Test failed.\" end if if ( me == 1 ) print * , \"Test passed.\" end program test1caf","tags":"","loc":"sourcefile/test1caf.f90.html","title":"test1Caf.f90 – OpenCoarrays"},{"text":"Source Code program atomic use iso_fortran_env implicit none integer :: me , np , res integer ( atomic_int_kind ) :: atom [ * ] me = this_image () np = num_images () call atomic_define ( atom [ 1 ], 0 ) sync all call ATOMIC_ADD ( atom [ 1 ], me ) sync all if ( me == 1 ) then call atomic_ref ( res , atom [ 1 ]) if ( res /= ( np * ( np + 1 )) / 2 ) then write ( * , * ) 'res' , res call abort () endif write ( * , * ) 'OK' endif end program","tags":"","loc":"sourcefile/testatomics.f90.html","title":"testAtomics.f90 – OpenCoarrays"},{"text":"Source Code ! syncimages test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program duplicate_syncimages implicit none integer :: me , i , array ( 4 ) integer :: stat = 0 me = this_image () if ( me == 1 ) then array ( 1 ) = 5 ; array ( 2 ) = 6 ; array ( 3 ) = 7 ; array ( 4 ) = 5 sync images ( array , stat = stat ) if ( stat == 3 ) then print * , \"Test passed.\" else print * , \"Test failed.\" endif endif sync all end program","tags":"","loc":"sourcefile/duplicate_syncimages.f90.html","title":"duplicate_syncimages.f90 – OpenCoarrays"},{"text":"Source Code ! syncall test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program syncall implicit none integer :: me , np , i integer :: scalar [ * ] me = this_image () np = num_images () scalar = - 1 if ( me /= 1 ) call sleep ( 1 ) scalar = 1 sync all if ( me == 1 ) then do i = 1 , np if ( scalar [ i ] /= 1 ) then write ( * , * ) 'Test failed.' stop endif end do end if if ( me == 1 ) print * , 'Test passed.' end program syncall","tags":"","loc":"sourcefile/syncall.f90.html","title":"syncall.f90 – OpenCoarrays"},{"text":"Source Code ! syncimages test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! program syncimages implicit none integer :: me , ne , i integer :: p [ * ] = 0 logical :: test [ * ] = . true . me = this_image () ne = num_images () if ( me == 1 ) then p = 1 else sync images ( me - 1 ) p = p [ me - 1 ] + 1 endif if ( me < ne ) sync images ( me + 1 ) if ( me /= p ) test = . false . sync all if ( me == 1 ) then do i = 1 , ne if ( test [ i ]. eqv .. false .) error stop \"Test failed.\" enddo endif if ( me == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/syncimages.f90~2.html","title":"syncimages.f90 – OpenCoarrays"},{"text":"Source Code ! syncimages2 test ! ! Copyright (c) 2012-2014, Sourcery, Inc. ! All rights reserved. ! ! Redistribution and use in source and binary forms, with or without ! modification, are permitted provided that the following conditions are met: !     * Redistributions of source code must retain the above copyright !       notice, this list of conditions and the following disclaimer. !     * Redistributions in binary form must reproduce the above copyright !       notice, this list of conditions and the following disclaimer in the !       documentation and/or other materials provided with the distribution. !     * Neither the name of the Sourcery, Inc., nor the !       names of its contributors may be used to endorse or promote products !       derived from this software without specific prior written permission. ! ! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ! ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED ! WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE ! DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY ! DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES ! (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; ! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ! ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS ! ! The test passes if it terminates ! If the test fails you will get an error or a non-termination. program syncimages2 implicit none if ( this_image () == 1 ) then sync images ( * ) else sync images ( 1 ) endif sync all if ( this_image () == 1 ) print * , \"Test passed.\" end program","tags":"","loc":"sourcefile/syncimages2.f90~2.html","title":"syncimages2.f90 – OpenCoarrays"},{"text":"Source Code ! SYNC IMAGES(*) with the STAT=STAT_STOPPED_IMAGE specifier ! Based on a test taken from UH caf-testsuite program sync_images_stat use , intrinsic :: iso_fortran_env implicit none integer :: stat_var = 0 , me me = this_image () if ( me /= 1 ) then call sleep ( 1 ) sync images ( * , STAT = stat_var ) if ( stat_var /= STAT_STOPPED_IMAGE ) then print * , \"Error:stat_var /= STAT_STOPPED_IMAGE: \" , me ERROR STOP 1 end if if ( me == 2 ) print * , 'Test passed.' end if end program sync_images_stat","tags":"","loc":"sourcefile/syncimages_status.f90.html","title":"syncimages_status.f90 – OpenCoarrays"},{"text":"Source Code /* One-sided MPI implementation of Libcaf Copyright (c) 2012-2016, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ #ifndef LIBCAF_GFORTRAN_DESCRIPTOR_H #define LIBCAF_GFORTRAN_DESCRIPTOR_H #include <stdint.h>\t/* For int32_t.  */ /* GNU Fortran's array descriptor.  Keep in sync with libgfortran.h.  To be replaced by TS29113's ISO_Fortran_binding.h with CFI_cdesc_t.  */ enum { BT_UNKNOWN = 0 , BT_INTEGER , BT_LOGICAL , BT_REAL , BT_COMPLEX , BT_DERIVED , BT_CHARACTER , BT_CLASS , BT_PROCEDURE , BT_HOLLERITH , BT_VOID , BT_ASSUMED }; typedef struct descriptor_dimension { ptrdiff_t _stride ; ptrdiff_t lower_bound ; ptrdiff_t _ubound ; } descriptor_dimension ; typedef struct gfc_descriptor_t { void * base_addr ; size_t offset ; ptrdiff_t dtype ; descriptor_dimension dim []; } gfc_descriptor_t ; #define GFC_MAX_DIMENSIONS 7 #define GFC_DTYPE_RANK_MASK 0x07 #define GFC_DTYPE_TYPE_SHIFT 3 #define GFC_DTYPE_TYPE_MASK 0x38 #define GFC_DTYPE_SIZE_SHIFT 6 #define GFC_DESCRIPTOR_RANK(desc) ((desc)->dtype & GFC_DTYPE_RANK_MASK) #define GFC_DESCRIPTOR_TYPE(desc) (((desc)->dtype & GFC_DTYPE_TYPE_MASK) \\ >> GFC_DTYPE_TYPE_SHIFT) #define GFC_DESCRIPTOR_SIZE(desc) ((desc)->dtype >> GFC_DTYPE_SIZE_SHIFT) #define GFC_DTYPE_SIZE_MASK \\ ((~((ptrdiff_t) 0) >> GFC_DTYPE_SIZE_SHIFT) << GFC_DTYPE_SIZE_SHIFT) #define GFC_DTYPE_TYPE_SIZE_MASK (GFC_DTYPE_SIZE_MASK | GFC_DTYPE_TYPE_MASK) #define GFC_DTYPE_TYPE_SIZE(desc) ((desc)->dtype & GFC_DTYPE_TYPE_SIZE_MASK) #define GFC_DTYPE_INTEGER_1 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(int8_t) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_INTEGER_2 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(int16_t) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_INTEGER_4 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(int32_t) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_INTEGER_8 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(int64_t) << GFC_DTYPE_SIZE_SHIFT)) #if HAVE_INT128_T #define GFC_DTYPE_INTEGER_16 ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(__int128_t) << GFC_DTYPE_SIZE_SHIFT)) #endif #define GFC_DTYPE_LOGICAL_4 ((BT_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(int) << GFC_DTYPE_SIZE_SHIFT)) #if 0 #define GFC_DTYPE_LOGICAL_1 ((BT_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_LOGICAL_1) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_LOGICAL_2 ((BT_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_LOGICAL_2) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_LOGICAL_8 ((BT_LOGICAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(double) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_LOGICAL_16 ((BT_LOGICAL << GFC_DTYPE_TYPE_SHIFT)\\ | (sizeof(GFC_LOGICAL_16) << GFC_DTYPE_SIZE_SHIFT)) #endif #define GFC_DTYPE_REAL_4 ((BT_REAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(float) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_REAL_8 ((BT_REAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(double) << GFC_DTYPE_SIZE_SHIFT)) #if 0 #ifdef HAVE_GFC_REAL_10 #define GFC_DTYPE_REAL_10  ((BT_REAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_REAL_10) << GFC_DTYPE_SIZE_SHIFT)) #endif #ifdef HAVE_GFC_REAL_16 #define GFC_DTYPE_REAL_16 ((BT_REAL << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_REAL_16) << GFC_DTYPE_SIZE_SHIFT)) #endif #endif #define GFC_DTYPE_COMPLEX_4 ((BT_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(_Complex float) << GFC_DTYPE_SIZE_SHIFT)) #define GFC_DTYPE_COMPLEX_8 ((BT_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(_Complex double) << GFC_DTYPE_SIZE_SHIFT)) #if 0 #ifdef HAVE_GFC_COMPLEX_10 #define GFC_DTYPE_COMPLEX_10 ((BT_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_COMPLEX_10) << GFC_DTYPE_SIZE_SHIFT)) #endif #ifdef HAVE_GFC_COMPLEX_16 #define GFC_DTYPE_COMPLEX_16 ((BT_COMPLEX << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(GFC_COMPLEX_16) << GFC_DTYPE_SIZE_SHIFT)) #endif #endif /* FIXME: Hardwiring these values to what the mpi_caf.c macro GFC_DTYPE_TYPE_SIZE(desc) receives in the dtype component its gf_descriptor_t argument for character(kind=c_char) and logical(kind=c_bool) data: */ #define GFC_DTYPE_CHARACTER 48 #if 0 #define GFC_DTYPE_CHARACTER ((BT_CHARACTER << GFC_DTYPE_TYPE_SHIFT) \\ | (sizeof(char) << GFC_DTYPE_SIZE_SHIFT)) #endif #endif /* LIBCAF_GFORTRAN_DESCRIPTOR_H.  */","tags":"","loc":"sourcefile/libcaf-gfortran-descriptor.h.html","title":"libcaf-gfortran-descriptor.h – OpenCoarrays"},{"text":"Source Code /* One-sided MPI implementation of Libcaf Copyright (c) 2012-2016, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ #ifndef LIBCAF_H #define LIBCAF_H #include <stdint.h>\t/* For int32_t.  */ #include <stddef.h>\t/* For size_t.  */ #include <stdbool.h> #include \"libcaf-gfortran-descriptor.h\" #ifndef __GNUC__ #define __attribute__(x) #define likely(x)       (x) #define unlikely(x)     (x) #else #define likely(x)       __builtin_expect(!!(x), 1) #define unlikely(x)     __builtin_expect(!!(x), 0) #endif #ifdef PREFIX_NAME #define PREFIX3(X,Y) X ## Y #define PREFIX2(X,Y) PREFIX3(X,Y) #define PREFIX(X) PREFIX2(PREFIX_NAME,X) #else #define PREFIX(X) X #endif /* Definitions of the Fortran 2008 standard; need to kept in sync with ISO_FORTRAN_ENV, cf. libgfortran.h.  */ #define STAT_UNLOCKED\t\t0 #define STAT_LOCKED\t\t1 #define STAT_LOCKED_OTHER_IMAGE\t2 #define STAT_DUP_SYNC_IMAGES    3 #define STAT_STOPPED_IMAGE \t6000 /* Describes what type of array we are registerring. Keep in sync with gcc/fortran/trans.h.  */ typedef enum caf_register_t { CAF_REGTYPE_COARRAY_STATIC , CAF_REGTYPE_COARRAY_ALLOC , CAF_REGTYPE_LOCK_STATIC , CAF_REGTYPE_LOCK_ALLOC , CAF_REGTYPE_CRITICAL , CAF_REGTYPE_EVENT_STATIC , CAF_REGTYPE_EVENT_ALLOC } caf_register_t ; typedef void * caf_token_t ; /* Linked list of static coarrays registered.  */ typedef struct caf_static_t { caf_token_t token ; struct caf_static_t * prev ; } caf_static_t ; /* When there is a vector subscript in this dimension, nvec == 0, otherwise, lower_bound, upper_bound, stride contains the bounds relative to the declared bounds; kind denotes the integer kind of the elements of vector[].  */ typedef struct caf_vector_t { size_t nvec ; union { struct { void * vector ; int kind ; } v ; struct { ptrdiff_t lower_bound , upper_bound , stride ; } triplet ; } u ; } caf_vector_t ; /* Common auxiliary functions: caf_auxiliary.c.  */ bool PREFIX ( is_contiguous ) ( gfc_descriptor_t * ); /* Header for the specific implementation.  */ void PREFIX ( init ) ( int * , char *** ); void PREFIX ( finalize ) ( void ); int PREFIX ( this_image ) ( int ); int PREFIX ( num_images ) ( int , int ); void * PREFIX ( register ) ( size_t , caf_register_t , caf_token_t * , int * , char * , int ); void PREFIX ( deregister ) ( caf_token_t * , int * , char * , int ); void PREFIX ( caf_get ) ( caf_token_t , size_t , int , gfc_descriptor_t * , caf_vector_t * , gfc_descriptor_t * , int , int ); void PREFIX ( caf_send ) ( caf_token_t , size_t , int , gfc_descriptor_t * , caf_vector_t * , gfc_descriptor_t * , int , int ); void PREFIX ( caf_sendget ) ( caf_token_t , size_t , int , gfc_descriptor_t * , caf_vector_t * , caf_token_t , size_t , int , gfc_descriptor_t * , caf_vector_t * , int , int ); void PREFIX ( co_max ) ( gfc_descriptor_t * , int , int * , char * , int , int ); void PREFIX ( co_min ) ( gfc_descriptor_t * , int , int * , char * , int , int ); void PREFIX ( co_sum ) ( gfc_descriptor_t * , int , int * , char * , int ); void PREFIX ( sync_all ) ( int * , char * , int ); void PREFIX ( sync_images ) ( int , int [], int * , char * , int ); void PREFIX ( error_stop_str ) ( const char * , int32_t ) __attribute__ (( noreturn )); void PREFIX ( error_stop ) ( int32_t ) __attribute__ (( noreturn )); void PREFIX ( atomic_define ) ( caf_token_t , size_t , int , void * , int * , int , int ); void PREFIX ( atomic_ref ) ( caf_token_t , size_t , int , void * , int * , int , int ); void PREFIX ( atomic_cas ) ( caf_token_t , size_t , int , void * , void * , void * , int * , int , int ); void PREFIX ( atomic_op ) ( int , caf_token_t , size_t , int , void * , void * , int * , int , int ); void PREFIX ( lock ) ( caf_token_t , size_t , int , int * , int * , char * , int ); void PREFIX ( unlock ) ( caf_token_t , size_t , int , int * , char * , int ); void PREFIX ( event_post ) ( caf_token_t , size_t , int , int * , char * , int ); void PREFIX ( event_wait ) ( caf_token_t , size_t , int , int * , char * , int ); void PREFIX ( event_query ) ( caf_token_t , size_t , int , int * , int * ); #endif /* LIBCAF_H  */","tags":"","loc":"sourcefile/libcaf.h.html","title":"libcaf.h – OpenCoarrays"},{"text":"Source Code /* Auxiliary functions for all of GNU Fortran libcaf implementations. Copyright (c) 2012-2014, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ #include \"libcaf.h\" /* Check whether the array section is contiguous.  There are two possibilities either the stride matches always the extent of that dimension - or if the \"noncontiguous\" dimensions have all extent one (= element access for that dimension); a mixture is possible if the left dimensions are contiguous and the right ones are elements.  */ bool PREFIX ( is_contiguous ) ( gfc_descriptor_t * array ) { int i ; ptrdiff_t dim_extent ; ptrdiff_t extent = 1 ; bool element = false ; for ( i = 0 ; i < GFC_DESCRIPTOR_RANK ( array ); i ++ ) { if ( ! element && array -> dim [ i ]. _stride != extent ) return false ; dim_extent = array -> dim [ i ]. _ubound - array -> dim [ i ]. lower_bound + 1 ; if ( dim_extent <= 0 ) return true ; /* Zero-sized array.  */ else if ( dim_extent == 1 && GFC_DESCRIPTOR_RANK ( array ) == 1 ) element = true ; else if ( element ) return false ; extent *= dim_extent ; } return true ; }","tags":"","loc":"sourcefile/caf_auxiliary.c.html","title":"caf_auxiliary.c – OpenCoarrays"},{"text":"Source Code /* One-sided MPI implementation of Libcaf Copyright (c) 2012-2016, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ /****l* mpi/mpi_caf.c * NAME *   mpi_caf * SYNOPSIS *   This program implements the LIBCAF_MPI transport layer. ****** */ #include <stdio.h> #include <stdlib.h> #include <string.h>        /* For memcpy.  */ #include <stdarg.h>        /* For variadic arguments.  */ #include <alloca.h> #include <unistd.h> #include <mpi.h> #include <pthread.h> #include \"libcaf.h\" /* Define GFC_CAF_CHECK to enable run-time checking.  */ /* #define GFC_CAF_CHECK  1  */ typedef MPI_Win * mpi_caf_token_t ; #define TOKEN(X) ((mpi_caf_token_t) (X)) static void error_stop ( int error ) __attribute__ (( noreturn )); /* Global variables.  */ static int caf_this_image ; static int caf_num_images ; static int caf_is_finalized ; #if MPI_VERSION >= 3 MPI_Info mpi_info_same_size ; #endif // MPI_VERSION /*Sync image part*/ static int * orders ; MPI_Request * handlers ; static int * images_full ; static int * arrived ; /* Pending puts */ #if defined(NONBLOCKING_PUT) && !defined(CAF_MPI_LOCK_UNLOCK) typedef struct win_sync { MPI_Win * win ; int img ; struct win_sync * next ; } win_sync ; static win_sync * last_elem = NULL ; static win_sync * pending_puts = NULL ; #endif caf_static_t * caf_static_list = NULL ; caf_static_t * caf_tot = NULL ; /* Image status variable */ static int * img_status = NULL ; MPI_Win * stat_tok ; /* Active messages variables */ char ** buff_am ; MPI_Status * s_am ; MPI_Request * req_am ; MPI_Datatype * dts ; char * msgbody ; pthread_mutex_t lock_am ; int done_am = 0 ; char err_buffer [ MPI_MAX_ERROR_STRING ]; /* All CAF runtime calls should use this comm instead of MPI_COMM_WORLD for interoperability purposes. */ MPI_Comm CAF_COMM_WORLD ; /* For MPI interoperability, allow external initialization (and thus finalization) of MPI. */ bool caf_owns_mpi = false ; /* Foo function pointers for coreduce */ int ( * foo_int32_t )( void * , void * ); float ( * foo_float )( void * , void * ); double ( * foo_double )( void * , void * ); #define MIN(X, Y) (((X) < (Y)) ? (X) : (Y)) #if defined(NONBLOCKING_PUT) && !defined(CAF_MPI_LOCK_UNLOCK) void explicit_flush () { win_sync * w = pending_puts , * t ; MPI_Win * p ; while ( w != NULL ) { p = w -> win ; MPI_Win_flush ( w -> img , * p ); t = w ; w = w -> next ; free ( t ); } last_elem = NULL ; pending_puts = NULL ; } #endif #ifdef HELPER void helperFunction () { int i = 0 , flag = 0 , msgid = 0 ; int ndim = 0 , position = 0 ; s_am = calloc ( caf_num_images , sizeof ( MPI_Status )); req_am = calloc ( caf_num_images , sizeof ( MPI_Request )); dts = calloc ( caf_num_images , sizeof ( MPI_Datatype )); for ( i = 0 ; i < caf_num_images ; i ++ ) MPI_Irecv ( buff_am [ i ], 1000 , MPI_PACKED , i , 1 , CAF_COMM_WORLD , & req_am [ i ]); while ( 1 ) { pthread_mutex_lock ( & lock_am ); for ( i = 0 ; i < caf_num_images ; i ++ ) { if ( ! caf_is_finalized ) { MPI_Test ( & req_am [ i ], & flag , & s_am [ i ]); if ( flag == 1 ) { position = 0 ; MPI_Unpack ( buff_am [ i ], 1000 , & position , & msgid , 1 , MPI_INT , CAF_COMM_WORLD ); /* msgid=2 was initially assigned to strided transfers, it can be reused */ /* Strided transfers Msgid=2 */ /* You can add you own function */ if ( msgid == 2 ) { msgid = 0 ; position = 0 ; } MPI_Irecv ( buff_am [ i ], 1000 , MPI_PACKED , i , 1 , CAF_COMM_WORLD , & req_am [ i ]); flag = 0 ; } } else { done_am = 1 ; pthread_mutex_unlock ( & lock_am ); return ; } } pthread_mutex_unlock ( & lock_am ); } } #endif /* Keep in sync with single.c.  */ static void caf_runtime_error ( const char * message , ...) { va_list ap ; fprintf ( stderr , \"Fortran runtime error on image %d: \" , caf_this_image ); va_start ( ap , message ); vfprintf ( stderr , message , ap ); va_end ( ap ); fprintf ( stderr , \" \\n \" ); /* FIXME: Shutdown the Fortran RTL to flush the buffer.  PR 43849.  */ /* FIXME: Do some more effort than just to abort.  */ //  MPI_Finalize(); /* Should be unreachable, but to make sure also call exit.  */ exit ( EXIT_FAILURE ); } /* FIXME: CMake chokes on the \"inline\" keyword below.  If we can detect that CMake is  */ /*        being used, we could add something of the form \"#ifdef _CMAKE\" to remove the */ /*        keyword only when building with CMake */ /* inline */ void locking_atomic_op ( MPI_Win win , int * value , int newval , int compare , int image_index , int index ) { # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index - 1 , 0 , win ); # endif // CAF_MPI_LOCK_UNLOCK MPI_Compare_and_swap ( & newval , & compare , value , MPI_INT , image_index - 1 , index * sizeof ( int ), win ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , win ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , win ); # endif // CAF_MPI_LOCK_UNLOCK } void mutex_lock ( MPI_Win win , int image_index , int index , int * stat , int * acquired_lock , char * errmsg , int errmsg_len ) { const char msg [] = \"Already locked\" ; #if MPI_VERSION >= 3 int value = 1 , compare = 0 , newval = caf_this_image , i = 1 ; if ( stat != NULL ) * stat = 0 ; locking_atomic_op ( win , & value , newval , compare , image_index , index ); if ( value == caf_this_image && image_index == caf_this_image ) goto stat_error ; if ( acquired_lock != NULL ) { if ( value == 0 ) * acquired_lock = 1 ; else * acquired_lock = 0 ; return ; } while ( value != 0 ) { locking_atomic_op ( win , & value , newval , compare , image_index , index ); usleep ( caf_this_image * i ); i ++ ; } return ; stat_error : if ( errmsg != NULL ) { memset ( errmsg , ' ' , errmsg_len ); memcpy ( errmsg , msg , MIN ( errmsg_len , strlen ( msg ))); } if ( stat != NULL ) * stat = 99 ; else error_stop ( 99 ); #else // MPI_VERSION #warning Locking for MPI-2 is not implemented printf ( \"Locking for MPI-2 is not supported, please update your MPI implementation \\n \" ); #endif // MPI_VERSION } void mutex_unlock ( MPI_Win win , int image_index , int index , int * stat , char * errmsg , int errmsg_len ) { const char msg [] = \"Variable is not locked\" ; if ( stat != NULL ) * stat = 0 ; #if MPI_VERSION >= 3 int value = 1 , compare = 1 , newval = 0 ; /* locking_atomic_op(win, &value, newval, compare, image_index, index); */ # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index - 1 , 0 , win ); # endif // CAF_MPI_LOCK_UNLOCK MPI_Fetch_and_op ( & newval , & value , MPI_INT , image_index - 1 , index * sizeof ( int ), MPI_REPLACE , win ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , win ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , win ); # endif // CAF_MPI_LOCK_UNLOCK if ( value == 0 ) goto stat_error ; return ; stat_error : if ( errmsg != NULL ) { memset ( errmsg , ' ' , errmsg_len ); memcpy ( errmsg , msg , MIN ( errmsg_len , strlen ( msg ))); } if ( stat != NULL ) * stat = 99 ; else error_stop ( 99 ); #else // MPI_VERSION #warning Locking for MPI-2 is not implemented printf ( \"Locking for MPI-2 is not supported, please update your MPI implementation \\n \" ); #endif // MPI_VERSION } /* Initialize coarray program.  This routine assumes that no other GASNet initialization happened before. */ void #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS _gfortran_caf_init ( int * argc , char *** argv ) #else PREFIX ( init ) ( int * argc , char *** argv ) #endif { if ( caf_num_images == 0 ) { int ierr = 0 , i = 0 , j = 0 ; int is_init = 0 , prior_thread_level = MPI_THREAD_SINGLE ; MPI_Initialized ( & is_init ); if ( is_init ) { MPI_Query_thread ( & prior_thread_level ); } #ifdef HELPER int prov_lev = 0 ; if ( is_init ) { prov_lev = prior_thread_level ; caf_owns_mpi = false ; } else { MPI_Init_thread ( argc , argv , MPI_THREAD_MULTIPLE , & prov_lev ); caf_owns_mpi = true ; } if ( caf_this_image == 0 && MPI_THREAD_MULTIPLE != prov_lev ) caf_runtime_error ( \"MPI_THREAD_MULTIPLE is not supported: %d\" , prov_lev ); #else if ( is_init ) { caf_owns_mpi = false ; } else { MPI_Init ( argc , argv ); caf_owns_mpi = true ; } #endif if ( unlikely (( ierr != MPI_SUCCESS ))) caf_runtime_error ( \"Failure when initializing MPI: %d\" , ierr ); /* Duplicate MPI_COMM_WORLD so that no CAF internal functions use it - this is critical for MPI-interoperability. */ MPI_Comm_dup ( MPI_COMM_WORLD , & CAF_COMM_WORLD ); MPI_Comm_size ( CAF_COMM_WORLD , & caf_num_images ); MPI_Comm_rank ( CAF_COMM_WORLD , & caf_this_image ); caf_this_image ++ ; caf_is_finalized = 0 ; images_full = ( int * ) calloc ( caf_num_images - 1 , sizeof ( int )); for ( i = 0 ; i < caf_num_images ; i ++ ) if ( i + 1 != caf_this_image ) { images_full [ j ] = i + 1 ; j ++ ; } orders = calloc ( caf_num_images , sizeof ( int )); arrived = calloc ( caf_num_images , sizeof ( int )); handlers = malloc ( caf_num_images * sizeof ( MPI_Request )); stat_tok = malloc ( sizeof ( MPI_Win )); #if MPI_VERSION >= 3 MPI_Info_create ( & mpi_info_same_size ); MPI_Info_set ( mpi_info_same_size , \"same_size\" , \"true\" ); /* Setting img_status */ MPI_Win_allocate ( sizeof ( int ), 1 , mpi_info_same_size , CAF_COMM_WORLD , & img_status , stat_tok ); # ifndef CAF_MPI_LOCK_UNLOCK MPI_Win_lock_all ( MPI_MODE_NOCHECK , * stat_tok ); # endif // CAF_MPI_LOCK_UNLOCK #else MPI_Alloc_mem ( sizeof ( int ), MPI_INFO_NULL , & img_status , stat_tok ); MPI_Win_create ( img_status , sizeof ( int ), 1 , MPI_INFO_NULL , CAF_COMM_WORLD , stat_tok ); #endif // MPI_VERSION * img_status = 0 ; } /* MPI_Barrier(CAF_COMM_WORLD); */ } /* Finalize coarray program.   */ void #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS _gfortran_caf_finalize ( void ) #else PREFIX ( finalize ) ( void ) #endif { * img_status = STAT_STOPPED_IMAGE ; /* GFC_STAT_STOPPED_IMAGE = 6000 */ MPI_Win_sync ( * stat_tok ); MPI_Barrier ( CAF_COMM_WORLD ); while ( caf_static_list != NULL ) { caf_static_t * tmp = caf_static_list -> prev ; free ( caf_static_list ); caf_static_list = tmp ; } caf_static_t * tmp_tot = caf_tot , * prev = caf_tot ; MPI_Win * p ; while ( tmp_tot ) { prev = tmp_tot -> prev ; p = tmp_tot -> token ; # ifndef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock_all ( * p ); # endif // CAF_MPI_LOCK_UNLOCK MPI_Win_free ( p ); free ( tmp_tot ); tmp_tot = prev ; } #if MPI_VERSION >= 3 MPI_Info_free ( & mpi_info_same_size ); #endif // MPI_VERSION MPI_Comm_free ( & CAF_COMM_WORLD ); /* Only call Finalize if CAF runtime Initialized MPI. */ if ( caf_owns_mpi ) { MPI_Finalize (); } pthread_mutex_lock ( & lock_am ); caf_is_finalized = 1 ; pthread_mutex_unlock ( & lock_am ); exit ( 0 ); } int PREFIX ( this_image )( int distance __attribute__ (( unused ))) { return caf_this_image ; } int PREFIX ( num_images )( int distance __attribute__ (( unused )), int failed __attribute__ (( unused ))) { return caf_num_images ; } #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS void * _gfortran_caf_register ( size_t size , caf_register_t type , caf_token_t * token , int * stat , char * errmsg , int errmsg_len ) #else void * PREFIX ( register ) ( size_t size , caf_register_t type , caf_token_t * token , int * stat , char * errmsg , int errmsg_len ) #endif { /* int ierr; */ void * mem ; size_t actual_size ; int l_var = 0 , * init_array = NULL ; if ( unlikely ( caf_is_finalized )) goto error ; /* Start GASNET if not already started.  */ if ( caf_num_images == 0 ) #ifdef COMPILER_SUPPORTS_CAF_INTRINSICS _gfortran_caf_init ( NULL , NULL ); #else PREFIX ( init ) ( NULL , NULL ); #endif /* Token contains only a list of pointers.  */ * token = malloc ( sizeof ( MPI_Win )); MPI_Win * p = * token ; if ( type == CAF_REGTYPE_LOCK_STATIC || type == CAF_REGTYPE_LOCK_ALLOC || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC || type == CAF_REGTYPE_EVENT_ALLOC ) { actual_size = size * sizeof ( int ); l_var = 1 ; } else actual_size = size ; #if MPI_VERSION >= 3 MPI_Win_allocate ( actual_size , 1 , mpi_info_same_size , CAF_COMM_WORLD , & mem , * token ); # ifndef CAF_MPI_LOCK_UNLOCK MPI_Win_lock_all ( MPI_MODE_NOCHECK , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION MPI_Alloc_mem ( actual_size , MPI_INFO_NULL , & mem ); MPI_Win_create ( mem , actual_size , 1 , MPI_INFO_NULL , CAF_COMM_WORLD , * token ); #endif // MPI_VERSION p = * token ; if ( l_var ) { init_array = ( int * ) calloc ( size , sizeof ( int )); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , caf_this_image - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK MPI_Put ( init_array , size , MPI_INT , caf_this_image - 1 , 0 , size , MPI_INT , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( caf_this_image - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( caf_this_image - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK free ( init_array ); } PREFIX ( sync_all ) ( NULL , NULL , 0 ); caf_static_t * tmp = malloc ( sizeof ( caf_static_t )); tmp -> prev = caf_tot ; tmp -> token = * token ; caf_tot = tmp ; if ( type == CAF_REGTYPE_COARRAY_STATIC ) { tmp = malloc ( sizeof ( caf_static_t )); tmp -> prev = caf_static_list ; tmp -> token = * token ; caf_static_list = tmp ; } if ( stat ) * stat = 0 ; return mem ; error : { char * msg ; if ( caf_is_finalized ) msg = \"Failed to allocate coarray - there are stopped images\" ; else msg = \"Failed to allocate coarray\" ; if ( stat ) { * stat = caf_is_finalized ? STAT_STOPPED_IMAGE : 1 ; if ( errmsg_len > 0 ) { int len = (( int ) strlen ( msg ) > errmsg_len ) ? errmsg_len : ( int ) strlen ( msg ); memcpy ( errmsg , msg , len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], ' ' , errmsg_len - len ); } } else caf_runtime_error ( msg ); } return NULL ; } void PREFIX ( deregister ) ( caf_token_t * token , int * stat , char * errmsg , int errmsg_len ) { /* int ierr; */ if ( unlikely ( caf_is_finalized )) { const char msg [] = \"Failed to deallocate coarray - \" \"there are stopped images\" ; if ( stat ) { * stat = STAT_STOPPED_IMAGE ; if ( errmsg_len > 0 ) { int len = (( int ) sizeof ( msg ) - 1 > errmsg_len ) ? errmsg_len : ( int ) sizeof ( msg ) - 1 ; memcpy ( errmsg , msg , len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], ' ' , errmsg_len - len ); } return ; } caf_runtime_error ( msg ); } PREFIX ( sync_all ) ( NULL , NULL , 0 ); caf_static_t * tmp = caf_tot , * prev = caf_tot , * next = caf_tot ; MPI_Win * p = * token ; while ( tmp ) { prev = tmp -> prev ; if ( tmp -> token == * token ) { p = * token ; # ifndef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock_all ( * p ); # endif // CAF_MPI_LOCK_UNLOCK MPI_Win_free ( p ); if ( prev ) next -> prev = prev -> prev ; else next -> prev = NULL ; if ( tmp == caf_tot ) caf_tot = prev ; free ( tmp ); break ; } next = tmp ; tmp = prev ; } if ( stat ) * stat = 0 ; /* if (unlikely (ierr = ARMCI_Free ((*token)[caf_this_image-1]))) */ /*   caf_runtime_error (\"ARMCI memory freeing failed: Error code %d\", ierr); */ //gasnet_exit(0); free ( * token ); } void PREFIX ( sync_memory ) ( int * stat , char * errmsg , int errmsg_len ) { #if defined(NONBLOCKING_PUT) && !defined(CAF_MPI_LOCK_UNLOCK) explicit_flush (); #endif } void PREFIX ( sync_all ) ( int * stat , char * errmsg , int errmsg_len ) { int ierr = 0 ; if ( unlikely ( caf_is_finalized )) ierr = STAT_STOPPED_IMAGE ; else { #if defined(NONBLOCKING_PUT) && !defined(CAF_MPI_LOCK_UNLOCK) explicit_flush (); #endif MPI_Barrier ( CAF_COMM_WORLD ); ierr = 0 ; } if ( stat ) * stat = ierr ; if ( ierr ) { char * msg ; if ( caf_is_finalized ) msg = \"SYNC ALL failed - there are stopped images\" ; else msg = \"SYNC ALL failed\" ; if ( errmsg_len > 0 ) { int len = (( int ) strlen ( msg ) > errmsg_len ) ? errmsg_len : ( int ) strlen ( msg ); memcpy ( errmsg , msg , len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], ' ' , errmsg_len - len ); } else caf_runtime_error ( msg ); } } /* token: The token of the array to be written to. */ /* offset: Difference between the coarray base address and the actual data, used for caf(3)[2] = 8 or caf[4]%a(4)%b = 7. */ /* image_index: Index of the coarray (typically remote, though it can also be on this_image). */ /* data: Pointer to the to-be-transferred data. */ /* size: The number of bytes to be transferred. */ /* asynchronous: Return before the data transfer has been complete  */ void selectType ( int size , MPI_Datatype * dt ) { int t_s ; MPI_Type_size ( MPI_INT , & t_s ); if ( t_s == size ) { * dt = MPI_INT ; return ; } MPI_Type_size ( MPI_DOUBLE , & t_s ); if ( t_s == size ) { * dt = MPI_DOUBLE ; return ; } MPI_Type_size ( MPI_COMPLEX , & t_s ); if ( t_s == size ) { * dt = MPI_COMPLEX ; return ; } MPI_Type_size ( MPI_DOUBLE_COMPLEX , & t_s ); if ( t_s == size ) { * dt = MPI_DOUBLE_COMPLEX ; return ; } } void PREFIX ( sendget ) ( caf_token_t token_s , size_t offset_s , int image_index_s , gfc_descriptor_t * dest , caf_vector_t * dst_vector __attribute__ (( unused )), caf_token_t token_g , size_t offset_g , int image_index_g , gfc_descriptor_t * src , caf_vector_t * src_vector __attribute__ (( unused )), int src_kind , int dst_kind , bool mrt ) { int ierr = 0 ; size_t i , size ; int j ; int rank = GFC_DESCRIPTOR_RANK ( dest ); MPI_Win * p_s = token_s , * p_g = token_g ; ptrdiff_t dst_offset = 0 ; ptrdiff_t src_offset = 0 ; void * pad_str = NULL ; size_t src_size = GFC_DESCRIPTOR_SIZE ( src ); size_t dst_size = GFC_DESCRIPTOR_SIZE ( dest ); char * tmp ; size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( size == 0 ) return ; if ( rank == 0 || ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind && GFC_DESCRIPTOR_RANK ( src ) != 0 && ( GFC_DESCRIPTOR_TYPE ( dest ) != BT_CHARACTER || dst_size == src_size ) && PREFIX ( is_contiguous ) ( dest ) && PREFIX ( is_contiguous ) ( src ))) { tmp = ( char * ) calloc ( size , dst_size ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , image_index_g - 1 , 0 , * p_g ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Get ( tmp , dst_size * size , MPI_BYTE , image_index_g - 1 , offset_g , dst_size * size , MPI_BYTE , * p_g ); if ( pad_str ) memcpy (( char * ) tmp + src_size , pad_str , dst_size - src_size ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index_g - 1 , * p_g ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index_g - 1 , * p_g ); # endif // CAF_MPI_LOCK_UNLOCK # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index_s - 1 , 0 , * p_s ); # endif // CAF_MPI_LOCK_UNLOCK if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) ierr = MPI_Put ( tmp , dst_size * size , MPI_BYTE , image_index_s - 1 , offset_s , ( dst_size > src_size ? src_size : dst_size ) * size , MPI_BYTE , * p_s ); if ( pad_str ) ierr = MPI_Put ( pad_str , dst_size - src_size , MPI_BYTE , image_index_s - 1 , offset_s , dst_size - src_size , MPI_BYTE , * p_s ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index_s - 1 , * p_s ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index_s - 1 , * p_s ); # endif // CAF_MPI_LOCK_UNLOCK if ( ierr != 0 ) error_stop ( ierr ); return ; free ( tmp ); } else { tmp = calloc ( 1 , dst_size ); for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / ( extent * stride )) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; } extent = ( dest -> dim [ rank - 1 ]. _ubound - dest -> dim [ rank - 1 ]. lower_bound + 1 ); array_offset_dst += ( i / extent ) * dest -> dim [ rank - 1 ]. _stride ; dst_offset = offset_s + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest ); ptrdiff_t array_offset_sr = 0 ; if ( GFC_DESCRIPTOR_RANK ( src ) != 0 ) { stride = 1 ; extent = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / ( extent * stride )) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; } extent = ( src -> dim [ rank - 1 ]. _ubound - src -> dim [ rank - 1 ]. lower_bound + 1 ); array_offset_sr += ( i / extent ) * src -> dim [ rank - 1 ]. _stride ; array_offset_sr *= GFC_DESCRIPTOR_SIZE ( src ); } src_offset = offset_g + array_offset_sr ; # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , image_index_g - 1 , 0 , * p_g ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Get ( tmp , dst_size , MPI_BYTE , image_index_g - 1 , src_offset , src_size , MPI_BYTE , * p_g ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index_g - 1 , * p_g ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index_g - 1 , * p_g ); # endif // CAF_MPI_LOCK_UNLOCK # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index_s - 1 , 0 , * p_s ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Put ( tmp , GFC_DESCRIPTOR_SIZE ( dest ), MPI_BYTE , image_index_s - 1 , dst_offset , GFC_DESCRIPTOR_SIZE ( dest ), MPI_BYTE , * p_s ); if ( pad_str ) ierr = MPI_Put ( pad_str , dst_size - src_size , MPI_BYTE , image_index_s - 1 , dst_offset , dst_size - src_size , MPI_BYTE , * p_s ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index_s - 1 , * p_s ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index_s - 1 , * p_s ); # endif // CAF_MPI_LOCK_UNLOCK if ( ierr != 0 ) { error_stop ( ierr ); return ; } } free ( tmp ); } } /* Send array data from src to dest on a remote image.  */ /* The last argument means may_require_temporary */ void PREFIX ( send ) ( caf_token_t token , size_t offset , int image_index , gfc_descriptor_t * dest , caf_vector_t * dst_vector __attribute__ (( unused )), gfc_descriptor_t * src , int dst_kind , int src_kind , bool mrt ) { /* FIXME: Implement vector subscripts, type conversion and check whether string-kind conversions are permitted. FIXME: Implement sendget as well.  */ int ierr = 0 ; size_t i , size ; int j ; /* int position, msg = 0;  */ int rank = GFC_DESCRIPTOR_RANK ( dest ); MPI_Win * p = token ; ptrdiff_t dst_offset = 0 ; void * pad_str = NULL ; void * t_buff = NULL ; bool * buff_map = NULL ; size_t src_size = GFC_DESCRIPTOR_SIZE ( src ); size_t dst_size = GFC_DESCRIPTOR_SIZE ( dest ); size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( size == 0 ) return ; if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { pad_str = alloca ( dst_size - src_size ); if ( dst_kind == 1 ) memset ( pad_str , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( i = 0 ; i < ( dst_size - src_size ) / 4 ; i ++ ) (( int32_t * ) pad_str )[ i ] = ( int32_t ) ' ' ; } if ( rank == 0 || ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind && GFC_DESCRIPTOR_RANK ( src ) != 0 && ( GFC_DESCRIPTOR_TYPE ( dest ) != BT_CHARACTER || dst_size == src_size ) && PREFIX ( is_contiguous ) ( dest ) && PREFIX ( is_contiguous ) ( src ))) { if ( caf_this_image == image_index ) { /* The address of source passed by the compiler points on the right * memory location. No offset summation is needed.  */ void * dest_tmp = ( void * ) (( char * ) dest -> base_addr ); // + offset); memmove ( dest_tmp , src -> base_addr , size * dst_size ); return ; } else { #ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index - 1 , 0 , * p ); #endif // CAF_MPI_LOCK_UNLOCK if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) ierr = MPI_Put ( src -> base_addr , ( dst_size > src_size ? src_size : dst_size ) * size , MPI_BYTE , image_index - 1 , offset , ( dst_size > src_size ? src_size : dst_size ) * size , MPI_BYTE , * p ); if ( pad_str ) { size_t newoff = offset + ( dst_size > src_size ? src_size : dst_size ) * size ; ierr = MPI_Put ( pad_str , dst_size - src_size , MPI_BYTE , image_index - 1 , newoff , dst_size - src_size , MPI_BYTE , * p ); } #ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); #elif NONBLOCKING_PUT /* Pending puts init */ if ( pending_puts == NULL ) { pending_puts = calloc ( 1 , sizeof ( win_sync )); pending_puts -> next = NULL ; pending_puts -> win = token ; pending_puts -> img = image_index - 1 ; last_elem = pending_puts ; last_elem -> next = NULL ; } else { last_elem -> next = calloc ( 1 , sizeof ( win_sync )); last_elem = last_elem -> next ; last_elem -> win = token ; last_elem -> img = image_index - 1 ; last_elem -> next = NULL ; } #else MPI_Win_flush ( image_index - 1 , * p ); #endif // CAF_MPI_LOCK_UNLOCK } if ( ierr != 0 ) error_stop ( ierr ); return ; } else { #ifdef STRIDED MPI_Datatype dt_s , dt_d , base_type_src , base_type_dst ; int * arr_bl ; int * arr_dsp_s , * arr_dsp_d ; void * sr = src -> base_addr ; selectType ( GFC_DESCRIPTOR_SIZE ( src ), & base_type_src ); selectType ( GFC_DESCRIPTOR_SIZE ( dest ), & base_type_dst ); if ( rank == 1 ) { MPI_Type_vector ( size , 1 , src -> dim [ 0 ]. _stride , base_type_src , & dt_s ); MPI_Type_vector ( size , 1 , dest -> dim [ 0 ]. _stride , base_type_dst , & dt_d ); } /* else if(rank == 2) */ /*   { */ /*     MPI_Type_vector(size/src->dim[0]._ubound, src->dim[0]._ubound, src->dim[1]._stride, base_type_src, &dt_s); */ /*     MPI_Type_vector(size/dest->dim[0]._ubound, dest->dim[0]._ubound, dest->dim[1]._stride, base_type_dst, &dt_d); */ /*   } */ else { arr_bl = calloc ( size , sizeof ( int )); arr_dsp_s = calloc ( size , sizeof ( int )); arr_dsp_d = calloc ( size , sizeof ( int )); for ( i = 0 ; i < size ; i ++ ) arr_bl [ i ] = 1 ; for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / tot_ext ) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_dst += ( i / tot_ext ) * dest -> dim [ rank - 1 ]. _stride ; arr_dsp_d [ i ] = array_offset_dst ; if ( GFC_DESCRIPTOR_RANK ( src ) != 0 ) { ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; tot_ext = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / tot_ext ) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_sr += ( i / tot_ext ) * src -> dim [ rank - 1 ]. _stride ; arr_dsp_s [ i ] = array_offset_sr ; } else arr_dsp_s [ i ] = 0 ; } MPI_Type_indexed ( size , arr_bl , arr_dsp_s , base_type_src , & dt_s ); MPI_Type_indexed ( size , arr_bl , arr_dsp_d , base_type_dst , & dt_d ); free ( arr_bl ); free ( arr_dsp_s ); free ( arr_dsp_d ); } MPI_Type_commit ( & dt_s ); MPI_Type_commit ( & dt_d ); dst_offset = offset ; # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Put ( sr , 1 , dt_s , image_index - 1 , dst_offset , 1 , dt_d , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK if ( ierr != 0 ) { error_stop ( ierr ); return ; } MPI_Type_free ( & dt_s ); MPI_Type_free ( & dt_d ); /* msg = 2; */ /* MPI_Pack(&msg, 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /* MPI_Pack(&rank, 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /* for(j=0;j<rank;j++) */ /*   { */ /*     MPI_Pack(&(dest->dim[j]._stride), 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /*     MPI_Pack(&(dest->dim[j].lower_bound), 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /*     MPI_Pack(&(dest->dim[j]._ubound), 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /*   } */ /* MPI_Pack(&size, 1, MPI_INT, buff_am[caf_this_image], 1000, &position, CAF_COMM_WORLD); */ /* /\\* non-blocking send *\\/ */ /* MPI_Issend(buff_am[caf_this_image], position, MPI_PACKED, image_index-1, 1, CAF_COMM_WORLD, &reqdt); */ /* msgbody = calloc(size, sizeof(char)); */ /* ptrdiff_t array_offset_sr = 0; */ /* ptrdiff_t stride = 1; */ /* ptrdiff_t extent = 1; */ /* for(i = 0; i < size; i++) */ /*   { */ /*     for (j = 0; j < GFC_DESCRIPTOR_RANK (src)-1; j++) */ /*         { */ /*           array_offset_sr += ((i / (extent*stride)) */ /*                               % (src->dim[j]._ubound */ /*                                  - src->dim[j].lower_bound + 1)) */ /*             * src->dim[j]._stride; */ /*           extent = (src->dim[j]._ubound - src->dim[j].lower_bound + 1); */ /*         stride = src->dim[j]._stride; */ /*         } */ /*     array_offset_sr += (i / extent) * src->dim[rank-1]._stride; */ /*     void *sr = (void *)((char *) src->base_addr */ /*                           + array_offset_sr*GFC_DESCRIPTOR_SIZE (src)); */ /*     memmove (msgbody+p_mb, sr, GFC_DESCRIPTOR_SIZE (src)); */ /*     p_mb += GFC_DESCRIPTOR_SIZE (src); */ /*   } */ /* MPI_Wait(&reqdt, &stadt); */ /* MPI_Ssend(msgbody, size, MPI_BYTE, image_index-1, 1, CAF_COMM_WORLD); */ /* free(msgbody); */ #else if ( caf_this_image == image_index && mrt ) { t_buff = calloc ( size , GFC_DESCRIPTOR_SIZE ( dest )); buff_map = calloc ( size , sizeof ( bool )); } # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image_index - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / tot_ext ) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_dst += ( i / tot_ext ) * dest -> dim [ rank - 1 ]. _stride ; dst_offset = offset + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest ); void * sr ; if ( GFC_DESCRIPTOR_RANK ( src ) != 0 ) { ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; tot_ext = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / tot_ext ) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_sr += ( i / tot_ext ) * src -> dim [ rank - 1 ]. _stride ; sr = ( void * )(( char * ) src -> base_addr + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src )); } else sr = src -> base_addr ; if ( caf_this_image == image_index ) { if ( ! mrt ) memmove ( dest -> base_addr + dst_offset , sr , GFC_DESCRIPTOR_SIZE ( src )); else { memmove ( t_buff + i * GFC_DESCRIPTOR_SIZE ( src ), sr , GFC_DESCRIPTOR_SIZE ( src )); buff_map [ i ] = true ; } } else { ierr = MPI_Put ( sr , GFC_DESCRIPTOR_SIZE ( dest ), MPI_BYTE , image_index - 1 , dst_offset , GFC_DESCRIPTOR_SIZE ( dest ), MPI_BYTE , * p ); if ( pad_str ) ierr = MPI_Put ( pad_str , dst_size - src_size , MPI_BYTE , image_index - 1 , dst_offset , dst_size - src_size , MPI_BYTE , * p ); } if ( ierr != 0 ) { error_stop ( ierr ); return ; } } if ( caf_this_image == image_index && mrt ) { for ( i = 0 ; i < size ; i ++ ) { if ( buff_map [ i ]) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / tot_ext ) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; tot_ext *= extent ; } //extent = (dest->dim[rank-1]._ubound - dest->dim[rank-1].lower_bound + 1); array_offset_dst += ( i / tot_ext ) * dest -> dim [ rank - 1 ]. _stride ; dst_offset = offset + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest ); memmove ( src -> base_addr + dst_offset , t_buff + i * GFC_DESCRIPTOR_SIZE ( src ), GFC_DESCRIPTOR_SIZE ( src )); } } free ( t_buff ); free ( buff_map ); } # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK #endif } } /* Get array data from a remote src to a local dest.  */ void PREFIX ( get ) ( caf_token_t token , size_t offset , int image_index , gfc_descriptor_t * src , caf_vector_t * src_vector __attribute__ (( unused )), gfc_descriptor_t * dest , int src_kind , int dst_kind , bool mrt ) { size_t i , size ; int ierr = 0 ; int j ; MPI_Win * p = token ; int rank = GFC_DESCRIPTOR_RANK ( src ); size_t src_size = GFC_DESCRIPTOR_SIZE ( src ); size_t dst_size = GFC_DESCRIPTOR_SIZE ( dest ); void * t_buff = NULL ; bool * buff_map = NULL ; void * pad_str = NULL ; /* size_t sr_off = 0;  */ size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( size == 0 ) return ; if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { pad_str = alloca ( dst_size - src_size ); if ( dst_kind == 1 ) memset ( pad_str , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( i = 0 ; i < ( dst_size - src_size ) / 4 ; i ++ ) (( int32_t * ) pad_str )[ i ] = ( int32_t ) ' ' ; } if ( rank == 0 || ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind && ( GFC_DESCRIPTOR_TYPE ( dest ) != BT_CHARACTER || dst_size == src_size ) && PREFIX ( is_contiguous ) ( dest ) && PREFIX ( is_contiguous ) ( src ))) { /* FIXME: Handle image_index == this_image().  */ /*  if (async == false) */ if ( caf_this_image == image_index ) { /* The address of source passed by the compiler points on the right * memory location. No offset summation is needed.  */ void * src_tmp = ( void * ) (( char * ) src -> base_addr ); // + offset); memmove ( dest -> base_addr , src_tmp , size * src_size ); return ; } else { # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , image_index - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Get ( dest -> base_addr , dst_size * size , MPI_BYTE , image_index - 1 , offset , dst_size * size , MPI_BYTE , * p ); if ( pad_str ) memcpy (( char * ) dest -> base_addr + src_size , pad_str , dst_size - src_size ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK } if ( ierr != 0 ) error_stop ( ierr ); return ; } #ifdef STRIDED MPI_Datatype dt_s , dt_d , base_type_src , base_type_dst ; int * arr_bl ; int * arr_dsp_s , * arr_dsp_d ; void * dst = dest -> base_addr ; selectType ( GFC_DESCRIPTOR_SIZE ( src ), & base_type_src ); selectType ( GFC_DESCRIPTOR_SIZE ( dest ), & base_type_dst ); if ( rank == 1 ) { MPI_Type_vector ( size , 1 , src -> dim [ 0 ]. _stride , base_type_src , & dt_s ); MPI_Type_vector ( size , 1 , dest -> dim [ 0 ]. _stride , base_type_dst , & dt_d ); } /* else if(rank == 2) */ /*   { */ /*     MPI_Type_vector(size/src->dim[0]._ubound, src->dim[0]._ubound, src->dim[1]._stride, base_type_src, &dt_s); */ /*     MPI_Type_vector(size/dest->dim[0]._ubound, dest->dim[0]._ubound, dest->dim[1]._stride, base_type_dst, &dt_d); */ /*   } */ else { arr_bl = calloc ( size , sizeof ( int )); arr_dsp_s = calloc ( size , sizeof ( int )); arr_dsp_d = calloc ( size , sizeof ( int )); for ( i = 0 ; i < size ; i ++ ) arr_bl [ i ] = 1 ; for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / tot_ext ) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; tot_ext *= extent ; } //extent = (dest->dim[rank-1]._ubound - dest->dim[rank-1].lower_bound + 1); array_offset_dst += ( i / tot_ext ) * dest -> dim [ rank - 1 ]. _stride ; arr_dsp_d [ i ] = array_offset_dst ; ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; tot_ext = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / tot_ext ) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; tot_ext *= extent ; } //extent = (src->dim[rank-1]._ubound - src->dim[rank-1].lower_bound + 1); array_offset_sr += ( i / tot_ext ) * src -> dim [ rank - 1 ]. _stride ; arr_dsp_s [ i ] = array_offset_sr ; } MPI_Type_indexed ( size , arr_bl , arr_dsp_s , base_type_src , & dt_s ); MPI_Type_indexed ( size , arr_bl , arr_dsp_d , base_type_dst , & dt_d ); free ( arr_bl ); free ( arr_dsp_s ); free ( arr_dsp_d ); } MPI_Type_commit ( & dt_s ); MPI_Type_commit ( & dt_d ); //sr_off = offset; # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , image_index - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Get ( dst , 1 , dt_d , image_index - 1 , offset , 1 , dt_s , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK if ( ierr != 0 ) error_stop ( ierr ); MPI_Type_free ( & dt_s ); MPI_Type_free ( & dt_d ); #else if ( caf_this_image == image_index && mrt ) { t_buff = calloc ( size , GFC_DESCRIPTOR_SIZE ( dest )); buff_map = calloc ( size , sizeof ( bool )); } # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , image_index - 1 , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / tot_ext ) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_dst += ( i / tot_ext ) * dest -> dim [ rank - 1 ]. _stride ; ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; tot_ext = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / tot_ext ) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; tot_ext *= extent ; } array_offset_sr += ( i / tot_ext ) * src -> dim [ rank - 1 ]. _stride ; size_t sr_off = offset + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src ); void * dst = ( void * ) (( char * ) dest -> base_addr + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest )); /* FIXME: Handle image_index == this_image().  */ /*  if (async == false) */ if ( caf_this_image == image_index ) { /* Is this needed? */ if ( ! mrt ) memmove ( dst , src -> base_addr + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src ), GFC_DESCRIPTOR_SIZE ( src )); else { memmove ( t_buff + i * GFC_DESCRIPTOR_SIZE ( dest ), dst , GFC_DESCRIPTOR_SIZE ( dest )); buff_map [ i ] = true ; } } else { ierr = MPI_Get ( dst , GFC_DESCRIPTOR_SIZE ( dest ), MPI_BYTE , image_index - 1 , sr_off , GFC_DESCRIPTOR_SIZE ( src ), MPI_BYTE , * p ); if ( pad_str ) memcpy (( char * ) dst + src_size , pad_str , dst_size - src_size ); } if ( ierr != 0 ) error_stop ( ierr ); } if ( caf_this_image == image_index && mrt ) { for ( i = 0 ; i < size ; i ++ ) { if ( buff_map [ i ]) { ptrdiff_t array_offset_sr = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; ptrdiff_t tot_ext = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / tot_ext ) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; tot_ext *= extent ; } //extent = (src->dim[rank-1]._ubound - src->dim[rank-1].lower_bound + 1); array_offset_sr += ( i / tot_ext ) * src -> dim [ rank - 1 ]. _stride ; size_t sr_off = offset + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src ); memmove ( dest -> base_addr + sr_off , t_buff + i * GFC_DESCRIPTOR_SIZE ( src ), GFC_DESCRIPTOR_SIZE ( src )); } } free ( t_buff ); free ( buff_map ); } # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image_index - 1 , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image_index - 1 , * p ); # endif // CAF_MPI_LOCK_UNLOCK #endif } /* SYNC IMAGES. Note: SYNC IMAGES(*) is passed as count == -1 while SYNC IMAGES([]) has count == 0. Note further that SYNC IMAGES(*) is not equivalent to SYNC ALL. */ void PREFIX ( sync_images ) ( int count , int images [], int * stat , char * errmsg , int errmsg_len ) { int ierr = 0 , i = 0 , remote_stat = 0 ; int dup = 0 , j = 0 ; MPI_Status s ; if ( count == 0 || ( count == 1 && images [ 0 ] == caf_this_image )) { if ( stat ) * stat = 0 ; return ; } /* halt execution if sync images contains duplicate image numbers */ for ( i = 0 ; i < count ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( images [ i ] == images [ j ]) { ierr = STAT_DUP_SYNC_IMAGES ; if ( stat ) * stat = ierr ; goto sync_images_err_chk ; } #ifdef GFC_CAF_CHECK { for ( i = 0 ; i < count ; i ++ ) if ( images [ i ] < 1 || images [ i ] > caf_num_images ) { fprintf ( stderr , \"COARRAY ERROR: Invalid image index %d to SYNC \" \"IMAGES\" , images [ i ]); error_stop ( 1 ); } } #endif if ( unlikely ( caf_is_finalized )) ierr = STAT_STOPPED_IMAGE ; else { if ( count == - 1 ) { for ( i = 0 ; i < caf_num_images - 1 ; i ++ ) orders [ images_full [ i ] - 1 ] ++ ; count = caf_num_images - 1 ; images = images_full ; } else { for ( i = 0 ; i < count ; i ++ ) orders [ images [ i ] - 1 ] ++ ; } #if defined(NONBLOCKING_PUT) && !defined(CAF_MPI_LOCK_UNLOCK) explicit_flush (); #endif for ( i = 0 ; i < count ; i ++ ) ierr = MPI_Irecv ( & arrived [ images [ i ] - 1 ], 1 , MPI_INT , images [ i ] - 1 , 0 , CAF_COMM_WORLD , & handlers [ images [ i ] - 1 ]); for ( i = 0 ; i < count ; i ++ ) { # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_SHARED , images [ i ] - 1 , 0 , * stat_tok ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Get ( & remote_stat , 1 , MPI_INT , images [ i ] - 1 , 0 , 1 , MPI_INT , * stat_tok ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( images [ i ] - 1 , * stat_tok ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( images [ i ] - 1 , * stat_tok ); # endif // CAF_MPI_LOCK_UNLOCK if ( remote_stat != 0 ) { ierr = STAT_STOPPED_IMAGE ; if ( stat != NULL ) * stat = ierr ; goto sync_images_err_chk ; } } for ( i = 0 ; i < count ; i ++ ) ierr = MPI_Send ( & caf_this_image , 1 , MPI_INT , images [ i ] - 1 , 0 , CAF_COMM_WORLD ); for ( i = 0 ; i < count ; i ++ ) ierr = MPI_Wait ( & handlers [ images [ i ] - 1 ], & s ); memset ( arrived , 0 , sizeof ( int ) * caf_num_images ); } if ( stat ) * stat = ierr ; sync_images_err_chk : if ( ierr && stat == NULL ) { char * msg ; if ( caf_is_finalized ) msg = \"SYNC IMAGES failed - there are stopped images\" ; else msg = \"SYNC IMAGES failed\" ; if ( errmsg_len > 0 ) { int len = (( int ) strlen ( msg ) > errmsg_len ) ? errmsg_len : ( int ) strlen ( msg ); memcpy ( errmsg , msg , len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], ' ' , errmsg_len - len ); } else caf_runtime_error ( msg ); } } #define GEN_REDUCTION(name, datatype, operator) \\ static void \\ name (datatype *invec, datatype *inoutvec, int *len, \\ MPI_Datatype *datatype __attribute__ ((unused))) \\ { \\ int i; \\ for (i = 0; i < len; i++) \\ operator; \\ } #define FOOFUNC(TYPE) foo_ ## TYPE #define GEN_COREDUCE(name, dt)\t\t\t\\ static void \\ name (void *invec, void *inoutvec, int *len, \\ MPI_Datatype *datatype)\t\t     \\ { \\ int i;\t     \\ for(i=0;i<*len;i++)\t\t\t\t\\ {\t\t\t\t\t\t\t\t\\ *((dt*)inoutvec) = (dt)(FOOFUNC(dt)((dt *)invec,(dt *)inoutvec));\t\\ invec+=sizeof(dt); inoutvec+=sizeof(dt);\t\\ } \\ } GEN_COREDUCE ( redux_int32 , int32_t ) GEN_COREDUCE ( redux_real32 , float ) GEN_COREDUCE ( redux_real64 , double ) #ifndef MPI_INTEGER1 GEN_REDUCTION ( do_sum_int1 , int8_t , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_int1 , int8_t , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_int1 , int8_t , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) #endif #ifndef MPI_INTEGER2 GEN_REDUCTION ( do_sum_int1 , int16_t , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_int1 , int16_t , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_int1 , int16_t , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) #endif #if defined(MPI_INTEGER16) && defined(GFC_INTEGER_16) GEN_REDUCTION ( do_sum_int1 , GFC_INTEGER_16 , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_int1 , GFC_INTEGER_16 , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_int1 , GFC_INTEGER_16 , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) #endif #if defined(GFC_DTYPE_REAL_10) \\ || (!defined(GFC_DTYPE_REAL_10)  && defined(GFC_DTYPE_REAL_16)) GEN_REDUCTION ( do_sum_real10 , long double , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_real10 , long double , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_real10 , long double , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_sum_complex10 , _Complex long double , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_complex10 , _Complex long double , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_complex10 , _Complex long double , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) #endif #if defined(GFC_DTYPE_REAL_10) && defined(GFC_DTYPE_REAL_16) GEN_REDUCTION ( do_sum_real10 , __float128 , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_min_real10 , __float128 , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_real10 , __float128 , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_sum_complex10 , _Complex __float128 , inoutvec [ i ] += invec [ i ]) GEN_REDUCTION ( do_mincomplexl10 , _Complex __float128 , inoutvec [ i ] = invec [ i ] >= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) GEN_REDUCTION ( do_max_complex10 , _Complex __float128 , inoutvec [ i ] = invec [ i ] <= inoutvec [ i ] ? inoutvec [ i ] : invec [ i ]) #endif #undef GEN_REDUCTION static MPI_Datatype get_MPI_datatype ( gfc_descriptor_t * desc ) { /* FIXME: Better check whether the sizes are okay and supported; MPI3 adds more types, e.g. MPI_INTEGER1.  */ switch ( GFC_DTYPE_TYPE_SIZE ( desc )) { #ifdef MPI_INTEGER1 case GFC_DTYPE_INTEGER_1 : return MPI_INTEGER1 ; #endif #ifdef MPI_INTEGER2 case GFC_DTYPE_INTEGER_2 : return MPI_INTEGER2 ; #endif case GFC_DTYPE_INTEGER_4 : #ifdef MPI_INTEGER4 return MPI_INTEGER4 ; #else return MPI_INTEGER ; #endif #ifdef MPI_INTEGER8 case GFC_DTYPE_INTEGER_8 : return MPI_INTEGER8 ; #endif #if defined(MPI_INTEGER16) && defined(GFC_DTYPE_INTEGER_16) case GFC_DTYPE_INTEGER_16 : return MPI_INTEGER16 ; #endif case GFC_DTYPE_LOGICAL_4 : return MPI_INT ; case GFC_DTYPE_REAL_4 : #ifdef MPI_REAL4 return MPI_REAL4 ; #else return MPI_REAL ; #endif case GFC_DTYPE_REAL_8 : #ifdef MPI_REAL8 return MPI_REAL8 ; #else return MPI_DOUBLE_PRECISION ; #endif /* Note that we cannot use REAL_16 as we do not know whether it matches REAL(10) or REAL(16), which have both the same bitsize and only make use of less bits.  */ case GFC_DTYPE_COMPLEX_4 : return MPI_COMPLEX ; case GFC_DTYPE_COMPLEX_8 : return MPI_DOUBLE_COMPLEX ; } /* gfortran passes character string arguments with a GFC_DTYPE_TYPE_SIZE == GFC_TYPE_CHARACTER + 64*strlen */ if ( ( GFC_DTYPE_TYPE_SIZE ( desc ) - GFC_DTYPE_CHARACTER ) % 64 == 0 ) return MPI_CHARACTER ; caf_runtime_error ( \"Unsupported data type in collective: %ld \\n \" , GFC_DTYPE_TYPE_SIZE ( desc )); return 0 ; } static void co_reduce_1 ( MPI_Op op , gfc_descriptor_t * source , int result_image , int * stat , char * errmsg , int src_len __attribute__ (( unused )), int errmsg_len ) { size_t i , size ; int j , ierr ; int rank = GFC_DESCRIPTOR_RANK ( source ); MPI_Datatype datatype = get_MPI_datatype ( source ); size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = source -> dim [ j ]. _ubound - source -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( rank == 0 || PREFIX ( is_contiguous ) ( source )) { if ( result_image == 0 ) ierr = MPI_Allreduce ( MPI_IN_PLACE , source -> base_addr , size , datatype , op , CAF_COMM_WORLD ); else if ( result_image == caf_this_image ) ierr = MPI_Reduce ( MPI_IN_PLACE , source -> base_addr , size , datatype , op , result_image - 1 , CAF_COMM_WORLD ); else ierr = MPI_Reduce ( source -> base_addr , NULL , size , datatype , op , result_image - 1 , CAF_COMM_WORLD ); if ( ierr ) goto error ; return ; } for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_sr = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( source ) - 1 ; j ++ ) { array_offset_sr += (( i / ( extent * stride )) % ( source -> dim [ j ]. _ubound - source -> dim [ j ]. lower_bound + 1 )) * source -> dim [ j ]. _stride ; extent = ( source -> dim [ j ]. _ubound - source -> dim [ j ]. lower_bound + 1 ); stride = source -> dim [ j ]. _stride ; } array_offset_sr += ( i / extent ) * source -> dim [ rank - 1 ]. _stride ; void * sr = ( void * )(( char * ) source -> base_addr + array_offset_sr * GFC_DESCRIPTOR_SIZE ( source )); if ( result_image == 0 ) ierr = MPI_Allreduce ( MPI_IN_PLACE , sr , 1 , datatype , op , CAF_COMM_WORLD ); else if ( result_image == caf_this_image ) ierr = MPI_Reduce ( MPI_IN_PLACE , sr , 1 , datatype , op , result_image - 1 , CAF_COMM_WORLD ); else ierr = MPI_Reduce ( sr , NULL , 1 , datatype , op , result_image - 1 , CAF_COMM_WORLD ); if ( ierr ) goto error ; } if ( stat ) * stat = 0 ; return ; error : /* FIXME: Put this in an extra function and use it elsewhere.  */ if ( stat ) { * stat = ierr ; if ( ! errmsg ) return ; } int len = sizeof ( err_buffer ); MPI_Error_string ( ierr , err_buffer , & len ); if ( ! stat ) { err_buffer [ len == sizeof ( err_buffer ) ? len - 1 : len ] = '\\0' ; caf_runtime_error ( \"CO_SUM failed with %s \\n \" , err_buffer ); } memcpy ( errmsg , err_buffer , errmsg_len > len ? len : errmsg_len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], '\\0' , errmsg_len - len ); } void PREFIX ( co_broadcast ) ( gfc_descriptor_t * a , int source_image , int * stat , char * errmsg , int errmsg_len ) { size_t i , size ; int j , ierr ; int rank = GFC_DESCRIPTOR_RANK ( a ); MPI_Datatype datatype = get_MPI_datatype ( a ); size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = a -> dim [ j ]. _ubound - a -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( rank == 0 ) { if ( datatype != MPI_CHARACTER ) ierr = MPI_Bcast ( a -> base_addr , size , datatype , source_image - 1 , CAF_COMM_WORLD ); else { int a_length ; if ( caf_this_image == source_image ) a_length = strlen ( a -> base_addr ); /* Broadcast the string lenth */ ierr = MPI_Bcast ( & a_length , 1 , MPI_INT , source_image - 1 , CAF_COMM_WORLD ); if ( ierr ) goto error ; /* Broadcast the string itself */ ierr = MPI_Bcast ( a -> base_addr , a_length , datatype , source_image - 1 , CAF_COMM_WORLD ); } if ( ierr ) goto error ; return ; } else if ( datatype == MPI_CHARACTER ) /* rank !=0  */ { caf_runtime_error ( \"Co_broadcast of character arrays not yet supported \\n \" ); } for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_sr = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( a ) - 1 ; j ++ ) { array_offset_sr += (( i / ( extent * stride )) % ( a -> dim [ j ]. _ubound - a -> dim [ j ]. lower_bound + 1 )) * a -> dim [ j ]. _stride ; extent = ( a -> dim [ j ]. _ubound - a -> dim [ j ]. lower_bound + 1 ); stride = a -> dim [ j ]. _stride ; } array_offset_sr += ( i / extent ) * a -> dim [ rank - 1 ]. _stride ; void * sr = ( void * )(( char * ) a -> base_addr + array_offset_sr * GFC_DESCRIPTOR_SIZE ( a )); ierr = MPI_Bcast ( sr , 1 , datatype , source_image - 1 , CAF_COMM_WORLD ); if ( ierr ) goto error ; } return ; error : /* FIXME: Put this in an extra function and use it elsewhere.  */ if ( stat ) { * stat = ierr ; if ( ! errmsg ) return ; } int len = sizeof ( err_buffer ); MPI_Error_string ( ierr , err_buffer , & len ); if ( ! stat ) { err_buffer [ len == sizeof ( err_buffer ) ? len - 1 : len ] = '\\0' ; caf_runtime_error ( \"CO_SUM failed with %s \\n \" , err_buffer ); } memcpy ( errmsg , err_buffer , errmsg_len > len ? len : errmsg_len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], '\\0' , errmsg_len - len ); } void PREFIX ( co_reduce ) ( gfc_descriptor_t * a , void * ( * opr ) ( void * , void * ), int opr_flags , int result_image , int * stat , char * errmsg , int a_len , int errmsg_len ) { MPI_Op op ; if ( GFC_DESCRIPTOR_TYPE ( a ) == BT_INTEGER ) { foo_int32_t = ( typeof ( foo_int32_t )) opr ; MPI_Op_create ( redux_int32 , 1 , & op ); } else if ( GFC_DESCRIPTOR_TYPE ( a ) == BT_REAL ) { if ( GFC_DESCRIPTOR_SIZE ( a ) == sizeof ( float )) { foo_float = ( typeof ( foo_float )) opr ; MPI_Op_create ( redux_real32 , 1 , & op ); } else { foo_double = ( typeof ( foo_double )) opr ; MPI_Op_create ( redux_real64 , 1 , & op ); } } else if ( GFC_DESCRIPTOR_TYPE ( a ) == BT_LOGICAL ) { foo_int32_t = ( typeof ( foo_int32_t )) opr ; MPI_Op_create ( redux_int32 , 1 , & op ); } else { caf_runtime_error ( \"Data type not yet supported for co_reduce \\n \" ); } co_reduce_1 ( op , a , result_image , stat , errmsg , 0 , errmsg_len ); } void PREFIX ( co_sum ) ( gfc_descriptor_t * a , int result_image , int * stat , char * errmsg , int errmsg_len ) { co_reduce_1 ( MPI_SUM , a , result_image , stat , errmsg , 0 , errmsg_len ); } void PREFIX ( co_min ) ( gfc_descriptor_t * a , int result_image , int * stat , char * errmsg , int src_len , int errmsg_len ) { co_reduce_1 ( MPI_MIN , a , result_image , stat , errmsg , src_len , errmsg_len ); } void PREFIX ( co_max ) ( gfc_descriptor_t * a , int result_image , int * stat , char * errmsg , int src_len , int errmsg_len ) { co_reduce_1 ( MPI_MAX , a , result_image , stat , errmsg , src_len , errmsg_len ); } /* Locking functions */ void PREFIX ( lock ) ( caf_token_t token , size_t index , int image_index , int * acquired_lock , int * stat , char * errmsg , int errmsg_len ) { int dest_img ; MPI_Win * p = token ; if ( image_index == 0 ) dest_img = caf_this_image ; else dest_img = image_index ; mutex_lock ( * p , dest_img , index , stat , acquired_lock , errmsg , errmsg_len ); } void PREFIX ( unlock ) ( caf_token_t token , size_t index , int image_index , int * stat , char * errmsg , int errmsg_len ) { int dest_img ; MPI_Win * p = token ; if ( image_index == 0 ) dest_img = caf_this_image ; else dest_img = image_index ; mutex_unlock ( * p , dest_img , index , stat , errmsg , errmsg_len ); } /* Atomics operations */ void PREFIX ( atomic_define ) ( caf_token_t token , size_t offset , int image_index , void * value , int * stat , int type __attribute__ (( unused )), int kind ) { MPI_Win * p = token ; MPI_Datatype dt ; int ierr = 0 ; int image ; if ( image_index != 0 ) image = image_index - 1 ; else image = caf_this_image - 1 ; selectType ( kind , & dt ); #if MPI_VERSION >= 3 # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Accumulate ( value , 1 , dt , image , offset , 1 , dt , MPI_REPLACE , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); ierr = MPI_Put ( value , 1 , dt , image , offset , 1 , dt , * p ); MPI_Win_unlock ( image , * p ); #endif // MPI_VERSION if ( stat ) * stat = ierr ; else if ( ierr != 0 ) error_stop ( ierr ); return ; } void PREFIX ( atomic_ref ) ( caf_token_t token , size_t offset , int image_index , void * value , int * stat , int type __attribute__ (( unused )), int kind ) { MPI_Win * p = token ; MPI_Datatype dt ; int ierr = 0 ; int image ; if ( image_index != 0 ) image = image_index - 1 ; else image = caf_this_image - 1 ; selectType ( kind , & dt ); #if MPI_VERSION >= 3 # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Fetch_and_op ( NULL , value , dt , image , offset , MPI_NO_OP , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); ierr = MPI_Get ( value , 1 , dt , image , offset , 1 , dt , * p ); MPI_Win_unlock ( image , * p ); #endif // MPI_VERSION if ( stat ) * stat = ierr ; else if ( ierr != 0 ) error_stop ( ierr ); return ; } void PREFIX ( atomic_cas ) ( caf_token_t token , size_t offset , int image_index , void * old , void * compare , void * new_val , int * stat , int type __attribute__ (( unused )), int kind ) { MPI_Win * p = token ; MPI_Datatype dt ; int ierr = 0 ; int image ; if ( image_index != 0 ) image = image_index - 1 ; else image = caf_this_image - 1 ; selectType ( kind , & dt ); #if MPI_VERSION >= 3 # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Compare_and_swap ( new_val , compare , old , dt , image , offset , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION #warning atomic_cas for MPI-2 is not yet implemented printf ( \"We apologize but atomic_cas for MPI-2 is not yet implemented \\n \" ); ierr = 1 ; #endif // MPI_VERSION if ( stat ) * stat = ierr ; else if ( ierr != 0 ) error_stop ( ierr ); return ; } void PREFIX ( atomic_op ) ( int op , caf_token_t token , size_t offset , int image_index , void * value , void * old , int * stat , int type __attribute__ (( unused )), int kind ) { int ierr = 0 ; MPI_Datatype dt ; MPI_Win * p = token ; int image ; #if MPI_VERSION >= 3 old = malloc ( kind ); if ( image_index != 0 ) image = image_index - 1 ; else image = caf_this_image - 1 ; selectType ( kind , & dt ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK /* Atomic_add */ switch ( op ) { case 1 : ierr = MPI_Fetch_and_op ( value , old , dt , image , offset , MPI_SUM , * p ); break ; case 2 : ierr = MPI_Fetch_and_op ( value , old , dt , image , offset , MPI_BAND , * p ); break ; case 4 : ierr = MPI_Fetch_and_op ( value , old , dt , image , offset , MPI_BOR , * p ); break ; case 5 : ierr = MPI_Fetch_and_op ( value , old , dt , image , offset , MPI_BXOR , * p ); break ; default : printf ( \"We apologize but the atomic operation requested for MPI is not yet implemented \\n \" ); break ; } # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK free ( old ); #else // MPI_VERSION #warning atomic_op for MPI is not yet implemented printf ( \"We apologize but atomic_op for MPI is not yet implemented \\n \" ); #endif // MPI_VERSION if ( stat ) * stat = ierr ; else if ( ierr != 0 ) error_stop ( ierr ); return ; } /* Events */ void PREFIX ( event_post ) ( caf_token_t token , size_t index , int image_index , int * stat , char * errmsg , int errmsg_len ) { int image , value = 1 , ierr = 0 ; MPI_Win * p = token ; const char msg [] = \"Error on event post\" ; if ( image_index == 0 ) image = caf_this_image - 1 ; else image = image_index - 1 ; if ( stat != NULL ) * stat = 0 ; #if MPI_VERSION >= 3 # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Accumulate ( & value , 1 , MPI_INT , image , index * sizeof ( int ), 1 , MPI_INT , MPI_SUM , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION #warning Events for MPI-2 are not implemented printf ( \"Events for MPI-2 are not supported, please update your MPI implementation \\n \" ); #endif // MPI_VERSION if ( ierr != MPI_SUCCESS ) { if ( stat != NULL ) * stat = ierr ; if ( errmsg != NULL ) { memset ( errmsg , ' ' , errmsg_len ); memcpy ( errmsg , msg , MIN ( errmsg_len , strlen ( msg ))); } } } void PREFIX ( event_wait ) ( caf_token_t token , size_t index , int until_count , int * stat , char * errmsg , int errmsg_len ) { int ierr = 0 , count = 0 , i , image = caf_this_image - 1 ; int * var = NULL , flag , old = 0 ; int newval = 0 ; const int spin_loop_max = 20000 ; MPI_Win * p = token ; const char msg [] = \"Error on event wait\" ; if ( stat != NULL ) * stat = 0 ; MPI_Win_get_attr ( * p , MPI_WIN_BASE , & var , & flag ); for ( i = 0 ; i < spin_loop_max ; ++ i ) { MPI_Win_sync ( * p ); count = var [ index ]; if ( count >= until_count ) break ; } i = 1 ; while ( count < until_count ) /* for(i = 0; i < spin_loop_max; ++i) */ { MPI_Win_sync ( * p ); count = var [ index ]; /* if(count >= until_count) */ /*   break; */ usleep ( 5 * i ); i ++ ; } newval = - until_count ; # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Fetch_and_op ( & newval , & old , MPI_INT , image , index * sizeof ( int ), MPI_SUM , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK if ( ierr != MPI_SUCCESS ) { if ( stat != NULL ) * stat = ierr ; if ( errmsg != NULL ) { memset ( errmsg , ' ' , errmsg_len ); memcpy ( errmsg , msg , MIN ( errmsg_len , strlen ( msg ))); } } } void PREFIX ( event_query ) ( caf_token_t token , size_t index , int image_index , int * count , int * stat ) { int image , ierr = 0 ; MPI_Win * p = token ; if ( image_index == 0 ) image = caf_this_image - 1 ; else image = image_index - 1 ; if ( stat != NULL ) * stat = 0 ; #if MPI_VERSION >= 3 # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_lock ( MPI_LOCK_EXCLUSIVE , image , 0 , * p ); # endif // CAF_MPI_LOCK_UNLOCK ierr = MPI_Fetch_and_op ( NULL , count , MPI_INT , image , index * sizeof ( int ), MPI_NO_OP , * p ); # ifdef CAF_MPI_LOCK_UNLOCK MPI_Win_unlock ( image , * p ); # else // CAF_MPI_LOCK_UNLOCK MPI_Win_flush ( image , * p ); # endif // CAF_MPI_LOCK_UNLOCK #else // MPI_VERSION #warning Events for MPI-2 are not implemented printf ( \"Events for MPI-2 are not supported, please update your MPI implementation \\n \" ); #endif // MPI_VERSION if ( ierr != MPI_SUCCESS && stat != NULL ) * stat = ierr ; } /* ERROR STOP the other images.  */ static void error_stop ( int error ) { /* FIXME: Shutdown the Fortran RTL to flush the buffer.  PR 43849.  */ /* FIXME: Do some more effort than just gasnet_exit().  */ MPI_Abort ( CAF_COMM_WORLD , error ); /* Should be unreachable, but to make sure also call exit.  */ exit ( error ); } /* STOP function for integer arguments.  */ void PREFIX ( stop_numeric ) ( int32_t stop_code ) { fprintf ( stderr , \"STOP %d \\n \" , stop_code ); PREFIX ( finalize ) (); } /* STOP function for string arguments.  */ void PREFIX ( stop_str ) ( const char * string , int32_t len ) { fputs ( \"STOP \" , stderr ); while ( len -- ) fputc ( * ( string ++ ), stderr ); fputs ( \" \\n \" , stderr ); PREFIX ( finalize ) (); } /* ERROR STOP function for string arguments.  */ void PREFIX ( error_stop_str ) ( const char * string , int32_t len ) { fputs ( \"ERROR STOP \" , stderr ); while ( len -- ) fputc ( * ( string ++ ), stderr ); fputs ( \" \\n \" , stderr ); error_stop ( 1 ); } /* ERROR STOP function for numerical arguments.  */ void PREFIX ( error_stop ) ( int32_t error ) { fprintf ( stderr , \"ERROR STOP %d \\n \" , error ); error_stop ( error ); }","tags":"","loc":"sourcefile/mpi_caf.c.html","title":"mpi_caf.c – OpenCoarrays"},{"text":"Source Code /* Single-Image implementation of Libcaf Copyright (c) 2012-2014, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */ #include \"libcaf.h\" #include <stdio.h>  /* For fputs and fprintf.  */ #include <stdlib.h> /* For exit and malloc.  */ #include <string.h> /* For memcpy and memset.  */ #include <stdarg.h> /* For variadic arguments.  */ /* Define GFC_CAF_CHECK to enable run-time checking.  */ /* #define GFC_CAF_CHECK  1  */ /* Single-image implementation of the CAF library. Note: For performance reasons -fcoarry=single should be used rather than this library.  */ typedef void * single_token_t ; #define TOKEN(X) ((single_token_t) (X)) /* Global variables.  */ caf_static_t * caf_static_list = NULL ; /* Keep in sync with mpi.c.  */ static void caf_runtime_error ( const char * message , ...) { va_list ap ; fprintf ( stderr , \"Fortran runtime error: \" ); va_start ( ap , message ); vfprintf ( stderr , message , ap ); va_end ( ap ); fprintf ( stderr , \" \\n \" ); /* FIXME: Shutdown the Fortran RTL to flush the buffer.  PR 43849.  */ exit ( EXIT_FAILURE ); } void PREFIX ( init ) ( int * argc __attribute__ (( unused )), char *** argv __attribute__ (( unused ))) { } void PREFIX ( finalize ) ( void ) { while ( caf_static_list != NULL ) { caf_static_t * tmp = caf_static_list -> prev ; free ( TOKEN ( caf_static_list -> token )); free ( caf_static_list ); caf_static_list = tmp ; } } int PREFIX ( this_image ) ( int distance __attribute__ (( unused ))) { return 1 ; } int PREFIX ( num_images ) ( int distance __attribute__ (( unused )), int failed __attribute__ (( unused ))) { return 1 ; } void * PREFIX ( register ) ( size_t size , caf_register_t type , caf_token_t * token , int * stat , char * errmsg , int errmsg_len ) { void * local ; local = malloc ( size ); * token = malloc ( sizeof ( single_token_t )); if ( unlikely ( local == NULL || TOKEN ( * token ) == NULL )) { const char msg [] = \"Failed to allocate coarray\" ; if ( stat ) { * stat = 1 ; if ( errmsg_len > 0 ) { int len = (( int ) sizeof ( msg ) > errmsg_len ) ? errmsg_len : ( int ) sizeof ( msg ); memcpy ( errmsg , msg , len ); if ( errmsg_len > len ) memset ( & errmsg [ len ], ' ' , errmsg_len - len ); } return NULL ; } else caf_runtime_error ( msg ); } * token = local ; if ( stat ) * stat = 0 ; if ( type == CAF_REGTYPE_COARRAY_STATIC ) { caf_static_t * tmp = malloc ( sizeof ( caf_static_t )); tmp -> prev = caf_static_list ; tmp -> token = * token ; caf_static_list = tmp ; } return local ; } void PREFIX ( deregister ) ( caf_token_t * token , int * stat , char * errmsg __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { free ( TOKEN ( * token )); if ( stat ) * stat = 0 ; } static void convert_type ( void * dst , int dst_type , int dst_kind , void * src , int src_type , int src_kind ) { #ifdef HAVE_GFC_INTEGER_16 typedef __int128 int128t ; #else typedef int64_t int128t ; #endif #if defined(GFC_REAL_16_IS_LONG_DOUBLE) typedef long double real128t ; typedef _Complex long double complex128t ; #elif defined(HAVE_GFC_REAL_16) typedef _Complex float __attribute__ (( mode ( TC ))) __complex128 ; typedef __float128 real128t ; typedef __complex128 complex128t ; #elif defined(HAVE_GFC_REAL_10) typedef long double real128t ; typedef long double complex128t ; #else typedef double real128t ; typedef _Complex double complex128t ; #endif int128t int_val = 0 ; real128t real_val = 0 ; complex128t cmpx_val = 0 ; switch ( src_type ) { case BT_INTEGER : if ( src_kind == 1 ) int_val = * ( int8_t * ) src ; else if ( src_kind == 2 ) int_val = * ( int16_t * ) src ; else if ( src_kind == 4 ) int_val = * ( int32_t * ) src ; else if ( src_kind == 8 ) int_val = * ( int64_t * ) src ; #ifdef HAVE_GFC_INTEGER_16 else if ( src_kind == 16 ) int_val = * ( int128t * ) src ; #endif else goto error ; break ; case BT_REAL : if ( src_kind == 4 ) real_val = * ( float * ) src ; else if ( src_kind == 8 ) real_val = * ( double * ) src ; #ifdef HAVE_GFC_REAL_10 else if ( src_kind == 10 ) real_val = * ( long double * ) src ; #endif #ifdef HAVE_GFC_REAL_16 else if ( src_kind == 16 ) real_val = * ( real128t * ) src ; #endif else goto error ; break ; case BT_COMPLEX : if ( src_kind == 4 ) cmpx_val = * ( _Complex float * ) src ; else if ( src_kind == 8 ) cmpx_val = * ( _Complex double * ) src ; #ifdef HAVE_GFC_REAL_10 else if ( src_kind == 10 ) cmpx_val = * ( _Complex long double * ) src ; #endif #ifdef HAVE_GFC_REAL_16 else if ( src_kind == 16 ) cmpx_val = * ( complex128t * ) src ; #endif else goto error ; break ; default : goto error ; } switch ( dst_type ) { case BT_INTEGER : if ( src_type == BT_INTEGER ) { if ( dst_kind == 1 ) * ( int8_t * ) dst = ( int8_t ) int_val ; else if ( dst_kind == 2 ) * ( int16_t * ) dst = ( int16_t ) int_val ; else if ( dst_kind == 4 ) * ( int32_t * ) dst = ( int32_t ) int_val ; else if ( dst_kind == 8 ) * ( int64_t * ) dst = ( int64_t ) int_val ; #ifdef HAVE_GFC_INTEGER_16 else if ( dst_kind == 16 ) * ( int128t * ) dst = ( int128t ) int_val ; #endif else goto error ; } else if ( src_type == BT_REAL ) { if ( dst_kind == 1 ) * ( int8_t * ) dst = ( int8_t ) real_val ; else if ( dst_kind == 2 ) * ( int16_t * ) dst = ( int16_t ) real_val ; else if ( dst_kind == 4 ) * ( int32_t * ) dst = ( int32_t ) real_val ; else if ( dst_kind == 8 ) * ( int64_t * ) dst = ( int64_t ) real_val ; #ifdef HAVE_GFC_INTEGER_16 else if ( dst_kind == 16 ) * ( int128t * ) dst = ( int128t ) real_val ; #endif else goto error ; } else if ( src_type == BT_COMPLEX ) { if ( dst_kind == 1 ) * ( int8_t * ) dst = ( int8_t ) cmpx_val ; else if ( dst_kind == 2 ) * ( int16_t * ) dst = ( int16_t ) cmpx_val ; else if ( dst_kind == 4 ) * ( int32_t * ) dst = ( int32_t ) cmpx_val ; else if ( dst_kind == 8 ) * ( int64_t * ) dst = ( int64_t ) cmpx_val ; #ifdef HAVE_GFC_INTEGER_16 else if ( dst_kind == 16 ) * ( int128t * ) dst = ( int128t ) cmpx_val ; #endif else goto error ; } else goto error ; break ; case BT_REAL : if ( src_type == BT_INTEGER ) { if ( dst_kind == 4 ) * ( float * ) dst = ( float ) int_val ; else if ( dst_kind == 8 ) * ( double * ) dst = ( double ) int_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( long double * ) dst = ( long double ) int_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( real128t * ) dst = ( real128t ) int_val ; #endif else goto error ; } else if ( src_type == BT_REAL ) { if ( dst_kind == 4 ) * ( float * ) dst = ( float ) real_val ; else if ( dst_kind == 8 ) * ( double * ) dst = ( double ) real_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( long double * ) dst = ( long double ) real_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( real128t * ) dst = ( real128t ) real_val ; #endif else goto error ; } else if ( src_type == BT_COMPLEX ) { if ( dst_kind == 4 ) * ( float * ) dst = ( float ) cmpx_val ; else if ( dst_kind == 8 ) * ( double * ) dst = ( double ) cmpx_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( long double * ) dst = ( long double ) cmpx_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( real128t * ) dst = ( real128t ) cmpx_val ; #endif else goto error ; } break ; case BT_COMPLEX : if ( src_type == BT_INTEGER ) { if ( dst_kind == 4 ) * ( _Complex float * ) dst = ( _Complex float ) int_val ; else if ( dst_kind == 8 ) * ( _Complex double * ) dst = ( _Complex double ) int_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( _Complex long double * ) dst = ( _Complex long double ) int_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( complex128t * ) dst = ( complex128t ) int_val ; #endif else goto error ; } else if ( src_type == BT_REAL ) { if ( dst_kind == 4 ) * ( _Complex float * ) dst = ( _Complex float ) real_val ; else if ( dst_kind == 8 ) * ( _Complex double * ) dst = ( _Complex double ) real_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( _Complex long double * ) dst = ( _Complex long double ) real_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( complex128t * ) dst = ( complex128t ) real_val ; #endif else goto error ; } else if ( src_type == BT_COMPLEX ) { if ( dst_kind == 4 ) * ( _Complex float * ) dst = ( _Complex float ) cmpx_val ; else if ( dst_kind == 8 ) * ( _Complex double * ) dst = ( _Complex double ) cmpx_val ; #ifdef HAVE_GFC_REAL_10 else if ( dst_kind == 10 ) * ( _Complex long double * ) dst = ( _Complex long double ) cmpx_val ; #endif #ifdef HAVE_GFC_REAL_16 else if ( dst_kind == 16 ) * ( complex128t * ) dst = ( complex128t ) cmpx_val ; #endif else goto error ; } else goto error ; break ; default : goto error ; } error : fprintf ( stderr , \"RUNTIME ERROR: Cannot convert type %d kind \" \"%d to type %d kind %d \\n \" , src_type , src_kind , dst_type , dst_kind ); PREFIX ( error_stop ) ( 1 ); } /* Get a scalar (or contiguous) data from remote image into a buffer.  */ void PREFIX ( get ) ( caf_token_t token , size_t offset , int image_index __attribute__ (( unused )), gfc_descriptor_t * src , caf_vector_t * src_vector __attribute__ (( unused )), gfc_descriptor_t * dest , int src_kind , int dst_kind ) { /* FIXME: Handle vector subscripts; check whether strings of different kinds are permitted.  */ size_t i , k , size ; int j ; int rank = GFC_DESCRIPTOR_RANK ( dest ); size_t src_size = GFC_DESCRIPTOR_SIZE ( src ); size_t dst_size = GFC_DESCRIPTOR_SIZE ( dest ); if ( rank == 0 ) { void * sr = ( void * ) (( char * ) TOKEN ( token ) + offset ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) memmove ( dest -> base_addr , sr , dst_size > src_size ? src_size : dst_size ); else convert_type ( dest -> base_addr , GFC_DESCRIPTOR_TYPE ( dest ), dst_kind , sr , GFC_DESCRIPTOR_TYPE ( src ), src_kind ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { if ( dst_kind == 1 ) memset (( void * )( char * ) dest -> base_addr + src_size , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( i = src_size / 4 ; i < dst_size / 4 ; i ++ ) (( int32_t * ) dest -> base_addr )[ i ] = ( int32_t ) ' ' ; } return ; } size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( size == 0 ) return ; for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / ( extent * stride )) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; } array_offset_dst += ( i / extent ) * dest -> dim [ rank - 1 ]. _stride ; void * dst = dest -> base_addr + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest ); ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / ( extent * stride )) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; } array_offset_sr += ( i / extent ) * src -> dim [ rank - 1 ]. _stride ; void * sr = ( void * )(( char * ) TOKEN ( token ) + offset + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src )); if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) memmove ( dst , sr , dst_size > src_size ? src_size : dst_size ); else convert_type ( dst , GFC_DESCRIPTOR_TYPE ( dest ), dst_kind , sr , GFC_DESCRIPTOR_TYPE ( src ), src_kind ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { if ( dst_kind == 1 ) memset (( void * )( char * ) dst + src_size , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( k = src_size / 4 ; k < dst_size / 4 ; i ++ ) (( int32_t * ) dst )[ i ] = ( int32_t ) ' ' ; } } } void PREFIX ( send ) ( caf_token_t token , size_t offset , int image_index __attribute__ (( unused )), gfc_descriptor_t * dest , caf_vector_t * dst_vector __attribute__ (( unused )), gfc_descriptor_t * src , int dst_kind , int src_kind ) { /* FIXME: Handle vector subscripts; check whether strings of different kinds are permitted.  */ size_t i , k , size ; int j ; int rank = GFC_DESCRIPTOR_RANK ( dest ); size_t src_size = GFC_DESCRIPTOR_SIZE ( src ); size_t dst_size = GFC_DESCRIPTOR_SIZE ( dest ); if ( rank == 0 ) { void * dst = ( void * ) (( char * ) TOKEN ( token ) + offset ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) memmove ( dst , src -> base_addr , dst_size > src_size ? src_size : dst_size ); else convert_type ( dst , GFC_DESCRIPTOR_TYPE ( dest ), dst_kind , src -> base_addr , GFC_DESCRIPTOR_TYPE ( src ), src_kind ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { if ( dst_kind == 1 ) memset (( void * )( char * ) dst + src_size , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( i = src_size / 4 ; i < dst_size / 4 ; i ++ ) (( int32_t * ) dst )[ i ] = ( int32_t ) ' ' ; } return ; } size = 1 ; for ( j = 0 ; j < rank ; j ++ ) { ptrdiff_t dimextent = dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ; if ( dimextent < 0 ) dimextent = 0 ; size *= dimextent ; } if ( size == 0 ) return ; for ( i = 0 ; i < size ; i ++ ) { ptrdiff_t array_offset_dst = 0 ; ptrdiff_t stride = 1 ; ptrdiff_t extent = 1 ; for ( j = 0 ; j < rank - 1 ; j ++ ) { array_offset_dst += (( i / ( extent * stride )) % ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 )) * dest -> dim [ j ]. _stride ; extent = ( dest -> dim [ j ]. _ubound - dest -> dim [ j ]. lower_bound + 1 ); stride = dest -> dim [ j ]. _stride ; } array_offset_dst += ( i / extent ) * dest -> dim [ rank - 1 ]. _stride ; void * dst = ( void * )(( char * ) TOKEN ( token ) + offset + array_offset_dst * GFC_DESCRIPTOR_SIZE ( dest )); void * sr ; if ( GFC_DESCRIPTOR_RANK ( src ) != 0 ) { ptrdiff_t array_offset_sr = 0 ; stride = 1 ; extent = 1 ; for ( j = 0 ; j < GFC_DESCRIPTOR_RANK ( src ) - 1 ; j ++ ) { array_offset_sr += (( i / ( extent * stride )) % ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 )) * src -> dim [ j ]. _stride ; extent = ( src -> dim [ j ]. _ubound - src -> dim [ j ]. lower_bound + 1 ); stride = src -> dim [ j ]. _stride ; } array_offset_sr += ( i / extent ) * src -> dim [ rank - 1 ]. _stride ; sr = ( void * )(( char * ) src -> base_addr + array_offset_sr * GFC_DESCRIPTOR_SIZE ( src )); } else sr = src -> base_addr ; if ( GFC_DESCRIPTOR_TYPE ( dest ) == GFC_DESCRIPTOR_TYPE ( src ) && dst_kind == src_kind ) memmove ( dst , sr , dst_size > src_size ? src_size : dst_size ); else convert_type ( dst , GFC_DESCRIPTOR_TYPE ( dest ), dst_kind , sr , GFC_DESCRIPTOR_TYPE ( src ), src_kind ); if ( GFC_DESCRIPTOR_TYPE ( dest ) == BT_CHARACTER && dst_size > src_size ) { if ( dst_kind == 1 ) memset (( void * )( char * ) dst + src_size , ' ' , dst_size - src_size ); else /* dst_kind == 4.  */ for ( k = src_size / 4 ; k < dst_size / 4 ; i ++ ) (( int32_t * ) dst )[ i ] = ( int32_t ) ' ' ; } } } void PREFIX ( sendget ) ( caf_token_t dst_token , size_t dst_offset , int dst_image_index , gfc_descriptor_t * dest , caf_vector_t * dst_vector , caf_token_t src_token , size_t src_offset , int src_image_index __attribute__ (( unused )), gfc_descriptor_t * src , caf_vector_t * src_vector __attribute__ (( unused )), int dst_len , int src_len ) { /* FIXME: Handle vector subscript of 'src_vector'.  */ /* For a single image, src->base_addr should be the same as src_token + offset but to play save, we do it properly.  */ void * src_base = src -> base_addr ; src -> base_addr = ( void * ) (( char * ) TOKEN ( src_token ) + src_offset ); PREFIX ( send ) ( dst_token , dst_offset , dst_image_index , dest , dst_vector , src , dst_len , src_len ); src -> base_addr = src_base ; } void PREFIX ( co_sum ) ( gfc_descriptor_t * a __attribute__ (( unused )), int result_image __attribute__ (( unused )), int * stat , char * errmsg __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { if ( stat ) * stat = 0 ; } void PREFIX ( co_min ) ( gfc_descriptor_t * a __attribute__ (( unused )), int result_image __attribute__ (( unused )), int * stat , char * errmsg __attribute__ (( unused )), int src_len __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { if ( stat ) * stat = 0 ; } void PREFIX ( co_max ) ( gfc_descriptor_t * a __attribute__ (( unused )), int result_image __attribute__ (( unused )), int * stat , char * errmsg __attribute__ (( unused )), int src_len __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { if ( stat ) * stat = 0 ; } void PREFIX ( sync_all ) ( int * stat , char * errmsg __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { if ( stat ) * stat = 0 ; } void PREFIX ( sync_images ) ( int count __attribute__ (( unused )), int images [] __attribute__ (( unused )), int * stat , char * errmsg __attribute__ (( unused )), int errmsg_len __attribute__ (( unused ))) { #ifdef GFC_CAF_CHECK int i ; for ( i = 0 ; i < count ; i ++ ) if ( images [ i ] != 1 ) { fprintf ( stderr , \"COARRAY ERROR: Invalid image index %d to SYNC \" \"IMAGES\" , images [ i ]); exit ( EXIT_FAILURE ); } #endif if ( stat ) * stat = 0 ; } void PREFIX ( error_stop_str ) ( const char * string , int32_t len ) { fputs ( \"ERROR STOP \" , stderr ); while ( len -- ) fputc ( * ( string ++ ), stderr ); fputs ( \" \\n \" , stderr ); exit ( 1 ); } void PREFIX ( error_stop ) ( int32_t error ) { fprintf ( stderr , \"ERROR STOP %d \\n \" , error ); exit ( error ); }","tags":"","loc":"sourcefile/single.c.html","title":"single.c – OpenCoarrays"},{"text":"Source Code #!/bin/sh echo \"Building the code:\" export TAU_MAKEFILE = /opt/paratools/tau/x86_64/lib/Makefile.tau-mpi-pdt export TAU_OPTIONS = \"-optVerbose -optCompInst\" make clean make -f Makefile.inst # Specify TAU parameters here: export TAU_CALLPATH = 1 export TAU_CALLPATH_DEPTH = 100 #export TAU_SAMPLING=1 for i in 1 2 4 do echo \"Running the code:\" mpirun -np ${ i } ./burgers paraprof --pack ${ i } p.ppk taudb_loadtrial -a fireworks -x experiment -n ${ i } ${ i } p.ppk done echo \"Running the pprof command:\" pprof echo \"Running the TAU paraprof analyzer command:\" paraprof &","tags":"","loc":"sourcefile/run.sh.html","title":"run.sh – OpenCoarrays"},{"text":"Source Code #!/bin/sh echo \"Building the code:\" export TAU_MAKEFILE = /opt/paratools/tau/x86_64/lib/Makefile.tau-mpi-pdt export TAU_OPTIONS = \"-optVerbose -optCompInst\" make clean make -f Makefile.inst # Specify TAU parameters here: export TAU_CALLPATH = 1 export TAU_CALLPATH_DEPTH = 100 #export TAU_SAMPLING=1 echo \"Running the code:\" mpirun -np 4 ./burgers echo \"Running the pprof command:\" pprof echo \"Running the TAU paraprof analyzer command:\" paraprof &","tags":"","loc":"sourcefile/run.sh~2.html","title":"run.sh – OpenCoarrays"},{"text":"Source Code #!/bin/bash source /usr/local/packages/Modules/init/bash module load intel/14.0 source /usr/local/packages/intel/14.0/bin/ifortvars.sh intel64 export TAU_MAKEFILE = /usr/local/packages/tau-2.22.2/x86_64/lib/Makefile.tau-coarray-icpc-mpi export TAU_COMM_MATRIX = 1 export PATH = /usr/local/packages/tau-2.22.2/x86_64/bin: $PATH module load java export PATH = /usr/local/packages/intel/14.0/mpirt/bin/intel64/: $PATH #export FOR_COARRAY_NUM_IMAGES=1 echo \"Using FOR_COARRAY_NUM_IMAGES = \" $FOR_COARRAY_NUM_IMAGES mpirun --mca btl_tcp_if_include eth2 -np 16 ./burgers_caf #./burgers_caf","tags":"","loc":"sourcefile/run_troubleshooting.sh.html","title":"run_troubleshooting.sh – OpenCoarrays"},{"text":"Source Code /* PSNAP Test: timemeausure.c Copyright (c) 2012-2016, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS */ #include <stdio.h> #include <stdlib.h> #include <sys/types.h> #include <sys/errno.h> #include <sys/time.h> static struct timezone tz ; static struct timeval start_time , finish_time ; /* Start measuring a time delay */ void start_timer ( void ) { gettimeofday ( & start_time , & tz ); } /* Retunrn elapsed time in microseconds */ int elapsed_time ( void ) { gettimeofday ( & finish_time , & tz ); return ( 1000000.0 * ( finish_time . tv_sec - start_time . tv_sec ) + ( finish_time . tv_usec - start_time . tv_usec ) ); } /* Return the stopping time in microseconds */ double stop_timer ( void ) { gettimeofday ( & finish_time , & tz ); return ( 1000000.0 * finish_time . tv_sec + finish_time . tv_usec ); }","tags":"","loc":"sourcefile/timemeasure.c.html","title":"timemeasure.c – OpenCoarrays"},{"text":"Source Code /* syncimages2 test program Copyright (c) 2012-2014, Sourcery, Inc. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the Sourcery, Inc., nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SOURCERY, INC., BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS */ #include <stdlib.h> #include <stdio.h> #include \"libcaf.h\" #include <sys/types.h> #include <sys/errno.h> #include <sys/time.h> #include <stdbool.h> static struct timezone tz ; static struct timeval start_time , finish_time ; /* Start measuring a time delay */ void start_timer ( void ) { gettimeofday ( & start_time , & tz ); } /* Retunrn elapsed time in milliseconds */ double elapsed_time ( void ) { gettimeofday ( & finish_time , & tz ); return ( 1000.0 * ( finish_time . tv_sec - start_time . tv_sec ) + ( finish_time . tv_usec - start_time . tv_usec ) / 1000.0 ); } /* Return the stopping time in milliseconds */ double stop_time ( void ) { gettimeofday ( & finish_time , & tz ); return ( 1000.0 * finish_time . tv_sec + finish_time . tv_usec / 1000.0 ); } int main ( int argc , char ** argv ) { int info = 0 , me , np , n = 1 , i , * images ; double * a_d , * d ; caf_token_t token ; ptrdiff_t size = sizeof ( double ); char errmsg [ 255 ]; bool check = true ; /* if(argc == 1) */ /*   { */ /*     printf(\"Please insert message size\\n\"); */ /*     return 1; */ /*   } */ /* sscanf(argv[1],\"%d\",&n); */ /* n = (int)n/sizeof(double); */ /* size = n*sizeof(double); */ _gfortran_caf_init ( & argc , & argv ); me = _gfortran_caf_this_image ( 1 ); np = _gfortran_caf_num_images ( 1 , 1 ); a_d = _gfortran_caf_register ( size , CAF_REGTYPE_COARRAY_STATIC , & token , & info , errmsg , 255 ); /* start_timer(); */ images = calloc ( np , sizeof ( int )); if ( me == 1 ) { images [ 0 ] = - 1 ; _gfortran_caf_sync_images ( 1 , images , & info , errmsg , 255 ); } else { images [ 0 ] = 1 ; _gfortran_caf_sync_images ( 1 , images , & info , errmsg , 255 ); } printf ( \"proc %d dval: %lf \\n \" , me ); /* stop_time(); */ if ( info != 0 ) printf ( \"Error \\n \" ); _gfortran_caf_finalize (); return 0 ; }","tags":"","loc":"sourcefile/syncimages2.c.html","title":"syncimages2.c – OpenCoarrays"},{"text":"type, private, bind(C) :: caf_vector_t type~~caf_vector_t~~InheritsGraph type~caf_vector_t caf_vector_t type~u_t u_t type~u_t->type~caf_vector_t u type~triplet_t triplet_t type~triplet_t->type~u_t triplet type~v_t v_t type~v_t->type~u_t v c_ptr c_ptr c_ptr->type~v_t vector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: nvec type( u_t ), public :: u","tags":"","loc":"type/caf_vector_t.html","title":"caf_vector_t – OpenCoarrays "},{"text":"type, private, bind(C) :: descriptor_dimension Inherited By type~~descriptor_dimension~~InheritedByGraph type~descriptor_dimension descriptor_dimension type~gfc_descriptor_t gfc_descriptor_t type~descriptor_dimension->type~gfc_descriptor_t dim_ Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: lower_bound integer(kind=c_ptrdiff_t), public :: stride integer(kind=c_ptrdiff_t), public :: ubound_","tags":"","loc":"type/descriptor_dimension.html","title":"descriptor_dimension – OpenCoarrays "},{"text":"type, private, bind(C) :: gfc_descriptor_t type~~gfc_descriptor_t~~InheritsGraph type~gfc_descriptor_t gfc_descriptor_t c_ptr c_ptr c_ptr->type~gfc_descriptor_t base_addr type~descriptor_dimension descriptor_dimension type~descriptor_dimension->type~gfc_descriptor_t dim_ Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type(c_ptr), public :: base_addr type( descriptor_dimension ), public :: dim_ (max_dimensions) integer(kind=c_ptrdiff_t), public :: dtype integer(kind=c_ptrdiff_t), public :: offset","tags":"","loc":"type/gfc_descriptor_t.html","title":"gfc_descriptor_t – OpenCoarrays "},{"text":"type, private, bind(C) :: triplet_t Inherited By type~~triplet_t~~InheritedByGraph type~triplet_t triplet_t type~u_t u_t type~triplet_t->type~u_t triplet type~caf_vector_t caf_vector_t type~u_t->type~caf_vector_t u Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: lower_bound integer(kind=c_ptrdiff_t), public :: stride integer(kind=c_ptrdiff_t), public :: upper_bound","tags":"","loc":"type/triplet_t.html","title":"triplet_t – OpenCoarrays "},{"text":"type, private, bind(C) :: u_t type~~u_t~~InheritsGraph type~u_t u_t type~triplet_t triplet_t type~triplet_t->type~u_t triplet type~v_t v_t type~v_t->type~u_t v c_ptr c_ptr c_ptr->type~v_t vector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Inherited By type~~u_t~~InheritedByGraph type~u_t u_t type~caf_vector_t caf_vector_t type~u_t->type~caf_vector_t u Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial type( triplet_t ), public :: triplet type( v_t ), public :: v","tags":"","loc":"type/u_t.html","title":"u_t – OpenCoarrays "},{"text":"type, private, bind(C) :: v_t type~~v_t~~InheritsGraph type~v_t v_t c_ptr c_ptr c_ptr->type~v_t vector Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Inherited By type~~v_t~~InheritedByGraph type~v_t v_t type~u_t u_t type~v_t->type~u_t v type~caf_vector_t caf_vector_t type~u_t->type~caf_vector_t u Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: kind_ type(c_ptr), public :: vector","tags":"","loc":"type/v_t.html","title":"v_t – OpenCoarrays "},{"text":"type, public, extends( co_object ) :: global_field type~~global_field~~InheritsGraph type~global_field global_field type~co_object co_object type~co_object->type~global_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=real64), private, allocatable :: values (:)[:] Type-Bound Procedures procedure, private :: add_local_field private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) procedure, private :: assign_local_field private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs generic, public :: assignment(=) => assign_local_field private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs procedure, public, nopass :: grid_spacing private function grid_spacing () result(delta_x) Arguments None Return Value real(kind=real64) procedure, private :: multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs class( global_field ), intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(*) => multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs class( global_field ), intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(+) => add_local_field private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) procedure, public :: output private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: set private subroutine set (this, initial_function, num_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this procedure( initial_condition ), , pointer :: initial_function integer, intent(in) :: num_points procedure, public :: state private pure function state (this) result(local_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:) procedure, public :: x private pure function x (this) result(this_x) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field ) procedure, public :: xx private function xx (this) result(this_xx) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field )","tags":"","loc":"type/global_field.html","title":"global_field – OpenCoarrays "},{"text":"type, public, extends( object ) :: local_field type~~local_field~~InheritsGraph type~local_field local_field type~object object type~object->type~local_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=real64), private, allocatable :: values (:) Type-Bound Procedures procedure, private :: assign_array private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real(kind=real64), intent(in) :: rhs (:) generic, public :: assignment(=) => assign_array private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real(kind=real64), intent(in) :: rhs (:) procedure, private, pass(rhs) :: multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(*) => multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(-) => subtract private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field ) procedure, public :: output private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: state private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:) procedure, private :: subtract private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"type/local_field.html","title":"local_field – OpenCoarrays "},{"text":"type, public :: error_message type~~error_message~~InheritsGraph type~error_message error_message type~object object type~object->type~error_message odata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. @endcond Components Type Visibility Attributes Name Initial complex, private, allocatable :: cdata (:) character, private, allocatable :: chdata (:) integer, private, allocatable :: idata (:) logical, private, allocatable :: ldata (:) class( object ), private, allocatable :: odata real, private, allocatable :: rdata (:) character(len=max_string_length), private :: string character(len=:), private, allocatable :: string Constructor public interface error_message @cond Interface private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message )","tags":"","loc":"type/error_message.html","title":"error_message – OpenCoarrays "},{"text":"type, public :: error Components Type Visibility Attributes Name Initial integer, private :: code class(*), private, allocatable :: data_ (:) character(len=max_string_length), private :: message character(len=:), private, allocatable :: message Type-Bound Procedures procedure, public :: define_error private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:) generic, public :: error => define_error private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:) procedure, public :: error_code private function error_code (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer","tags":"","loc":"type/error.html","title":"error – OpenCoarrays "},{"text":"type, public, abstract :: co_object Inherited By type~~co_object~~InheritedByGraph type~co_object co_object type~global_field global_field type~co_object->type~global_field Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, private :: defined = .false. real, private, allocatable :: dummy_to_facilitate_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this procedure( formatted_output_interface ), public, deferred :: output subroutine formatted_output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: user_defined private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"type/co_object.html","title":"co_object – OpenCoarrays "},{"text":"type, public, abstract :: object Inherited By type~~object~~InheritedByGraph type~object object type~error_message error_message type~object->type~error_message odata type~error_message~2 error_message type~object->type~error_message~2 odata type~local_field local_field type~object->type~local_field type~periodic_2nd_order periodic_2nd_order type~object->type~periodic_2nd_order type~mpi_class mpi_class type~object->type~mpi_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Type-Bound Procedures procedure, public :: mark_as_defined private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this procedure( output_interface ), public, deferred :: output subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: user_defined private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical generic, public :: write(formatted) => output subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/object.html","title":"object – OpenCoarrays "},{"text":"type, public :: global_field Components Type Visibility Attributes Name Initial real, private, allocatable :: values (:)[:] Type-Bound Procedures procedure, private :: add_local_field private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) procedure, private :: assign_local_field private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs generic, public :: assignment(=) => assign_local_field private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs generic, public :: global_field_ => set , only_allocate private subroutine set (this, internal_values, boundary_values, domain, num_global_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this real, intent(in) :: internal_values real, intent(in) :: boundary_values (num_end_points) real, intent(in) :: domain (num_end_points) integer, intent(in) :: num_global_points private subroutine only_allocate (this) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this procedure, private :: laplacian private pure function laplacian (rhs) result(laplacian_rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: rhs Return Value type( local_field ) procedure, public :: only_allocate private subroutine only_allocate (this) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this generic, public :: operator(+) => add_local_field private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(.laplacian.) => laplacian private pure function laplacian (rhs) result(laplacian_rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: rhs Return Value type( local_field ) procedure, public :: set private subroutine set (this, internal_values, boundary_values, domain, num_global_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this real, intent(in) :: internal_values real, intent(in) :: boundary_values (num_end_points) real, intent(in) :: domain (num_end_points) integer, intent(in) :: num_global_points procedure, public :: state private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real\n  (size(this%values(:)))","tags":"","loc":"type/global_field~2.html","title":"global_field – OpenCoarrays "},{"text":"type, public :: local_field Components Type Visibility Attributes Name Initial real, private, allocatable :: values (:) Type-Bound Procedures procedure, private :: assign_array private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real, intent(in) :: rhs (:) generic, public :: assignment(=) => assign_array private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real, intent(in) :: rhs (:) procedure, private :: multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs real, intent(in) :: rhs Return Value type( local_field ) generic, public :: operator(*) => multiply private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs real, intent(in) :: rhs Return Value type( local_field ) procedure, public :: state private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real\n  (size(this%values))","tags":"","loc":"type/local_field~2.html","title":"local_field – OpenCoarrays "},{"text":"type, public :: error_message type~~error_message~2~~InheritsGraph type~error_message~2 error_message type~object object type~object->type~error_message~2 odata Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. @endcond Components Type Visibility Attributes Name Initial complex, private, allocatable :: cdata (:) character, private, allocatable :: chdata (:) integer, private, allocatable :: idata (:) logical, private, allocatable :: ldata (:) class( object ), private, allocatable :: odata real, private, allocatable :: rdata (:) character(len=max_string_length), private :: string character(len=:), private, allocatable :: string Constructor public interface error_message @cond Interface private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message )","tags":"","loc":"type/error_message~2.html","title":"error_message – OpenCoarrays "},{"text":"type, public :: error Components Type Visibility Attributes Name Initial integer, private :: code class(*), private, allocatable :: data_ (:) character(len=max_string_length), private :: message character(len=:), private, allocatable :: message Type-Bound Procedures procedure, public :: define_error private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:) generic, public :: error => define_error private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:) procedure, public :: error_code private function error_code (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer","tags":"","loc":"type/error~2.html","title":"error – OpenCoarrays "},{"text":"type, public, abstract :: co_object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. real, private, allocatable :: dummy_to_facilitate_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this procedure( formatted_output_interface ), public, deferred :: output subroutine formatted_output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: user_defined private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"type/co_object~2.html","title":"co_object – OpenCoarrays "},{"text":"type, public, abstract :: object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Type-Bound Procedures procedure, public :: mark_as_defined private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this procedure( output_interface ), public, deferred :: output subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: user_defined private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical generic, public :: write(formatted) => output subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Prototype Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/object~2.html","title":"object – OpenCoarrays "},{"text":"type, public, extends( object ) :: mpi_class type~~mpi_class~~InheritsGraph type~mpi_class mpi_class type~object object type~object->type~mpi_class Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Type-Bound Procedures procedure, public, nopass :: barrier private subroutine barrier () Arguments None procedure, public, nopass :: mpi_begin private subroutine mpi_begin () Arguments None procedure, public, nopass :: mpi_end private subroutine mpi_end () Arguments None procedure, public, nopass :: oned_message private subroutine oned_message (periodic, local_grid_resolution, left_sub, right_sub) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:) :: periodic integer(kind=ikind), intent(in) :: local_grid_resolution real(kind=rkind), intent(inout) :: left_sub real(kind=rkind), intent(inout) :: right_sub procedure, public :: output private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( mpi_class ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"type/mpi_class.html","title":"mpi_class – OpenCoarrays "},{"text":"type, public, extends( object ) :: periodic_2nd_order type~~periodic_2nd_order~~InheritsGraph type~periodic_2nd_order periodic_2nd_order type~object object type~object->type~periodic_2nd_order Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Components Type Visibility Attributes Name Initial real(kind=rkind), public, allocatable :: global_f (:) Type-Bound Procedures procedure, public :: add => add_field private function add_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) procedure, public :: assign_field private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: lhs type( periodic_2nd_order ), intent(in) :: rhs generic, public :: assignment(=) => assign_field private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: lhs type( periodic_2nd_order ), intent(in) :: rhs procedure, public :: construct private subroutine construct (this, initial, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: this procedure( initial_field ), intent(in), pointer :: initial integer(kind=ikind), intent(in) :: num_grid_pts procedure, public, nopass :: get_time private pure function get_time () result(t) Arguments None Return Value real(kind=rkind) procedure, public :: has_a_zero_at private pure function has_a_zero_at (this, expected_location) result(zero_at_expected_location) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: expected_location Return Value logical procedure, public :: local_state private pure function local_state (this) result(local_state_vector) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value real(kind=rkind),\n  allocatable,(:) procedure, public :: multiply => multiply_field private function multiply_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) procedure, public :: multiply_real private function multiply_real (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs real(kind=rkind), intent(in) :: rhs Return Value type( periodic_2nd_order ) generic, public :: operator(*) => multiply private function multiply_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) generic, public :: operator(*) => multiply_real private function multiply_real (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs real(kind=rkind), intent(in) :: rhs Return Value type( periodic_2nd_order ) generic, public :: operator(+) => add private function add_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) generic, public :: operator(-) => subtract private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) procedure, public :: output private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: runge_kutta_2nd_step => rk2_dt private function rk2_dt (this, nu, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: nu integer(kind=ikind), intent(in) :: num_grid_pts Return Value real(kind=rkind) procedure, public, nopass :: set_time private subroutine set_time (time_stamp) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: time_stamp procedure, public :: subtract private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) procedure, public, nopass :: this_image_contains private pure function this_image_contains (location) result(within_bounds) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: location Return Value logical procedure, public :: x => df_dx private function df_dx (this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order ) procedure, public :: xx => d2f_dx2 private function d2f_dx2 (this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order )","tags":"","loc":"type/periodic_2nd_order.html","title":"periodic_2nd_order – OpenCoarrays "},{"text":"type, bind( c) :: counters Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index integer(kind=c_long), public :: val Source Code type , bind ( c ) :: counters integer ( c_long ) :: val integer ( c_int ) :: index end type counters","tags":"","loc":"type/counters.html","title":"counters – OpenCoarrays "},{"text":"abstract interface private pure function c_double_operator(lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: lhs real(kind=c_double), intent(in) :: rhs Return Value real(kind=c_double)","tags":"","loc":"interface/c_double_operator.html","title":"c_double_operator – OpenCoarrays"},{"text":"abstract interface private pure function c_int_operator(lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: lhs integer(kind=c_int), intent(in) :: rhs Return Value integer(kind=c_int)","tags":"","loc":"interface/c_int_operator.html","title":"c_int_operator – OpenCoarrays"},{"text":"abstract interface private pure function logical_operator(lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs logical, intent(in) :: rhs Return Value logical","tags":"","loc":"interface/logical_operator.html","title":"logical_operator – OpenCoarrays"},{"text":"abstract interface public pure function initial_condition(x) result(initial_values) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","loc":"interface/initial_condition.html","title":"initial_condition – OpenCoarrays"},{"text":"abstract interface private subroutine formatted_output_interface(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/formatted_output_interface.html","title":"formatted_output_interface – OpenCoarrays"},{"text":"abstract interface private subroutine output_interface(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/output_interface.html","title":"output_interface – OpenCoarrays"},{"text":"abstract interface private subroutine formatted_output_interface(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/formatted_output_interface~2.html","title":"formatted_output_interface – OpenCoarrays"},{"text":"abstract interface private subroutine output_interface(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"interface/output_interface~2.html","title":"output_interface – OpenCoarrays"},{"text":"abstract interface public pure function initial_field(x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/initial_field.html","title":"initial_field – OpenCoarrays"},{"text":"subroutine solve_navier_stokes() Uses: run_size Arguments None Description * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) Calls proc~~solve_navier_stokes~~CallsGraph proc~solve_navier_stokes solve_navier_stokes none~phase2 phase2 proc~solve_navier_stokes->none~phase2 none~walltime WALLTIME proc~solve_navier_stokes->none~walltime none~define_step define_step proc~solve_navier_stokes->none~define_step none~phase1 phase1 proc~solve_navier_stokes->none~phase1 none~define_field define_field proc~solve_navier_stokes->none~define_field none~ctrig ctrig proc~solve_navier_stokes->none~ctrig none~pressure pressure proc~solve_navier_stokes->none~pressure none~define_kspace define_kspace proc~solve_navier_stokes->none~define_kspace none~define_shifts define_shifts proc~solve_navier_stokes->none~define_shifts none~transpose_y_x transpose_Y_X proc~solve_navier_stokes->none~transpose_y_x none~enforce_conjugate_symmetry enforce_conjugate_symmetry proc~solve_navier_stokes->none~enforce_conjugate_symmetry none~advance advance proc~solve_navier_stokes->none~advance global_times global_times proc~solve_navier_stokes->global_times none~copy_s_n copy_s_n proc~solve_navier_stokes->none~copy_s_n none~transpose_x_y transpose_X_Y proc~solve_navier_stokes->none~transpose_x_y none~copy_n_s copy_n_s proc~solve_navier_stokes->none~copy_n_s none~rtrig rtrig proc~solve_navier_stokes->none~rtrig none~phase3 phase3 proc~solve_navier_stokes->none~phase3 none~cfft cfft none~phase2->none~cfft none~rfft rfft none~phase2->none~rfft none~define_step->none~walltime max_velmax max_velmax none~define_step->max_velmax none~phase1->none~cfft proc~init_random_seed init_random_seed none~define_field->proc~init_random_seed none~transpose_y_x->none~walltime proc~copy3 copy3 none~transpose_y_x->proc~copy3 none~transpose_x_y->none~walltime none~transpose_x_y->proc~copy3 none~phase3->none~cfft none~lcg lcg proc~init_random_seed->none~lcg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial complex, public, allocatable :: bufr_X_Y (:,:,:,:) complex, public, allocatable :: bufr_Y_X (:,:,:,:) real, public :: k1 (nx/2) real, public :: k2 (ny) real, public :: k3 (nz) real, public :: kx (nx/2) real, public :: ky (nx/2,ny) real, public :: ky_ (nx/2,ny) real, public :: kz (nz) real, public :: mk1 (nx/2) real, public :: mk2 (ny) real, public :: mk3 (nz) integer(kind=int64), public :: nshells integer(kind=int64), public :: oflag integer(kind=int64), public :: rflag integer(kind=int64), public :: rkstep integer(kind=int64), public :: step integer(kind=int64), public :: stop complex, public :: sx (nx/2,3) complex, public :: sy (ny,3) complex, public :: sz (nz,3) integer(kind=int64), public :: trigx integer(kind=int64), public :: trigxy integer(kind=int64), public :: trigy integer(kind=int64), public :: trigz complex, public, allocatable :: u (:,:,:,:)[:] complex, public, allocatable :: un (:,:,:,:) complex, public, allocatable :: ur (:,:,:,:)[:] Interfaces interface function WALLTIME () bind(C, name = \"WALLTIME\") Arguments None Return Value real(kind=real64) interface subroutine cfft (len, lot, data, inc, jmp, ctrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: ctrig integer(kind=int64), intent(in), value :: isign interface function ctrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) interface subroutine rfft (len, lot, data, inc, jmp, rtrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: rtrig integer(kind=int64), intent(in), value :: isign interface function rtrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) Subroutines subroutine advance() Arguments None subroutine copy_n_s() Arguments None subroutine copy_s_n() Arguments None subroutine define_field() Arguments None subroutine define_kspace() Arguments None subroutine define_shifts() Arguments None subroutine define_step() Arguments None subroutine enforce_conjugate_symmetry() Arguments None subroutine phase1() Arguments None subroutine phase2() Arguments None subroutine phase3() Arguments None subroutine pressure() Arguments None subroutine remesh() Arguments None subroutine spectra() Arguments None subroutine transpose_X_Y() Arguments None subroutine transpose_Y_X() Arguments None Source Code subroutine solve_navier_stokes end subroutine solve_navier_stokes","tags":"","loc":"proc/solve_navier_stokes.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"subroutine solve_navier_stokes() Uses: run_size Arguments None Description * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) Calls proc~~solve_navier_stokes~2~~CallsGraph proc~solve_navier_stokes~2 solve_navier_stokes none~copy_s_n~2 copy_s_n proc~solve_navier_stokes~2->none~copy_s_n~2 none~copy_n_s~2 copy_n_s proc~solve_navier_stokes~2->none~copy_n_s~2 global_times global_times proc~solve_navier_stokes~2->global_times none~pressure~2 pressure proc~solve_navier_stokes~2->none~pressure~2 none~define_shifts~2 define_shifts proc~solve_navier_stokes~2->none~define_shifts~2 none~phase1~2 phase1 proc~solve_navier_stokes~2->none~phase1~2 none~advance~2 advance proc~solve_navier_stokes~2->none~advance~2 none~rtrig~2 rtrig proc~solve_navier_stokes~2->none~rtrig~2 none~phase3~2 phase3 proc~solve_navier_stokes~2->none~phase3~2 none~ctrig~2 ctrig proc~solve_navier_stokes~2->none~ctrig~2 walltime walltime proc~solve_navier_stokes~2->walltime none~define_kspace~2 define_kspace proc~solve_navier_stokes~2->none~define_kspace~2 none~define_step~2 define_step proc~solve_navier_stokes~2->none~define_step~2 none~transpose_x_y~2 transpose_X_Y proc~solve_navier_stokes~2->none~transpose_x_y~2 none~transpose_y_x~2 transpose_Y_X proc~solve_navier_stokes~2->none~transpose_y_x~2 none~define_field~2 define_field proc~solve_navier_stokes~2->none~define_field~2 none~enforce_conjugate_symmetry~2 enforce_conjugate_symmetry proc~solve_navier_stokes~2->none~enforce_conjugate_symmetry~2 none~phase2~2 phase2 proc~solve_navier_stokes~2->none~phase2~2 none~cfft~2 cfft none~phase1~2->none~cfft~2 none~phase3~2->none~cfft~2 none~define_step~2->walltime max_velmax max_velmax none~define_step~2->max_velmax none~transpose_x_y~2->walltime proc~copy3 copy3 none~transpose_x_y~2->proc~copy3 none~transpose_y_x~2->walltime none~transpose_y_x~2->proc~copy3 proc~init_random_seed init_random_seed none~define_field~2->proc~init_random_seed none~phase2~2->none~cfft~2 none~rfft~2 rfft none~phase2~2->none~rfft~2 none~lcg lcg proc~init_random_seed->none~lcg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial complex, public, allocatable :: bufr_X_Y (:,:,:,:) complex, public, allocatable :: bufr_Y_X (:,:,:,:) real, public :: k1 (nx/2) real, public :: k2 (ny) real, public :: k3 (nz) real, public :: kx (nx/2) real, public :: ky (nx/2,ny) real, public :: ky_ (nx/2,ny) real, public :: kz (nz) real, public :: mk1 (nx/2) real, public :: mk2 (ny) real, public :: mk3 (nz) integer(kind=int64), public :: nshells integer(kind=int64), public :: oflag integer(kind=int64), public :: rflag integer(kind=int64), public :: rkstep integer(kind=int64), public :: step integer(kind=int64), public :: stop complex, public :: sx (nx/2,3) complex, public :: sy (ny,3) complex, public :: sz (nz,3) real, public :: t_end real, public :: t_start integer(kind=int64), public :: trigx integer(kind=int64), public :: trigxy integer(kind=int64), public :: trigy integer(kind=int64), public :: trigz complex, public, allocatable :: u (:,:,:,:)[:] complex, public, allocatable :: un (:,:,:,:) complex, public, allocatable :: ur (:,:,:,:)[:] Interfaces interface subroutine cfft (len, lot, data, inc, jmp, ctrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: ctrig integer(kind=int64), intent(in), value :: isign interface function ctrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) interface subroutine rfft (len, lot, data, inc, jmp, rtrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: rtrig integer(kind=int64), intent(in), value :: isign interface function rtrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) Subroutines subroutine advance() Arguments None subroutine copy_n_s() Arguments None subroutine copy_s_n() Arguments None subroutine define_field() Arguments None subroutine define_kspace() Arguments None subroutine define_shifts() Arguments None subroutine define_step() Arguments None subroutine enforce_conjugate_symmetry() Arguments None subroutine phase1() Arguments None subroutine phase2() Arguments None subroutine phase3() Arguments None subroutine pressure() Arguments None subroutine remesh() Arguments None subroutine spectra() Arguments None subroutine transpose_X_Y() Arguments None subroutine transpose_Y_X() Arguments None Source Code subroutine solve_navier_stokes end subroutine solve_navier_stokes","tags":"","loc":"proc/solve_navier_stokes~2.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"subroutine solve_navier_stokes() Uses: run_size Arguments None Description * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) Calls proc~~solve_navier_stokes~3~~CallsGraph proc~solve_navier_stokes~3 solve_navier_stokes none~phase3~3 phase3 proc~solve_navier_stokes~3->none~phase3~3 none~transpose_x_y~3 transpose_X_Y proc~solve_navier_stokes~3->none~transpose_x_y~3 none~define_field~3 define_field proc~solve_navier_stokes~3->none~define_field~3 none~phase2~3 phase2 proc~solve_navier_stokes~3->none~phase2~3 none~copy_s_n~3 copy_s_n proc~solve_navier_stokes~3->none~copy_s_n~3 none~enforce_conjugate_symmetry~3 enforce_conjugate_symmetry proc~solve_navier_stokes~3->none~enforce_conjugate_symmetry~3 none~define_step~3 define_step proc~solve_navier_stokes~3->none~define_step~3 none~copy_n_s~3 copy_n_s proc~solve_navier_stokes~3->none~copy_n_s~3 none~phase1~3 phase1 proc~solve_navier_stokes~3->none~phase1~3 none~advance~3 advance proc~solve_navier_stokes~3->none~advance~3 none~define_shifts~3 define_shifts proc~solve_navier_stokes~3->none~define_shifts~3 global_times global_times proc~solve_navier_stokes~3->global_times none~rtrig~3 rtrig proc~solve_navier_stokes~3->none~rtrig~3 none~walltime~2 WALLTIME proc~solve_navier_stokes~3->none~walltime~2 none~pressure~3 pressure proc~solve_navier_stokes~3->none~pressure~3 none~ctrig~3 ctrig proc~solve_navier_stokes~3->none~ctrig~3 none~define_kspace~3 define_kspace proc~solve_navier_stokes~3->none~define_kspace~3 none~transpose_y_x~3 transpose_Y_X proc~solve_navier_stokes~3->none~transpose_y_x~3 none~cfft~3 cfft none~phase3~3->none~cfft~3 none~transpose_x_y~3->none~walltime~2 proc~copy3 copy3 none~transpose_x_y~3->proc~copy3 proc~init_random_seed init_random_seed none~define_field~3->proc~init_random_seed none~phase2~3->none~cfft~3 none~rfft~3 rfft none~phase2~3->none~rfft~3 none~define_step~3->none~walltime~2 max_velmax max_velmax none~define_step~3->max_velmax none~phase1~3->none~cfft~3 none~transpose_y_x~3->none~walltime~2 none~transpose_y_x~3->proc~copy3 none~lcg lcg proc~init_random_seed->none~lcg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial complex, public, allocatable :: bufr_X_Y (:,:,:,:) complex, public, allocatable :: bufr_Y_X (:,:,:,:) real, public :: k1 (nx/2) real, public :: k2 (ny) real, public :: k3 (nz) real, public :: kx (nx/2) real, public :: ky (nx/2,ny) real, public :: ky_ (nx/2,ny) real, public :: kz (nz) real, public :: mk1 (nx/2) real, public :: mk2 (ny) real, public :: mk3 (nz) integer(kind=int64), public :: nshells integer(kind=int64), public :: oflag integer(kind=int64), public :: rflag integer(kind=int64), public :: rkstep integer(kind=int64), public :: step integer(kind=int64), public :: stop complex, public :: sx (nx/2,3) complex, public :: sy (ny,3) complex, public :: sz (nz,3) integer(kind=int64), public :: trigx integer(kind=int64), public :: trigxy integer(kind=int64), public :: trigy integer(kind=int64), public :: trigz complex, public, allocatable :: u (:,:,:,:)[:] complex, public, allocatable :: un (:,:,:,:) complex, public, allocatable :: ur (:,:,:,:)[:] Interfaces interface function WALLTIME () bind(C, name = \"WALLTIME\") Arguments None Return Value real(kind=real64) interface subroutine cfft (len, lot, data, inc, jmp, ctrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: ctrig integer(kind=int64), intent(in), value :: isign interface function ctrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) interface subroutine rfft (len, lot, data, inc, jmp, rtrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: rtrig integer(kind=int64), intent(in), value :: isign interface function rtrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) Subroutines subroutine advance() Arguments None subroutine copy_n_s() Arguments None subroutine copy_s_n() Arguments None subroutine define_field() Arguments None subroutine define_kspace() Arguments None subroutine define_shifts() Arguments None subroutine define_step() Arguments None subroutine enforce_conjugate_symmetry() Arguments None subroutine phase1() Arguments None subroutine phase2() Arguments None subroutine phase3() Arguments None subroutine pressure() Arguments None subroutine remesh() Arguments None subroutine spectra() Arguments None subroutine transpose_X_Y() Arguments None subroutine transpose_Y_X() Arguments None Source Code subroutine solve_navier_stokes end subroutine solve_navier_stokes","tags":"","loc":"proc/solve_navier_stokes~3.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"subroutine solve_navier_stokes() Uses: run_size Arguments None Description * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * **) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * * ) * * * * * * * * * * * * * * * *) * * * * * * * * * * * * * * * *) Calls proc~~solve_navier_stokes~4~~CallsGraph proc~solve_navier_stokes~4 solve_navier_stokes none~ctrig~4 ctrig proc~solve_navier_stokes~4->none~ctrig~4 global_times global_times proc~solve_navier_stokes~4->global_times none~define_kspace~4 define_kspace proc~solve_navier_stokes~4->none~define_kspace~4 none~walltime~3 WALLTIME proc~solve_navier_stokes~4->none~walltime~3 none~transpose_x_y~4 transpose_X_Y proc~solve_navier_stokes~4->none~transpose_x_y~4 none~advance~4 advance proc~solve_navier_stokes~4->none~advance~4 none~define_field~4 define_field proc~solve_navier_stokes~4->none~define_field~4 none~copy_s_n~4 copy_s_n proc~solve_navier_stokes~4->none~copy_s_n~4 none~enforce_conjugate_symmetry~4 enforce_conjugate_symmetry proc~solve_navier_stokes~4->none~enforce_conjugate_symmetry~4 mpi_barrier mpi_barrier proc~solve_navier_stokes~4->mpi_barrier none~phase3~4 phase3 proc~solve_navier_stokes~4->none~phase3~4 none~pressure~4 pressure proc~solve_navier_stokes~4->none~pressure~4 none~copy_n_s~4 copy_n_s proc~solve_navier_stokes~4->none~copy_n_s~4 none~transpose_y_x~4 transpose_Y_X proc~solve_navier_stokes~4->none~transpose_y_x~4 none~define_shifts~4 define_shifts proc~solve_navier_stokes~4->none~define_shifts~4 none~phase2~4 phase2 proc~solve_navier_stokes~4->none~phase2~4 none~define_step~4 define_step proc~solve_navier_stokes~4->none~define_step~4 none~rtrig~4 rtrig proc~solve_navier_stokes~4->none~rtrig~4 none~phase1~4 phase1 proc~solve_navier_stokes~4->none~phase1~4 none~transpose_x_y~4->none~walltime~3 none~transpose_x_y~4->mpi_barrier mpi_wait mpi_wait none~transpose_x_y~4->mpi_wait mpi_send mpi_send none~transpose_x_y~4->mpi_send proc~copy3 copy3 none~transpose_x_y~4->proc~copy3 mpi_irecv mpi_irecv none~transpose_x_y~4->mpi_irecv proc~init_random_seed init_random_seed none~define_field~4->proc~init_random_seed none~cfft~4 cfft none~phase3~4->none~cfft~4 none~transpose_y_x~4->none~walltime~3 none~transpose_y_x~4->mpi_barrier none~transpose_y_x~4->mpi_wait none~transpose_y_x~4->mpi_send none~transpose_y_x~4->proc~copy3 none~transpose_y_x~4->mpi_irecv none~phase2~4->none~cfft~4 none~rfft~4 rfft none~phase2~4->none~rfft~4 none~define_step~4->none~walltime~3 none~define_step~4->mpi_barrier mpi_allreduce mpi_allreduce none~define_step~4->mpi_allreduce none~phase1~4->none~cfft~4 none~lcg lcg proc~init_random_seed->none~lcg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial complex, public, allocatable :: bufr (:) real, public :: k1 (nx/2) real, public :: k2 (ny) real, public :: k3 (nz) real, public :: kx (nx/2) real, public :: ky (nx/2,ny) real, public :: ky_ (nx/2,ny) real, public :: kz (nz) real, public :: mk1 (nx/2) real, public :: mk2 (ny) real, public :: mk3 (nz) integer(kind=int64), public :: msg_size integer(kind=int64), public :: nshells integer(kind=int64), public :: oflag integer(kind=int64), public :: rflag integer(kind=int64), public :: rkstep integer(kind=int64), public :: step integer(kind=int64), public :: stop complex, public :: sx (nx/2,3) complex, public :: sy (ny,3) complex, public :: sz (nz,3) integer(kind=int64), public :: trigx integer(kind=int64), public :: trigxy integer(kind=int64), public :: trigy integer(kind=int64), public :: trigz complex, public, allocatable :: u (:,:,:,:) complex, public, allocatable :: un (:,:,:,:) complex, public, allocatable :: ur (:,:,:,:) Interfaces interface function WALLTIME () bind(C, name = \"WALLTIME\") Arguments None Return Value real(kind=real64) interface subroutine cfft (len, lot, data, inc, jmp, ctrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: ctrig integer(kind=int64), intent(in), value :: isign interface function ctrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) interface subroutine rfft (len, lot, data, inc, jmp, rtrig, isign) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len integer(kind=int64), intent(in), value :: lot complex, intent(in), dimension(0:0) :: data integer(kind=int64), intent(in), value :: inc integer(kind=int64), intent(in), value :: jmp integer(kind=int64), intent(in), value :: rtrig integer(kind=int64), intent(in), value :: isign interface function rtrig (len) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), value :: len Return Value integer(kind=int64) Subroutines subroutine advance() Arguments None subroutine copy_n_s() Arguments None subroutine copy_s_n() Arguments None subroutine define_field() Arguments None subroutine define_kspace() Arguments None subroutine define_shifts() Arguments None subroutine define_step() Arguments None subroutine enforce_conjugate_symmetry() Arguments None subroutine phase1() Arguments None subroutine phase2() Arguments None subroutine phase3() Arguments None subroutine pressure() Arguments None subroutine remesh() Arguments None subroutine spectra() Arguments None subroutine transpose_X_Y() Arguments None subroutine transpose_Y_X() Arguments None Source Code subroutine solve_navier_stokes end subroutine solve_navier_stokes","tags":"","loc":"proc/solve_navier_stokes~4.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"private function gfc_descriptor_c_double(a) result(a_descriptor) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) Calls proc~~gfc_descriptor_c_double~~CallsGraph proc~gfc_descriptor_c_double gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gfc_descriptor_c_double~~CalledByGraph proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor gfc_descriptor interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~gfc_descriptor proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~gfc_descriptor proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~gfc_descriptor proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~gfc_descriptor proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~gfc_descriptor proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~gfc_descriptor proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~gfc_descriptor proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~gfc_descriptor proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~gfc_descriptor proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~gfc_descriptor proc~get_c_int get_c_int proc~get_c_int->interface~gfc_descriptor interface~co_max co_max interface~co_max->proc~co_max_c_int interface~co_max->proc~co_max_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int var panprocgfc_descriptor_c_doubleCalledByGraph = svgPanZoom('#procgfc_descriptor_c_doubleCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: i integer(kind=c_int), public, parameter :: scalar_offset = -1 integer(kind=c_int), public, parameter :: unit_stride = 1","tags":"","loc":"proc/gfc_descriptor_c_double.html","title":"gfc_descriptor_c_double – OpenCoarrays"},{"text":"private function gfc_descriptor_c_int(a) result(a_descriptor) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) Calls proc~~gfc_descriptor_c_int~~CallsGraph proc~gfc_descriptor_c_int gfc_descriptor_c_int proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gfc_descriptor_c_int~~CalledByGraph proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor gfc_descriptor interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~gfc_descriptor proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~gfc_descriptor proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~gfc_descriptor proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~gfc_descriptor proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~gfc_descriptor proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~gfc_descriptor proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~gfc_descriptor proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~gfc_descriptor proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~gfc_descriptor proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~gfc_descriptor proc~get_c_int get_c_int proc~get_c_int->interface~gfc_descriptor interface~co_max co_max interface~co_max->proc~co_max_c_int interface~co_max->proc~co_max_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int var panprocgfc_descriptor_c_intCalledByGraph = svgPanZoom('#procgfc_descriptor_c_intCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: i integer(kind=c_int), public, parameter :: scalar_offset = -1 integer(kind=c_int), public, parameter :: unit_stride = 1","tags":"","loc":"proc/gfc_descriptor_c_int.html","title":"gfc_descriptor_c_int – OpenCoarrays"},{"text":"private function gfc_descriptor_logical(a) result(a_descriptor) Arguments Type Intent Optional Attributes Name logical, intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) Calls proc~~gfc_descriptor_logical~~CallsGraph proc~gfc_descriptor_logical gfc_descriptor_logical proc~my_dtype my_dtype proc~gfc_descriptor_logical->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~gfc_descriptor_logical~~CalledByGraph proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor gfc_descriptor interface~gfc_descriptor->proc~gfc_descriptor_logical proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~gfc_descriptor proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~gfc_descriptor proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~gfc_descriptor proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~gfc_descriptor proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~gfc_descriptor proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~gfc_descriptor proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~gfc_descriptor proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~gfc_descriptor proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~gfc_descriptor proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~gfc_descriptor proc~get_c_int get_c_int proc~get_c_int->interface~gfc_descriptor interface~co_max co_max interface~co_max->proc~co_max_c_int interface~co_max->proc~co_max_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int var panprocgfc_descriptor_logicalCalledByGraph = svgPanZoom('#procgfc_descriptor_logicalCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: i integer(kind=c_int), public, parameter :: scalar_offset = -1 integer(kind=c_int), public, parameter :: unit_stride = 1 integer(kind=c_int), public, parameter :: words = 1","tags":"","loc":"proc/gfc_descriptor_logical.html","title":"gfc_descriptor_logical – OpenCoarrays"},{"text":"private function my_dtype(type_, kind_, rank_) result(dtype_) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: type_ integer(kind=c_int32_t), intent(in) :: kind_ integer(kind=c_int32_t), intent(in) :: rank_ Return Value integer(kind=c_int32_t) Called By proc~~my_dtype~~CalledByGraph proc~my_dtype my_dtype proc~gfc_descriptor_c_double gfc_descriptor_c_double proc~gfc_descriptor_c_double->proc~my_dtype proc~gfc_descriptor_logical gfc_descriptor_logical proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_int gfc_descriptor_c_int proc~gfc_descriptor_c_int->proc~my_dtype interface~gfc_descriptor gfc_descriptor interface~gfc_descriptor->proc~gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~gfc_descriptor proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~gfc_descriptor proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~gfc_descriptor proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~gfc_descriptor proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~gfc_descriptor proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~gfc_descriptor proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~gfc_descriptor proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~gfc_descriptor proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~gfc_descriptor proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~gfc_descriptor proc~get_c_int get_c_int proc~get_c_int->interface~gfc_descriptor interface~co_max co_max interface~co_max->proc~co_max_c_int interface~co_max->proc~co_max_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int var panprocmy_dtypeCalledByGraph = svgPanZoom('#procmy_dtypeCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: GFC_DTYPE_SIZE_SHIFT = 8 integer, public, parameter :: GFC_DTYPE_TYPE_SHIFT = 3","tags":"","loc":"proc/my_dtype.html","title":"my_dtype – OpenCoarrays"},{"text":"public function num_images() result(num_images_) Uses: mpi Arguments None Return Value integer(kind=c_int) Calls proc~~num_images~~CallsGraph proc~num_images num_images mpi_comm_size mpi_comm_size proc~num_images->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: ierr","tags":"","loc":"proc/num_images.html","title":"num_images – OpenCoarrays"},{"text":"public function this_image() result(image_num) Uses: mpi Arguments None Return Value integer(kind=c_int) Calls proc~~this_image~~CallsGraph proc~this_image this_image mpi_comm_rank mpi_comm_rank proc~this_image->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public :: ierr","tags":"","loc":"proc/this_image.html","title":"this_image – OpenCoarrays"},{"text":"private subroutine co_broadcast_c_char(a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(inout), volatile, target :: a integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_broadcast_c_char~~CallsGraph proc~co_broadcast_c_char co_broadcast_c_char proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int interface~opencoarrays_co_broadcast opencoarrays_co_broadcast proc~co_broadcast_c_int->interface~opencoarrays_co_broadcast interface~gfc_descriptor gfc_descriptor proc~co_broadcast_c_int->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype var panprocco_broadcast_c_charCallsGraph = svgPanZoom('#procco_broadcast_c_charCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_broadcast_c_char~~CalledByGraph proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_char Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), public, allocatable :: a_cast_to_integer_array (:)","tags":"","loc":"proc/co_broadcast_c_char.html","title":"co_broadcast_c_char – OpenCoarrays"},{"text":"private subroutine co_broadcast_c_double(a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_broadcast_c_double~~CallsGraph proc~co_broadcast_c_double co_broadcast_c_double interface~opencoarrays_co_broadcast opencoarrays_co_broadcast proc~co_broadcast_c_double->interface~opencoarrays_co_broadcast interface~gfc_descriptor gfc_descriptor proc~co_broadcast_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_broadcast_c_double~~CalledByGraph proc~co_broadcast_c_double co_broadcast_c_double interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_source_image = 0 integer(kind=c_int), public :: source_image_","tags":"","loc":"proc/co_broadcast_c_double.html","title":"co_broadcast_c_double – OpenCoarrays"},{"text":"private subroutine co_broadcast_c_int(a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_broadcast_c_int~~CallsGraph proc~co_broadcast_c_int co_broadcast_c_int interface~opencoarrays_co_broadcast opencoarrays_co_broadcast proc~co_broadcast_c_int->interface~opencoarrays_co_broadcast interface~gfc_descriptor gfc_descriptor proc~co_broadcast_c_int->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_broadcast_c_int~~CalledByGraph proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char proc~co_broadcast_c_char->proc~co_broadcast_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_int interface~co_broadcast->proc~co_broadcast_c_char Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_source_image = 0 integer(kind=c_int), public :: source_image_","tags":"","loc":"proc/co_broadcast_c_int.html","title":"co_broadcast_c_int – OpenCoarrays"},{"text":"private subroutine co_max_c_double(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_max_c_double~~CallsGraph proc~co_max_c_double co_max_c_double interface~gfc_descriptor gfc_descriptor proc~co_max_c_double->interface~gfc_descriptor interface~opencoarrays_co_max opencoarrays_co_max proc~co_max_c_double->interface~opencoarrays_co_max proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_max_c_double~~CalledByGraph proc~co_max_c_double co_max_c_double interface~co_max co_max interface~co_max->proc~co_max_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_ integer(kind=c_int), public :: unused","tags":"","loc":"proc/co_max_c_double.html","title":"co_max_c_double – OpenCoarrays"},{"text":"private subroutine co_max_c_int(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_max_c_int~~CallsGraph proc~co_max_c_int co_max_c_int interface~gfc_descriptor gfc_descriptor proc~co_max_c_int->interface~gfc_descriptor interface~opencoarrays_co_max opencoarrays_co_max proc~co_max_c_int->interface~opencoarrays_co_max proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_max_c_int~~CalledByGraph proc~co_max_c_int co_max_c_int interface~co_max co_max interface~co_max->proc~co_max_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_ integer(kind=c_int), public :: unused","tags":"","loc":"proc/co_max_c_int.html","title":"co_max_c_int – OpenCoarrays"},{"text":"private subroutine co_min_c_double(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_min_c_double~~CallsGraph proc~co_min_c_double co_min_c_double interface~opencoarrays_co_min opencoarrays_co_min proc~co_min_c_double->interface~opencoarrays_co_min interface~gfc_descriptor gfc_descriptor proc~co_min_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_min_c_double~~CalledByGraph proc~co_min_c_double co_min_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_ integer(kind=c_int), public :: unused","tags":"","loc":"proc/co_min_c_double.html","title":"co_min_c_double – OpenCoarrays"},{"text":"private subroutine co_min_c_int(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_min_c_int~~CallsGraph proc~co_min_c_int co_min_c_int interface~opencoarrays_co_min opencoarrays_co_min proc~co_min_c_int->interface~opencoarrays_co_min interface~gfc_descriptor gfc_descriptor proc~co_min_c_int->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_min_c_int~~CalledByGraph proc~co_min_c_int co_min_c_int interface~co_min co_min interface~co_min->proc~co_min_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_ integer(kind=c_int), public :: unused","tags":"","loc":"proc/co_min_c_int.html","title":"co_min_c_int – OpenCoarrays"},{"text":"private subroutine co_reduce_c_double(a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, contiguous :: a (..) procedure( c_double_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) Calls proc~~co_reduce_c_double~~CallsGraph proc~co_reduce_c_double co_reduce_c_double interface~opencoarrays_co_reduce opencoarrays_co_reduce proc~co_reduce_c_double->interface~opencoarrays_co_reduce interface~gfc_descriptor gfc_descriptor proc~co_reduce_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_reduce_c_double~~CalledByGraph proc~co_reduce_c_double co_reduce_c_double interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, volatile :: a_len_unused integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public, volatile :: errmsg_len integer(kind=c_int), public, volatile :: opr_flags_unused integer(kind=c_int), public :: result_image_","tags":"","loc":"proc/co_reduce_c_double.html","title":"co_reduce_c_double – OpenCoarrays"},{"text":"private subroutine co_reduce_c_int(a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, contiguous :: a (..) procedure( c_int_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) Calls proc~~co_reduce_c_int~~CallsGraph proc~co_reduce_c_int co_reduce_c_int interface~opencoarrays_co_reduce opencoarrays_co_reduce proc~co_reduce_c_int->interface~opencoarrays_co_reduce interface~gfc_descriptor gfc_descriptor proc~co_reduce_c_int->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_reduce_c_int~~CalledByGraph proc~co_reduce_c_int co_reduce_c_int interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, volatile :: a_len_unused integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public, volatile :: errmsg_len integer(kind=c_int), public, volatile :: opr_flags_unused integer(kind=c_int), public :: result_image_","tags":"","loc":"proc/co_reduce_c_int.html","title":"co_reduce_c_int – OpenCoarrays"},{"text":"private subroutine co_reduce_logical(a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name logical, intent(inout), volatile, contiguous :: a (..) procedure( logical_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) Calls proc~~co_reduce_logical~~CallsGraph proc~co_reduce_logical co_reduce_logical interface~opencoarrays_co_reduce opencoarrays_co_reduce proc~co_reduce_logical->interface~opencoarrays_co_reduce interface~gfc_descriptor gfc_descriptor proc~co_reduce_logical->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_reduce_logical~~CalledByGraph proc~co_reduce_logical co_reduce_logical interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_logical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, volatile :: a_len_unused integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public, volatile :: errmsg_len integer(kind=c_int), public, volatile :: opr_flags_unused integer(kind=c_int), public :: result_image_","tags":"","loc":"proc/co_reduce_logical.html","title":"co_reduce_logical – OpenCoarrays"},{"text":"private subroutine co_sum_c_double(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_sum_c_double~~CallsGraph proc~co_sum_c_double co_sum_c_double interface~gfc_descriptor gfc_descriptor proc~co_sum_c_double->interface~gfc_descriptor interface~opencoarrays_co_sum opencoarrays_co_sum proc~co_sum_c_double->interface~opencoarrays_co_sum proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_sum_c_double~~CalledByGraph proc~co_sum_c_double co_sum_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_","tags":"","loc":"proc/co_sum_c_double.html","title":"co_sum_c_double – OpenCoarrays"},{"text":"private subroutine co_sum_c_int(a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg Calls proc~~co_sum_c_int~~CallsGraph proc~co_sum_c_int co_sum_c_int interface~gfc_descriptor gfc_descriptor proc~co_sum_c_int->interface~gfc_descriptor interface~opencoarrays_co_sum opencoarrays_co_sum proc~co_sum_c_int->interface~opencoarrays_co_sum proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~co_sum_c_int~~CalledByGraph proc~co_sum_c_int co_sum_c_int interface~co_sum co_sum interface~co_sum->proc~co_sum_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target :: a_descriptor integer(kind=c_int), public, parameter :: default_result_image = 0 integer(kind=c_int), public :: result_image_","tags":"","loc":"proc/co_sum_c_int.html","title":"co_sum_c_int – OpenCoarrays"},{"text":"public subroutine error_stop(stop_code) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), optional :: stop_code Calls proc~~error_stop~~CallsGraph proc~error_stop error_stop interface~opencoarrays_error_stop opencoarrays_error_stop proc~error_stop->interface~opencoarrays_error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~error_stop~~CalledByGraph proc~error_stop error_stop proc~get_c_int get_c_int proc~get_c_int->proc~error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int32_t), public :: code integer(kind=c_int32_t), public, parameter :: default_code = -1_c_int32_t","tags":"","loc":"proc/error_stop.html","title":"error_stop – OpenCoarrays"},{"text":"private subroutine get_c_int(src, dest, image_index_, offset, mrt) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: src (..) integer(kind=c_int), intent(out), target, contiguous, volatile :: dest (..) integer(kind=c_int), intent(in) :: image_index_ integer(kind=c_ptrdiff_t), intent(in) :: offset logical(kind=c_bool), intent(in) :: mrt Calls proc~~get_c_int~~CallsGraph proc~get_c_int get_c_int interface~opencoarrays_get opencoarrays_get proc~get_c_int->interface~opencoarrays_get proc~error_stop error_stop proc~get_c_int->proc~error_stop interface~gfc_descriptor gfc_descriptor proc~get_c_int->interface~gfc_descriptor interface~opencoarrays_error_stop opencoarrays_error_stop proc~error_stop->interface~opencoarrays_error_stop proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( gfc_descriptor_t ), public, target, volatile :: dest_descriptor type( gfc_descriptor_t ), public, target :: src_descriptor type( caf_vector_t ), public :: src_vector_unused type(c_ptr), public :: token","tags":"","loc":"proc/get_c_int.html","title":"get_c_int – OpenCoarrays"},{"text":"public subroutine sync_all(stat, errmsg, unused) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out), optional :: stat character(len=c_char), intent(out), optional :: errmsg integer(kind=c_int), intent(out), optional :: unused Calls proc~~sync_all~~CallsGraph proc~sync_all sync_all interface~opencoarrays_sync_all opencoarrays_sync_all proc~sync_all->interface~opencoarrays_sync_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/sync_all.html","title":"sync_all – OpenCoarrays"},{"text":"public interface co_broadcast Calls interface~~co_broadcast~~CallsGraph interface~co_broadcast co_broadcast proc~co_broadcast_c_int co_broadcast_c_int interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char proc~co_broadcast_c_double co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_double interface~opencoarrays_co_broadcast opencoarrays_co_broadcast proc~co_broadcast_c_int->interface~opencoarrays_co_broadcast interface~gfc_descriptor gfc_descriptor proc~co_broadcast_c_int->interface~gfc_descriptor proc~co_broadcast_c_char->proc~co_broadcast_c_int proc~co_broadcast_c_double->interface~opencoarrays_co_broadcast proc~co_broadcast_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype var paninterfaceco_broadcastCallsGraph = svgPanZoom('#interfaceco_broadcastCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_broadcast_c_int (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_double (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_char (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(inout), volatile, target :: a integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg","tags":"","loc":"interface/co_broadcast.html","title":"co_broadcast – OpenCoarrays"},{"text":"public interface co_max Calls interface~~co_max~~CallsGraph interface~co_max co_max proc~co_max_c_int co_max_c_int interface~co_max->proc~co_max_c_int proc~co_max_c_double co_max_c_double interface~co_max->proc~co_max_c_double interface~gfc_descriptor gfc_descriptor proc~co_max_c_int->interface~gfc_descriptor interface~opencoarrays_co_max opencoarrays_co_max proc~co_max_c_int->interface~opencoarrays_co_max proc~co_max_c_double->interface~gfc_descriptor proc~co_max_c_double->interface~opencoarrays_co_max proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_max_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_max_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg","tags":"","loc":"interface/co_max.html","title":"co_max – OpenCoarrays"},{"text":"public interface co_min Calls interface~~co_min~~CallsGraph interface~co_min co_min proc~co_min_c_int co_min_c_int interface~co_min->proc~co_min_c_int proc~co_min_c_double co_min_c_double interface~co_min->proc~co_min_c_double interface~opencoarrays_co_min opencoarrays_co_min proc~co_min_c_int->interface~opencoarrays_co_min interface~gfc_descriptor gfc_descriptor proc~co_min_c_int->interface~gfc_descriptor proc~co_min_c_double->interface~opencoarrays_co_min proc~co_min_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_min_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_min_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg","tags":"","loc":"interface/co_min.html","title":"co_min – OpenCoarrays"},{"text":"public interface co_reduce Calls interface~~co_reduce~~CallsGraph interface~co_reduce co_reduce proc~co_reduce_c_int co_reduce_c_int interface~co_reduce->proc~co_reduce_c_int proc~co_reduce_logical co_reduce_logical interface~co_reduce->proc~co_reduce_logical proc~co_reduce_c_double co_reduce_c_double interface~co_reduce->proc~co_reduce_c_double interface~opencoarrays_co_reduce opencoarrays_co_reduce proc~co_reduce_c_int->interface~opencoarrays_co_reduce interface~gfc_descriptor gfc_descriptor proc~co_reduce_c_int->interface~gfc_descriptor proc~co_reduce_logical->interface~opencoarrays_co_reduce proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double->interface~opencoarrays_co_reduce proc~co_reduce_c_double->interface~gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_reduce_c_int (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, contiguous :: a (..) procedure( c_int_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_c_double (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, contiguous :: a (..) procedure( c_double_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_logical (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name logical, intent(inout), volatile, contiguous :: a (..) procedure( logical_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*)","tags":"","loc":"interface/co_reduce.html","title":"co_reduce – OpenCoarrays"},{"text":"public interface co_sum Calls interface~~co_sum~~CallsGraph interface~co_sum co_sum proc~co_sum_c_int co_sum_c_int interface~co_sum->proc~co_sum_c_int proc~co_sum_c_double co_sum_c_double interface~co_sum->proc~co_sum_c_double interface~gfc_descriptor gfc_descriptor proc~co_sum_c_int->interface~gfc_descriptor interface~opencoarrays_co_sum opencoarrays_co_sum proc~co_sum_c_int->interface~opencoarrays_co_sum proc~co_sum_c_double->interface~gfc_descriptor proc~co_sum_c_double->interface~opencoarrays_co_sum proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_sum_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_sum_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg","tags":"","loc":"interface/co_sum.html","title":"co_sum – OpenCoarrays"},{"text":"private interface gfc_descriptor Calls interface~~gfc_descriptor~~CallsGraph interface~gfc_descriptor gfc_descriptor proc~gfc_descriptor_c_int gfc_descriptor_c_int interface~gfc_descriptor->proc~gfc_descriptor_c_int proc~gfc_descriptor_logical gfc_descriptor_logical interface~gfc_descriptor->proc~gfc_descriptor_logical proc~gfc_descriptor_c_double gfc_descriptor_c_double interface~gfc_descriptor->proc~gfc_descriptor_c_double proc~my_dtype my_dtype proc~gfc_descriptor_c_int->proc~my_dtype proc~gfc_descriptor_logical->proc~my_dtype proc~gfc_descriptor_c_double->proc~my_dtype Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~gfc_descriptor~~CalledByGraph interface~gfc_descriptor gfc_descriptor proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~gfc_descriptor proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~gfc_descriptor proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~gfc_descriptor proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~gfc_descriptor proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~gfc_descriptor proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~gfc_descriptor proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~gfc_descriptor proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~gfc_descriptor proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~gfc_descriptor proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~gfc_descriptor proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~gfc_descriptor proc~get_c_int get_c_int proc~get_c_int->interface~gfc_descriptor interface~co_max co_max interface~co_max->proc~co_max_c_int interface~co_max->proc~co_max_c_double interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_int proc~co_broadcast_c_char co_broadcast_c_char interface~co_broadcast->proc~co_broadcast_c_char interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_int interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_double interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int proc~co_broadcast_c_char->proc~co_broadcast_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function gfc_descriptor_c_int (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_c_double (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_logical (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name logical, intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t )","tags":"","loc":"interface/gfc_descriptor.html","title":"gfc_descriptor – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_co_broadcast~~CalledByGraph interface~opencoarrays_co_broadcast opencoarrays_co_broadcast proc~co_broadcast_c_int co_broadcast_c_int proc~co_broadcast_c_int->interface~opencoarrays_co_broadcast proc~co_broadcast_c_double co_broadcast_c_double proc~co_broadcast_c_double->interface~opencoarrays_co_broadcast proc~co_broadcast_c_char co_broadcast_c_char proc~co_broadcast_c_char->proc~co_broadcast_c_int interface~co_broadcast co_broadcast interface~co_broadcast->proc~co_broadcast_c_int interface~co_broadcast->proc~co_broadcast_c_double interface~co_broadcast->proc~co_broadcast_c_char Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_co_broadcast(a, source_image, stat, errmsg, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: errmsg_len","tags":"","loc":"interface/opencoarrays_co_broadcast.html","title":"opencoarrays_co_broadcast – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_co_max~~CalledByGraph interface~opencoarrays_co_max opencoarrays_co_max proc~co_max_c_double co_max_c_double proc~co_max_c_double->interface~opencoarrays_co_max proc~co_max_c_int co_max_c_int proc~co_max_c_int->interface~opencoarrays_co_max interface~co_max co_max interface~co_max->proc~co_max_c_double interface~co_max->proc~co_max_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_co_max(a, result_image, stat, errmsg, unused, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: unused integer(kind=c_int), intent(in), value :: errmsg_len","tags":"","loc":"interface/opencoarrays_co_max.html","title":"opencoarrays_co_max – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_co_min~~CalledByGraph interface~opencoarrays_co_min opencoarrays_co_min proc~co_min_c_double co_min_c_double proc~co_min_c_double->interface~opencoarrays_co_min proc~co_min_c_int co_min_c_int proc~co_min_c_int->interface~opencoarrays_co_min interface~co_min co_min interface~co_min->proc~co_min_c_double interface~co_min->proc~co_min_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_co_min(a, result_image, stat, errmsg, unused, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) integer(kind=c_int), intent(in), value :: unused integer(kind=c_int), intent(in), value :: errmsg_len","tags":"","loc":"interface/opencoarrays_co_min.html","title":"opencoarrays_co_min – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_co_reduce~~CalledByGraph interface~opencoarrays_co_reduce opencoarrays_co_reduce proc~co_reduce_c_double co_reduce_c_double proc~co_reduce_c_double->interface~opencoarrays_co_reduce proc~co_reduce_logical co_reduce_logical proc~co_reduce_logical->interface~opencoarrays_co_reduce proc~co_reduce_c_int co_reduce_c_int proc~co_reduce_c_int->interface~opencoarrays_co_reduce interface~co_reduce co_reduce interface~co_reduce->proc~co_reduce_c_double interface~co_reduce->proc~co_reduce_logical interface~co_reduce->proc~co_reduce_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_co_reduce(a, opr, opr_flags, result_image, stat, errmsg, a_len, errmsg_len) bind(C,name=\"0\") Uses: iso_c_binding Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a type(c_funptr), intent(in), value :: opr integer(kind=c_int), intent(in), value :: opr_flags integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out) :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) integer(kind=c_int), intent(in), value :: a_len integer(kind=c_int), intent(in), value :: errmsg_len","tags":"","loc":"interface/opencoarrays_co_reduce.html","title":"opencoarrays_co_reduce – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_co_sum~~CalledByGraph interface~opencoarrays_co_sum opencoarrays_co_sum proc~co_sum_c_double co_sum_c_double proc~co_sum_c_double->interface~opencoarrays_co_sum proc~co_sum_c_int co_sum_c_int proc~co_sum_c_int->interface~opencoarrays_co_sum interface~co_sum co_sum interface~co_sum->proc~co_sum_c_double interface~co_sum->proc~co_sum_c_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_co_sum(a, result_image, stat, errmsg, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: errmsg_len","tags":"","loc":"interface/opencoarrays_co_sum.html","title":"opencoarrays_co_sum – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_error_stop~~CalledByGraph interface~opencoarrays_error_stop opencoarrays_error_stop proc~error_stop error_stop proc~error_stop->interface~opencoarrays_error_stop proc~get_c_int get_c_int proc~get_c_int->proc~error_stop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_error_stop(stop_code) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: stop_code","tags":"","loc":"interface/opencoarrays_error_stop.html","title":"opencoarrays_error_stop – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_get~~CalledByGraph interface~opencoarrays_get opencoarrays_get proc~get_c_int get_c_int proc~get_c_int->interface~opencoarrays_get Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_get(token, offset, image_index_, src, src_vector_unused, dest, src_kind, dst_kind, mrt) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), , value :: token integer(kind=c_ptrdiff_t), , value :: offset integer(kind=c_int), , value :: image_index_ type( gfc_descriptor_t ) :: src type( caf_vector_t ) :: src_vector_unused type( gfc_descriptor_t ) :: dest integer(kind=c_int), , value :: src_kind integer(kind=c_int), , value :: dst_kind logical(kind=c_bool), , value :: mrt","tags":"","loc":"interface/opencoarrays_get.html","title":"opencoarrays_get – OpenCoarrays"},{"text":"interface private function opencoarrays_num_images(coarray, dim_) result(num_images_) bind(C,name=\"_gfortran_caf_num_images\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: coarray integer(kind=c_int), intent(in), value :: dim_ Return Value integer(kind=c_int)","tags":"","loc":"interface/opencoarrays_num_images.html","title":"opencoarrays_num_images – OpenCoarrays"},{"text":"interface Called By interface~~opencoarrays_sync_all~~CalledByGraph interface~opencoarrays_sync_all opencoarrays_sync_all proc~sync_all sync_all proc~sync_all->interface~opencoarrays_sync_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private subroutine opencoarrays_sync_all(stat, errmsg, unused) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: stat character(len=c_char), intent(out) :: errmsg (*) integer(kind=c_int), intent(out) :: unused","tags":"","loc":"interface/opencoarrays_sync_all.html","title":"opencoarrays_sync_all – OpenCoarrays"},{"text":"interface private function opencoarrays_this_image(coarray) result(image_num) bind(C,name=\"_gfortran_caf_this_image\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: coarray Return Value integer(kind=c_int)","tags":"","loc":"interface/opencoarrays_this_image.html","title":"opencoarrays_this_image – OpenCoarrays"},{"text":"public subroutine broadcast_int(variable) Arguments Type Intent Optional Attributes Name integer(kind=int64), , codimension[*] :: variable Called By proc~~broadcast_int~~CalledByGraph proc~broadcast_int broadcast_int program~coarray_distributed_transpose coarray_distributed_transpose program~coarray_distributed_transpose->proc~broadcast_int Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i Source Code subroutine broadcast_int ( variable ) integer ( int64 ), codimension [ * ] :: variable integer ( int64 ) :: i if ( my_node == 1 ) then do i = 2 , num_nodes ; variable [ i ] = variable ; end do end if end subroutine broadcast_int","tags":"","loc":"proc/broadcast_int.html","title":"broadcast_int – OpenCoarrays"},{"text":"public subroutine copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Called By proc~~copy3~~CalledByGraph proc~copy3 copy3 none~transpose_x_y~3 transpose_X_Y none~transpose_x_y~3->proc~copy3 proc~transpose_y_x transpose_Y_X proc~transpose_y_x->proc~copy3 none~transpose_x_y transpose_X_Y none~transpose_x_y->proc~copy3 none~transpose_y_x~3 transpose_Y_X none~transpose_y_x~3->proc~copy3 none~transpose_x_y~4 transpose_X_Y none~transpose_x_y~4->proc~copy3 none~transpose_y_x~4 transpose_Y_X none~transpose_y_x~4->proc~copy3 none~transpose_x_y~2 transpose_X_Y none~transpose_x_y~2->proc~copy3 none~transpose_y_x~2 transpose_Y_X none~transpose_y_x~2->proc~copy3 none~transpose_y_x transpose_Y_X none~transpose_y_x->proc~copy3 proc~transpose_x_y transpose_X_Y proc~transpose_x_y->proc~copy3 proc~solve_navier_stokes~3 solve_navier_stokes proc~solve_navier_stokes~3->none~transpose_x_y~3 proc~solve_navier_stokes~3->none~transpose_y_x~3 program~coarray_distributed_transpose coarray_distributed_transpose program~coarray_distributed_transpose->proc~transpose_y_x program~coarray_distributed_transpose->proc~transpose_x_y proc~solve_navier_stokes solve_navier_stokes proc~solve_navier_stokes->none~transpose_x_y proc~solve_navier_stokes->none~transpose_y_x proc~solve_navier_stokes~4 solve_navier_stokes proc~solve_navier_stokes~4->none~transpose_x_y~4 proc~solve_navier_stokes~4->none~transpose_y_x~4 proc~solve_navier_stokes~2 solve_navier_stokes proc~solve_navier_stokes~2->none~transpose_x_y~2 proc~solve_navier_stokes~2->none~transpose_y_x~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3","tags":"","loc":"proc/copy3.html","title":"copy3 – OpenCoarrays"},{"text":"subroutine transpose_X_Y() Uses: run_size Arguments None Calls proc~~transpose_x_y~~CallsGraph proc~transpose_x_y transpose_X_Y walltime walltime proc~transpose_x_y->walltime proc~copy3 copy3 proc~transpose_x_y->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~transpose_x_y~~CalledByGraph proc~transpose_x_y transpose_X_Y program~coarray_distributed_transpose coarray_distributed_transpose program~coarray_distributed_transpose->proc~transpose_x_y Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: stage Source Code subroutine transpose_X_Y use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ), bufr_Y_X & !-- intra-node transpose to buffer , nz * 3 , 1 _ 8 , 1 _ 8 & , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] = bufr_Y_X (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_X_Y","tags":"","loc":"proc/transpose_x_y.html","title":"transpose_X_Y – OpenCoarrays"},{"text":"subroutine transpose_Y_X() Uses: run_size Arguments None Calls proc~~transpose_y_x~~CallsGraph proc~transpose_y_x transpose_Y_X walltime walltime proc~transpose_y_x->walltime proc~copy3 copy3 proc~transpose_y_x->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~transpose_y_x~~CalledByGraph proc~transpose_y_x transpose_Y_X program~coarray_distributed_transpose coarray_distributed_transpose program~coarray_distributed_transpose->proc~transpose_y_x Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: stage Source Code subroutine transpose_Y_X use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ), bufr_X_Y & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] = bufr_X_Y (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_Y_X","tags":"","loc":"proc/transpose_y_x.html","title":"transpose_Y_X – OpenCoarrays"},{"text":"private pure function add_local_field(lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/add_local_field.html","title":"add_local_field – OpenCoarrays"},{"text":"private function grid_spacing() result(delta_x) Arguments None Return Value real(kind=real64) Calls proc~~grid_spacing~~CallsGraph proc~grid_spacing grid_spacing interface~assert assert proc~grid_spacing->interface~assert interface~error_message error_message proc~grid_spacing->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/grid_spacing.html","title":"grid_spacing – OpenCoarrays"},{"text":"private pure function multiply(lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs class( global_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/multiply.html","title":"multiply – OpenCoarrays"},{"text":"private pure function state(this) result(local_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:)","tags":"","loc":"proc/state.html","title":"state – OpenCoarrays"},{"text":"private pure function x(this) result(this_x) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field ) Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: left_neighbor real(kind=real64), public :: local_this_x (num_local_points) integer(kind=int64), public :: right_neighbor","tags":"","loc":"proc/x.html","title":"x – OpenCoarrays"},{"text":"private function xx(this) result(this_xx) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field ) Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: left_neighbor real(kind=real64), public :: local_this_xx (num_local_points) integer(kind=int64), public :: right_neighbor","tags":"","loc":"proc/xx.html","title":"xx – OpenCoarrays"},{"text":"private subroutine assign_local_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs Calls proc~~assign_local_field~~CallsGraph proc~assign_local_field assign_local_field proc~synchronize synchronize proc~assign_local_field->proc~synchronize interface~assert assert proc~assign_local_field->interface~assert interface~error_message error_message proc~assign_local_field->interface~error_message images images proc~synchronize->images proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=real64), public, allocatable :: values (:)","tags":"","loc":"proc/assign_local_field.html","title":"assign_local_field – OpenCoarrays"},{"text":"private subroutine output(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~output~~CallsGraph proc~output output interface~assert assert proc~output->interface~assert interface~error_message error_message proc~output->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i","tags":"","loc":"proc/output.html","title":"output – OpenCoarrays"},{"text":"private subroutine set(this, initial_function, num_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this procedure( initial_condition ), , pointer :: initial_function integer, intent(in) :: num_points Calls proc~~set~~CallsGraph proc~set set proc~synchronize synchronize proc~set->proc~synchronize interface~assert assert proc~set->interface~assert interface~error_message error_message proc~set->interface~error_message images images proc~synchronize->images proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i real(kind=real64), public, allocatable :: local_grid (:) integer(kind=int64), public :: num_intervals real(kind=real64), public, parameter :: two_pi = 2.*3.1415926535897932384626433832795028842_real64","tags":"","loc":"proc/set.html","title":"set – OpenCoarrays"},{"text":"private subroutine synchronize() Arguments None Calls proc~~synchronize~~CallsGraph proc~synchronize synchronize images images proc~synchronize->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~synchronize~~CalledByGraph proc~synchronize synchronize proc~set set proc~set->proc~synchronize proc~assign_local_field assign_local_field proc~assign_local_field->proc~synchronize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/synchronize.html","title":"synchronize – OpenCoarrays"},{"text":"private pure function multiply(lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/multiply~2.html","title":"multiply – OpenCoarrays"},{"text":"private pure function state(this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:)","tags":"","loc":"proc/state~2.html","title":"state – OpenCoarrays"},{"text":"private pure function subtract(lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/subtract.html","title":"subtract – OpenCoarrays"},{"text":"private pure subroutine assign_array(lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real(kind=real64), intent(in) :: rhs (:)","tags":"","loc":"proc/assign_array.html","title":"assign_array – OpenCoarrays"},{"text":"private subroutine output(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~output~2~~CallsGraph proc~output~2 output interface~assert assert proc~output~2->interface~assert interface~error_message error_message proc~output~2->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i","tags":"","loc":"proc/output~2.html","title":"output – OpenCoarrays"},{"text":"pure function diffusion_stability_limit(diffusivity, delta_x, order_of_accuracy) result(stable_time_step) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: diffusivity real(kind=real64), intent(in) :: delta_x integer, intent(in) :: order_of_accuracy Return Value real(kind=real64) Called By proc~~diffusion_stability_limit~~CalledByGraph proc~diffusion_stability_limit diffusion_stability_limit program~main main program~main->proc~diffusion_stability_limit Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter, dimension(*) :: stability_limit = [2., 2., 2.5, 2.79]","tags":"","loc":"proc/diffusion_stability_limit.html","title":"diffusion_stability_limit – OpenCoarrays"},{"text":"function sinusoid(u_solution) result(is_sinusoid) Arguments Type Intent Optional Attributes Name type( global_field ), intent(in) :: u_solution Return Value logical Calls proc~~sinusoid~~CallsGraph proc~sinusoid sinusoid interface~assert assert proc~sinusoid->interface~assert interface~error_message error_message proc~sinusoid->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~sinusoid~~CalledByGraph proc~sinusoid sinusoid proc~test test proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: cap = 0.001 real(kind=real64), public, parameter :: threshold = -0.001 type( global_field ), public :: u_xx real(kind=real64), public, allocatable :: u_xx_state (:)","tags":"","loc":"proc/sinusoid.html","title":"sinusoid – OpenCoarrays"},{"text":"pure function ten_sin(x) result(ten_sin_x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","loc":"proc/ten_sin.html","title":"ten_sin – OpenCoarrays"},{"text":"subroutine test(burgers_solution) Arguments Type Intent Optional Attributes Name type( global_field ), intent(in) :: burgers_solution Calls proc~~test~~CallsGraph proc~test test proc~sinusoid sinusoid proc~test->proc~sinusoid interface~assert assert proc~test->interface~assert interface~error_message error_message proc~test->interface~error_message proc~sinusoid->interface~assert proc~sinusoid->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~test~~CalledByGraph proc~test test program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/test.html","title":"test – OpenCoarrays"},{"text":"private function new_message(message, message_data) Uses: object_interface Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Called By proc~~new_message~~CalledByGraph proc~new_message new_message interface~error_message error_message interface~error_message->proc~new_message proc~grid_spacing grid_spacing proc~grid_spacing->interface~error_message proc~output~3 output proc~output~3->interface~error_message proc~sinusoid sinusoid proc~sinusoid->interface~error_message proc~output~4 output proc~output~4->interface~error_message proc~set set proc~set->interface~error_message proc~construct construct proc~construct->interface~error_message proc~output~2 output proc~output~2->interface~error_message proc~assign_local_field assign_local_field proc~assign_local_field->interface~error_message proc~oned_message oned_message proc~oned_message->interface~error_message proc~assign_field assign_field proc~assign_field->interface~error_message proc~output output proc~output->interface~error_message proc~test test proc~test->interface~error_message proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/new_message.html","title":"new_message – OpenCoarrays"},{"text":"public subroutine assert_identical(integers) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: integers Called By proc~~assert_identical~~CalledByGraph proc~assert_identical assert_identical proc~vector_assert vector_assert proc~vector_assert->proc~assert_identical interface~assert assert interface~assert->proc~vector_assert proc~grid_spacing grid_spacing proc~grid_spacing->interface~assert proc~output~3 output proc~output~3->interface~assert proc~sinusoid sinusoid proc~sinusoid->interface~assert proc~output~4 output proc~output~4->interface~assert proc~set set proc~set->interface~assert proc~construct construct proc~construct->interface~assert proc~output~2 output proc~output~2->interface~assert proc~assign_local_field assign_local_field proc~assign_local_field->interface~assert proc~oned_message oned_message proc~oned_message->interface~assert proc~assign_field assign_field proc~assign_field->interface~assert proc~output output proc~output->interface~assert proc~test test proc~test->interface~assert proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: any_mismatches integer, public :: i","tags":"","loc":"proc/assert_identical.html","title":"assert_identical – OpenCoarrays"},{"text":"private subroutine scalar_assert(assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message Called By proc~~scalar_assert~~CalledByGraph proc~scalar_assert scalar_assert interface~assert assert interface~assert->proc~scalar_assert proc~grid_spacing grid_spacing proc~grid_spacing->interface~assert proc~output~3 output proc~output~3->interface~assert proc~sinusoid sinusoid proc~sinusoid->interface~assert proc~output~4 output proc~output~4->interface~assert proc~set set proc~set->interface~assert proc~construct construct proc~construct->interface~assert proc~output~2 output proc~output~2->interface~assert proc~assign_local_field assign_local_field proc~assign_local_field->interface~assert proc~oned_message oned_message proc~oned_message->interface~assert proc~assign_field assign_field proc~assign_field->interface~assert proc~output output proc~output->interface~assert proc~test test proc~test->interface~assert proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=132), public :: io_message integer, public :: io_status","tags":"","loc":"proc/scalar_assert.html","title":"scalar_assert – OpenCoarrays"},{"text":"private subroutine vector_assert(assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text Calls proc~~vector_assert~~CallsGraph proc~vector_assert vector_assert proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~vector_assert~~CalledByGraph proc~vector_assert vector_assert interface~assert assert interface~assert->proc~vector_assert proc~grid_spacing grid_spacing proc~grid_spacing->interface~assert proc~output~3 output proc~output~3->interface~assert proc~sinusoid sinusoid proc~sinusoid->interface~assert proc~output~4 output proc~output~4->interface~assert proc~set set proc~set->interface~assert proc~construct construct proc~construct->interface~assert proc~output~2 output proc~output~2->interface~assert proc~assign_local_field assign_local_field proc~assign_local_field->interface~assert proc~oned_message oned_message proc~oned_message->interface~assert proc~assign_field assign_field proc~assign_field->interface~assert proc~output output proc~output->interface~assert proc~test test proc~test->interface~assert proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: any_failures integer, public :: i","tags":"","loc":"proc/vector_assert.html","title":"vector_assert – OpenCoarrays"},{"text":"public interface assert Calls interface~~assert~~CallsGraph interface~assert assert proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~assert~~CalledByGraph interface~assert assert proc~grid_spacing grid_spacing proc~grid_spacing->interface~assert proc~output~3 output proc~output~3->interface~assert proc~sinusoid sinusoid proc~sinusoid->interface~assert proc~output~4 output proc~output~4->interface~assert proc~set set proc~set->interface~assert proc~construct construct proc~construct->interface~assert proc~output~2 output proc~output~2->interface~assert proc~assign_local_field assign_local_field proc~assign_local_field->interface~assert proc~oned_message oned_message proc~oned_message->interface~assert proc~assign_field assign_field proc~assign_field->interface~assert proc~output output proc~output->interface~assert proc~test test proc~test->interface~assert proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text","tags":"","loc":"interface/assert.html","title":"assert – OpenCoarrays"},{"text":"public interface error_message @cond Interface Calls interface~~error_message~~CallsGraph interface~error_message error_message proc~new_message new_message interface~error_message->proc~new_message Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~error_message~~CalledByGraph interface~error_message error_message proc~grid_spacing grid_spacing proc~grid_spacing->interface~error_message proc~output~3 output proc~output~3->interface~error_message proc~sinusoid sinusoid proc~sinusoid->interface~error_message proc~output~4 output proc~output~4->interface~error_message proc~set set proc~set->interface~error_message proc~construct construct proc~construct->interface~error_message proc~output~2 output proc~output~2->interface~error_message proc~assign_local_field assign_local_field proc~assign_local_field->interface~error_message proc~oned_message oned_message proc~oned_message->interface~error_message proc~assign_field assign_field proc~assign_field->interface~error_message proc~output output proc~output->interface~error_message proc~test test proc~test->interface~error_message proc~test->proc~sinusoid program~main main program~main->proc~test Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message )","tags":"","loc":"interface/error_message.html","title":"error_message – OpenCoarrays"},{"text":"private function error_code(this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer","tags":"","loc":"proc/error_code.html","title":"error_code – OpenCoarrays"},{"text":"private function error_message(this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value character(len=:),\n  allocatable","tags":"","loc":"proc/error_message.html","title":"error_message – OpenCoarrays"},{"text":"private subroutine define_error(this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:)","tags":"","loc":"proc/define_error.html","title":"define_error – OpenCoarrays"},{"text":"private pure function user_defined(this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"proc/user_defined.html","title":"user_defined – OpenCoarrays"},{"text":"private pure subroutine mark_as_defined(this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this","tags":"","loc":"proc/mark_as_defined.html","title":"mark_as_defined – OpenCoarrays"},{"text":"private pure function user_defined(this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical","tags":"","loc":"proc/user_defined~2.html","title":"user_defined – OpenCoarrays"},{"text":"private pure subroutine mark_as_defined(this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this","tags":"","loc":"proc/mark_as_defined~2.html","title":"mark_as_defined – OpenCoarrays"},{"text":"private pure function add_local_field(lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/add_local_field~2.html","title":"add_local_field – OpenCoarrays"},{"text":"private pure function laplacian(rhs) result(laplacian_rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: rhs Return Value type( local_field ) Variables Type Visibility Attributes Name Initial integer, public :: i real, public :: local_laplacian (num_local_points)","tags":"","loc":"proc/laplacian.html","title":"laplacian – OpenCoarrays"},{"text":"private pure function state(this) result(this_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real\n  (size(this%values(:)))","tags":"","loc":"proc/state~3.html","title":"state – OpenCoarrays"},{"text":"private subroutine assign_local_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs Calls proc~~assign_local_field~2~~CallsGraph proc~assign_local_field~2 assign_local_field proc~synchronize~2 synchronize proc~assign_local_field~2->proc~synchronize~2 images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/assign_local_field~2.html","title":"assign_local_field – OpenCoarrays"},{"text":"private subroutine only_allocate(this) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this","tags":"","loc":"proc/only_allocate.html","title":"only_allocate – OpenCoarrays"},{"text":"private subroutine set(this, internal_values, boundary_values, domain, num_global_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this real, intent(in) :: internal_values real, intent(in) :: boundary_values (num_end_points) real, intent(in) :: domain (num_end_points) integer, intent(in) :: num_global_points Calls proc~~set~2~~CallsGraph proc~set~2 set proc~synchronize~2 synchronize proc~set~2->proc~synchronize~2 images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/set~2.html","title":"set – OpenCoarrays"},{"text":"private subroutine synchronize() Arguments None Calls proc~~synchronize~2~~CallsGraph proc~synchronize~2 synchronize images images proc~synchronize~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~synchronize~2~~CalledByGraph proc~synchronize~2 synchronize proc~assign_local_field~2 assign_local_field proc~assign_local_field~2->proc~synchronize~2 proc~set~2 set proc~set~2->proc~synchronize~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/synchronize~2.html","title":"synchronize – OpenCoarrays"},{"text":"private pure function multiply(lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs real, intent(in) :: rhs Return Value type( local_field )","tags":"","loc":"proc/multiply~3.html","title":"multiply – OpenCoarrays"},{"text":"private pure function state(this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real\n  (size(this%values))","tags":"","loc":"proc/state~4.html","title":"state – OpenCoarrays"},{"text":"private pure subroutine assign_array(lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real, intent(in) :: rhs (:)","tags":"","loc":"proc/assign_array~2.html","title":"assign_array – OpenCoarrays"},{"text":"private function new_message(message, message_data) Uses: object_interface Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Called By proc~~new_message~2~~CalledByGraph proc~new_message~2 new_message interface~error_message~2 error_message interface~error_message~2->proc~new_message~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/new_message~2.html","title":"new_message – OpenCoarrays"},{"text":"public subroutine assert_identical(integers) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: integers Called By proc~~assert_identical~2~~CalledByGraph proc~assert_identical~2 assert_identical proc~vector_assert~2 vector_assert proc~vector_assert~2->proc~assert_identical~2 interface~assert~2 assert interface~assert~2->proc~vector_assert~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: any_mismatches integer, public :: i","tags":"","loc":"proc/assert_identical~2.html","title":"assert_identical – OpenCoarrays"},{"text":"private subroutine scalar_assert(assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message Called By proc~~scalar_assert~2~~CalledByGraph proc~scalar_assert~2 scalar_assert interface~assert~2 assert interface~assert~2->proc~scalar_assert~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=132), public :: io_message integer, public :: io_status","tags":"","loc":"proc/scalar_assert~2.html","title":"scalar_assert – OpenCoarrays"},{"text":"private subroutine vector_assert(assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text Calls proc~~vector_assert~2~~CallsGraph proc~vector_assert~2 vector_assert proc~assert_identical~2 assert_identical proc~vector_assert~2->proc~assert_identical~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~vector_assert~2~~CalledByGraph proc~vector_assert~2 vector_assert interface~assert~2 assert interface~assert~2->proc~vector_assert~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: any_failures integer, public :: i","tags":"","loc":"proc/vector_assert~2.html","title":"vector_assert – OpenCoarrays"},{"text":"public interface assert Calls interface~~assert~2~~CallsGraph interface~assert~2 assert proc~scalar_assert~2 scalar_assert interface~assert~2->proc~scalar_assert~2 proc~vector_assert~2 vector_assert interface~assert~2->proc~vector_assert~2 proc~assert_identical~2 assert_identical proc~vector_assert~2->proc~assert_identical~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text","tags":"","loc":"interface/assert~2.html","title":"assert – OpenCoarrays"},{"text":"public interface error_message @cond Interface Calls interface~~error_message~2~~CallsGraph interface~error_message~2 error_message proc~new_message~2 new_message interface~error_message~2->proc~new_message~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message )","tags":"","loc":"interface/error_message~2.html","title":"error_message – OpenCoarrays"},{"text":"private function error_code(this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer","tags":"","loc":"proc/error_code~2.html","title":"error_code – OpenCoarrays"},{"text":"private function error_message(this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value character(len=:),\n  allocatable","tags":"","loc":"proc/error_message~2.html","title":"error_message – OpenCoarrays"},{"text":"private subroutine define_error(this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:)","tags":"","loc":"proc/define_error~2.html","title":"define_error – OpenCoarrays"},{"text":"private pure function user_defined(this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical","tags":"","loc":"proc/user_defined~3.html","title":"user_defined – OpenCoarrays"},{"text":"private pure subroutine mark_as_defined(this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this","tags":"","loc":"proc/mark_as_defined~3.html","title":"mark_as_defined – OpenCoarrays"},{"text":"private pure function user_defined(this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical","tags":"","loc":"proc/user_defined~4.html","title":"user_defined – OpenCoarrays"},{"text":"private pure subroutine mark_as_defined(this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this","tags":"","loc":"proc/mark_as_defined~4.html","title":"mark_as_defined – OpenCoarrays"},{"text":"public function get_keyword_values(keys, default_values) result(actual_values) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: keys character(len=*), intent(in), dimension(:) :: default_values Return Value character(len=:),\n  dimension(:),allocatable Calls proc~~get_keyword_values~~CallsGraph proc~get_keyword_values get_keyword_values proc~assert assert proc~get_keyword_values->proc~assert none~max_argument_length max_argument_length proc~get_keyword_values->none~max_argument_length none~check check proc~get_keyword_values->none~check none~max_argument_length->none~check none~check->none~max_argument_length Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: divider = \"=\" integer, public :: divider_position integer, public :: error_flag integer, public :: i integer, public :: j character(len=:), public, allocatable :: key_value_pair character(len=:), public, allocatable :: trimmed_argument character(len=:), public, allocatable :: trimmed_value Functions function max_argument_length() Arguments None Return Value integer Subroutines subroutine check(flag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: flag","tags":"","loc":"proc/get_keyword_values.html","title":"get_keyword_values – OpenCoarrays"},{"text":"private subroutine assert(test_passes) Arguments Type Intent Optional Attributes Name logical, intent(in) :: test_passes Called By proc~~assert~~CalledByGraph proc~assert assert proc~get_keyword_values get_keyword_values proc~get_keyword_values->proc~assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/assert.html","title":"assert – OpenCoarrays"},{"text":"public subroutine init_random_seed() Uses: iso_fortran_env Arguments None Calls proc~~init_random_seed~~CallsGraph proc~init_random_seed init_random_seed none~lcg lcg proc~init_random_seed->none~lcg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~init_random_seed~~CalledByGraph proc~init_random_seed init_random_seed none~define_field define_field none~define_field->proc~init_random_seed none~define_field~4 define_field none~define_field~4->proc~init_random_seed none~define_field~3 define_field none~define_field~3->proc~init_random_seed none~define_field~2 define_field none~define_field~2->proc~init_random_seed proc~solve_navier_stokes solve_navier_stokes proc~solve_navier_stokes->none~define_field proc~solve_navier_stokes~4 solve_navier_stokes proc~solve_navier_stokes~4->none~define_field~4 proc~solve_navier_stokes~3 solve_navier_stokes proc~solve_navier_stokes~3->none~define_field~3 proc~solve_navier_stokes~2 solve_navier_stokes proc~solve_navier_stokes~2->none~define_field~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dt (8) integer, public :: i integer, public :: istat integer, public :: n integer, public :: pid integer, public, allocatable :: seed (:) integer(kind=int64), public :: t integer, public :: un Functions function lcg(s) Arguments Type Intent Optional Attributes Name integer(kind=int64) :: s Return Value integer Source Code subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed","tags":"","loc":"proc/init_random_seed.html","title":"init_random_seed – OpenCoarrays"},{"text":"public subroutine copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3","tags":"","loc":"proc/copy3~2.html","title":"copy3 – OpenCoarrays"},{"text":"public subroutine global_times() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: stage Source Code subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times","tags":"","loc":"proc/global_times.html","title":"global_times – OpenCoarrays"},{"text":"public subroutine max_velmax() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i Source Code subroutine max_velmax () integer ( int64 ) :: i sync all if ( my_node == 1 ) then do i = 2 , num_nodes ; velmax = max ( velmax , velmax [ i ] ); end do end if sync all if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax","tags":"","loc":"proc/max_velmax.html","title":"max_velmax – OpenCoarrays"},{"text":"interface Called By interface~~solve_navier_stokes~~CalledByGraph interface~solve_navier_stokes solve_navier_stokes program~cshear cshear program~cshear->interface~solve_navier_stokes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine solve_navier_stokes() Arguments None","tags":"","loc":"interface/solve_navier_stokes.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"public subroutine init_random_seed() Uses: iso_fortran_env Arguments None Calls proc~~init_random_seed~2~~CallsGraph proc~init_random_seed~2 init_random_seed none~lcg~2 lcg proc~init_random_seed~2->none~lcg~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dt (8) integer, public :: i integer, public :: istat integer, public :: n integer, public :: pid integer, public, allocatable :: seed (:) integer(kind=int64), public :: t integer, public :: un Functions function lcg(s) Arguments Type Intent Optional Attributes Name integer(kind=int64) :: s Return Value integer Source Code subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed","tags":"","loc":"proc/init_random_seed~2.html","title":"init_random_seed – OpenCoarrays"},{"text":"public subroutine copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3","tags":"","loc":"proc/copy3~3.html","title":"copy3 – OpenCoarrays"},{"text":"public subroutine global_times() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: stage Source Code subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time_ max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time_ min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time_ [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time_ [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times","tags":"","loc":"proc/global_times~2.html","title":"global_times – OpenCoarrays"},{"text":"public subroutine max_velmax() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i Source Code subroutine max_velmax () integer ( int64 ) :: i ! sync all ! if( my_node == 1) then !     do i = 2, num_nodes;     velmax = max( velmax, velmax[i] );    end do ! end if ! sync all call co_max ( velmax , 1 ) if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax","tags":"","loc":"proc/max_velmax~2.html","title":"max_velmax – OpenCoarrays"},{"text":"interface Called By interface~~solve_navier_stokes~2~~CalledByGraph interface~solve_navier_stokes~2 solve_navier_stokes program~cshear~2 cshear program~cshear~2->interface~solve_navier_stokes~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine solve_navier_stokes() Arguments None","tags":"","loc":"interface/solve_navier_stokes~2.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"public subroutine init_random_seed() Uses: iso_fortran_env Arguments None Calls proc~~init_random_seed~3~~CallsGraph proc~init_random_seed~3 init_random_seed none~lcg~3 lcg proc~init_random_seed~3->none~lcg~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dt (8) integer, public :: i integer, public :: istat integer, public :: n integer, public :: pid integer, public, allocatable :: seed (:) integer(kind=int64), public :: t integer, public :: un Functions function lcg(s) Arguments Type Intent Optional Attributes Name integer(kind=int64) :: s Return Value integer Source Code subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then if ( this_image () == 1 ) print * , \"OS provides random number generator\" read ( un ) seed close ( un ) else if ( this_image () == 1 ) print * , \"OS does not provide random number generator\" ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed","tags":"","loc":"proc/init_random_seed~3.html","title":"init_random_seed – OpenCoarrays"},{"text":"public subroutine copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3","tags":"","loc":"proc/copy3~4.html","title":"copy3 – OpenCoarrays"},{"text":"public subroutine global_times() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: stage Source Code subroutine global_times () integer ( int64 ) :: i , stage max_cpu_time = cpu_time max_tran_time = tran_time max_total_time = sync_time max_total_time = total_time min_cpu_time = cpu_time min_tran_time = tran_time min_total_time = sync_time min_total_time = total_time do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) max_cpu_time = max ( max_cpu_time , cpu_time [ i ] ) min_cpu_time = min ( min_cpu_time , cpu_time [ i ] ) max_tran_time = max ( max_tran_time , tran_time [ i ] ) min_tran_time = min ( min_tran_time , tran_time [ i ] ) max_sync_time = max ( max_sync_time , sync_time [ i ] ) min_sync_time = min ( min_sync_time , sync_time [ i ] ) max_total_time = max ( max_total_time , total_time [ i ] ) min_total_time = min ( min_total_time , total_time [ i ] ) end do sync all end subroutine global_times","tags":"","loc":"proc/global_times~3.html","title":"global_times – OpenCoarrays"},{"text":"public subroutine max_velmax() Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i Source Code subroutine max_velmax () integer ( int64 ) :: i ! sync all ! if( my_node == 1) then !     do i = 2, num_nodes;     velmax = max( velmax, velmax[i] );    end do ! end if ! sync all call co_max ( velmax , 1 ) if ( my_node > 1 ) velmax = velmax [ 1 ] sync all end subroutine max_velmax","tags":"","loc":"proc/max_velmax~3.html","title":"max_velmax – OpenCoarrays"},{"text":"interface Called By interface~~solve_navier_stokes~3~~CalledByGraph interface~solve_navier_stokes~3 solve_navier_stokes program~cshear~3 cshear program~cshear~3->interface~solve_navier_stokes~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine solve_navier_stokes() Arguments None","tags":"","loc":"interface/solve_navier_stokes~3.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"public subroutine init_random_seed() Uses: iso_fortran_env Arguments None Calls proc~~init_random_seed~4~~CallsGraph proc~init_random_seed~4 init_random_seed none~lcg~4 lcg proc~init_random_seed~4->none~lcg~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dt (8) integer, public :: i integer, public :: istat integer, public :: n integer, public :: pid integer, public, allocatable :: seed (:) integer(kind=int64), public :: t integer, public :: un Functions function lcg(s) Arguments Type Intent Optional Attributes Name integer(kind=int64) :: s Return Value integer Source Code subroutine init_random_seed () use iso_fortran_env , only : int64 implicit none integer , allocatable :: seed (:) integer :: i , n , un , istat , dt ( 8 ), pid integer ( int64 ) :: t call random_seed ( size = n ) allocate ( seed ( n )) ! First try if the OS provides a random number generator open ( newunit = un , file = \"/dev/urandom\" , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = istat ) if ( istat == 0 ) then read ( un ) seed close ( un ) else ! Fallback to XOR:ing the current time and pid. The PID is ! useful in case one launches multiple instances of the same ! program in parallel. call system_clock ( t ) if ( t == 0 ) then call date_and_time ( values = dt ) t = ( dt ( 1 ) - 1970 ) * 365_int64 * 24 * 60 * 60 * 1000 & + dt ( 2 ) * 31_int64 * 24 * 60 * 60 * 1000 & + dt ( 3 ) * 24_int64 * 60 * 60 * 1000 & + dt ( 5 ) * 60 * 60 * 1000 & + dt ( 6 ) * 60 * 1000 + dt ( 7 ) * 1000 & + dt ( 8 ) end if pid = getpid () t = ieor ( t , int ( pid , kind ( t ))) do i = 1 , n seed ( i ) = lcg ( t ) end do end if call random_seed ( put = seed ) contains ! This simple PRNG might not be good enough for real work, but is ! sufficient for seeding a better PRNG. function lcg ( s ) integer :: lcg integer ( int64 ) :: s if ( s == 0 ) then s = 104729 else s = mod ( s , 4294967296_int64 ) end if s = mod ( s * 279470273_int64 , 4294967291_int64 ) lcg = int ( mod ( s , int ( huge ( 0 ), int64 )), kind ( 0 )) end function lcg end subroutine init_random_seed","tags":"","loc":"proc/init_random_seed~4.html","title":"init_random_seed – OpenCoarrays"},{"text":"public subroutine copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine copy3","tags":"","loc":"proc/copy3~5.html","title":"copy3 – OpenCoarrays"},{"text":"public subroutine global_times() Arguments None Calls proc~~global_times~4~~CallsGraph proc~global_times~4 global_times mpi_reduce mpi_reduce proc~global_times~4->mpi_reduce Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine global_times () call MPI_REDUCE ( total_time , max_total_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( total_time , min_total_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( tran_time , max_tran_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( tran_time , min_tran_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( cpu_time , max_cpu_time , 1 , MPI_DOUBLE , MPI_MAX , 0 , MPI_COMM_WORLD , ierror ) call MPI_REDUCE ( cpu_time , min_cpu_time , 1 , MPI_DOUBLE , MPI_MIN , 0 , MPI_COMM_WORLD , ierror ) end subroutine global_times","tags":"","loc":"proc/global_times~4.html","title":"global_times – OpenCoarrays"},{"text":"interface Called By interface~~solve_navier_stokes~4~~CalledByGraph interface~solve_navier_stokes~4 solve_navier_stokes program~mshear mshear program~mshear->interface~solve_navier_stokes~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine solve_navier_stokes() Arguments None","tags":"","loc":"interface/solve_navier_stokes~4.html","title":"solve_navier_stokes – OpenCoarrays"},{"text":"public pure function u_initial(x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/u_initial.html","title":"u_initial – OpenCoarrays"},{"text":"public pure function zero(x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/zero.html","title":"zero – OpenCoarrays"},{"text":"private subroutine barrier() Arguments None Calls proc~~barrier~~CallsGraph proc~barrier barrier mpi_barrier mpi_barrier proc~barrier->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/barrier.html","title":"barrier – OpenCoarrays"},{"text":"private subroutine mpi_begin() Arguments None Calls proc~~mpi_begin~~CallsGraph proc~mpi_begin mpi_begin mpi_init mpi_init proc~mpi_begin->mpi_init mpi_cart_shift mpi_cart_shift proc~mpi_begin->mpi_cart_shift mpi_comm_rank mpi_comm_rank proc~mpi_begin->mpi_comm_rank mpi_cart_create mpi_cart_create proc~mpi_begin->mpi_cart_create mpi_comm_size mpi_comm_size proc~mpi_begin->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: dims (1) integer, public :: periods (1) integer, public :: reorder","tags":"","loc":"proc/mpi_begin.html","title":"mpi_begin – OpenCoarrays"},{"text":"private subroutine mpi_end() Arguments None Calls proc~~mpi_end~~CallsGraph proc~mpi_end mpi_end mpi_finalize mpi_finalize proc~mpi_end->mpi_finalize Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/mpi_end.html","title":"mpi_end – OpenCoarrays"},{"text":"private subroutine oned_message(periodic, local_grid_resolution, left_sub, right_sub) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:) :: periodic integer(kind=ikind), intent(in) :: local_grid_resolution real(kind=rkind), intent(inout) :: left_sub real(kind=rkind), intent(inout) :: right_sub Calls proc~~oned_message~~CallsGraph proc~oned_message oned_message mpi_sendrecv mpi_sendrecv proc~oned_message->mpi_sendrecv interface~assert assert proc~oned_message->interface~assert interface~error_message error_message proc~oned_message->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial double precision, public :: left double precision, public :: right","tags":"","loc":"proc/oned_message.html","title":"oned_message – OpenCoarrays"},{"text":"private subroutine output(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( mpi_class ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~output~3~~CallsGraph proc~output~3 output interface~assert assert proc~output~3->interface~assert interface~error_message error_message proc~output~3->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=ikind), public :: i","tags":"","loc":"proc/output~3.html","title":"output – OpenCoarrays"},{"text":"private function add_field(this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order )","tags":"","loc":"proc/add_field.html","title":"add_field – OpenCoarrays"},{"text":"private function d2f_dx2(this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order ) Calls proc~~d2f_dx2~~CallsGraph proc~d2f_dx2 d2f_dx2 mpi_sendrecv mpi_sendrecv proc~d2f_dx2->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=rkind), public :: dx integer(kind=ikind), public :: i real(kind=rkind), public :: left_image integer(kind=ikind), public :: nx real(kind=rkind), public :: right_image real(kind=rkind), public, dimension(:), allocatable, save :: tmp_field_array","tags":"","loc":"proc/d2f_dx2.html","title":"d2f_dx2 – OpenCoarrays"},{"text":"private function df_dx(this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order ) Calls proc~~df_dx~~CallsGraph proc~df_dx df_dx mpi_sendrecv mpi_sendrecv proc~df_dx->mpi_sendrecv Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=rkind), public :: dx integer(kind=ikind), public :: i real(kind=rkind), public :: left_image integer(kind=ikind), public :: nx real(kind=rkind), public :: right_image real(kind=rkind), public, dimension(:), allocatable, save :: tmp_field_array","tags":"","loc":"proc/df_dx.html","title":"df_dx – OpenCoarrays"},{"text":"private pure function get_time() result(t) Arguments None Return Value real(kind=rkind)","tags":"","loc":"proc/get_time.html","title":"get_time – OpenCoarrays"},{"text":"private pure function has_a_zero_at(this, expected_location) result(zero_at_expected_location) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: expected_location Return Value logical Variables Type Visibility Attributes Name Initial integer, public :: nearest_grid_point real(kind=rkind), public, parameter :: tolerance = 1.0E-06_rkind","tags":"","loc":"proc/has_a_zero_at.html","title":"has_a_zero_at – OpenCoarrays"},{"text":"private pure function local_state(this) result(local_state_vector) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value real(kind=rkind),\n  allocatable,(:) Variables Type Visibility Attributes Name Initial integer(kind=ikind), public :: i","tags":"","loc":"proc/local_state.html","title":"local_state – OpenCoarrays"},{"text":"private function multiply_field(this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order )","tags":"","loc":"proc/multiply_field.html","title":"multiply_field – OpenCoarrays"},{"text":"private function multiply_real(lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs real(kind=rkind), intent(in) :: rhs Return Value type( periodic_2nd_order )","tags":"","loc":"proc/multiply_real.html","title":"multiply_real – OpenCoarrays"},{"text":"private function rk2_dt(this, nu, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: nu integer(kind=ikind), intent(in) :: num_grid_pts Return Value real(kind=rkind) Variables Type Visibility Attributes Name Initial real(kind=rkind), public :: CFL real(kind=rkind), public :: dx real(kind=rkind), public :: k_max","tags":"","loc":"proc/rk2_dt.html","title":"rk2_dt – OpenCoarrays"},{"text":"private pure function subtract(lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order )","tags":"","loc":"proc/subtract~2.html","title":"subtract – OpenCoarrays"},{"text":"private pure function this_image_contains(location) result(within_bounds) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: location Return Value logical","tags":"","loc":"proc/this_image_contains.html","title":"this_image_contains – OpenCoarrays"},{"text":"private subroutine assign_field(lhs, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: lhs type( periodic_2nd_order ), intent(in) :: rhs Calls proc~~assign_field~~CallsGraph proc~assign_field assign_field interface~assert assert proc~assign_field->interface~assert interface~error_message error_message proc~assign_field->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial double precision, public :: left double precision, public :: left_sub double precision, public :: right double precision, public :: right_sub","tags":"","loc":"proc/assign_field.html","title":"assign_field – OpenCoarrays"},{"text":"private subroutine construct(this, initial, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: this procedure( initial_field ), intent(in), pointer :: initial integer(kind=ikind), intent(in) :: num_grid_pts Calls proc~~construct~~CallsGraph proc~construct construct none~grid grid proc~construct->none~grid interface~assert assert proc~construct->interface~assert interface~error_message error_message proc~construct->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i double precision, public :: left double precision, public :: left_sub double precision, public :: right double precision, public :: right_sub Functions pure function grid() Arguments None Return Value real(kind=rkind),\n  dimension(:),allocatable","tags":"","loc":"proc/construct.html","title":"construct – OpenCoarrays"},{"text":"private subroutine output(this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~output~4~~CallsGraph proc~output~4 output interface~assert assert proc~output~4->interface~assert interface~error_message error_message proc~output~4->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=ikind), public :: i","tags":"","loc":"proc/output~4.html","title":"output – OpenCoarrays"},{"text":"private subroutine set_time(time_stamp) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: time_stamp","tags":"","loc":"proc/set_time.html","title":"set_time – OpenCoarrays"},{"text":"public subroutine mpi_copy3(A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Uses: iso_fortran_env Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 Called By proc~~mpi_copy3~~CalledByGraph proc~mpi_copy3 mpi_copy3 proc~transpose_x_y~2 transpose_X_Y proc~transpose_x_y~2->proc~mpi_copy3 proc~transpose_y_x~2 transpose_Y_X proc~transpose_y_x~2->proc~mpi_copy3 program~mpi_distributed_transpose mpi_distributed_transpose program~mpi_distributed_transpose->proc~transpose_x_y~2 program~mpi_distributed_transpose->proc~transpose_y_x~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: i integer(kind=int64), public :: j integer(kind=int64), public :: k Source Code subroutine mpi_copy3 ( A , B , n1 , sA1 , sB1 , n2 , sA2 , sB2 , n3 , sA3 , sB3 ) use iso_fortran_env implicit none complex , intent ( in ) :: A ( 0 : * ) complex , intent ( out ) :: B ( 0 : * ) integer ( int64 ), intent ( in ) :: n1 , sA1 , sB1 integer ( int64 ), intent ( in ) :: n2 , sA2 , sB2 integer ( int64 ), intent ( in ) :: n3 , sA3 , sB3 integer ( int64 ) i , j , k do k = 0 , n3 - 1 do j = 0 , n2 - 1 do i = 0 , n1 - 1 B ( i * sB1 + j * sB2 + k * sB3 ) = A ( i * sA1 + j * sA2 + k * sA3 ) end do end do end do end subroutine mpi_copy3","tags":"","loc":"proc/mpi_copy3.html","title":"mpi_copy3 – OpenCoarrays"},{"text":"subroutine transpose_X_Y() Uses: mpi_run_size Arguments None Calls proc~~transpose_x_y~2~~CallsGraph proc~transpose_x_y~2 transpose_X_Y mpi_issend mpi_issend proc~transpose_x_y~2->mpi_issend mpi_barrier mpi_barrier proc~transpose_x_y~2->mpi_barrier walltime walltime proc~transpose_x_y~2->walltime mpi_recv mpi_recv proc~transpose_x_y~2->mpi_recv proc~mpi_copy3 mpi_copy3 proc~transpose_x_y~2->proc~mpi_copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~transpose_x_y~2~~CalledByGraph proc~transpose_x_y~2 transpose_X_Y program~mpi_distributed_transpose mpi_distributed_transpose program~mpi_distributed_transpose->proc~transpose_x_y~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=M), public :: errs integer(kind=int64), public :: from integer, public :: idr (0:num_nodes-1) integer, public :: ids (0:num_nodes-1) integer(kind=int64), public :: recv_status (MPI_STATUS_SIZE) integer(kind=int64), public :: recv_tag integer(kind=int64), public :: send_status (MPI_STATUS_SIZE) integer(kind=int64), public :: send_tag integer, public :: stage integer(kind=int64), public :: to Source Code subroutine transpose_X_Y use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) character * ( MPI_MAX_ERROR_STRING ) errs call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( u ( 1 , 1 , first_x , 1 + to * my ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   receive and transpose other image's block  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , ur ( 1 , 1 , first_y , 1 + from * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( ur ( 1 , 1 , first_y , 1 + from * mx ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + to * my ), bufr & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () ! deallocate(ids,idr) end  subroutine transpose_X_Y","tags":"","loc":"proc/transpose_x_y~2.html","title":"transpose_X_Y – OpenCoarrays"},{"text":"subroutine transpose_Y_X() Uses: mpi_run_size Arguments None Calls proc~~transpose_y_x~2~~CallsGraph proc~transpose_y_x~2 transpose_Y_X mpi_issend mpi_issend proc~transpose_y_x~2->mpi_issend mpi_barrier mpi_barrier proc~transpose_y_x~2->mpi_barrier walltime walltime proc~transpose_y_x~2->walltime mpi_recv mpi_recv proc~transpose_y_x~2->mpi_recv proc~mpi_copy3 mpi_copy3 proc~transpose_y_x~2->proc~mpi_copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~transpose_y_x~2~~CalledByGraph proc~transpose_y_x~2 transpose_Y_X program~mpi_distributed_transpose mpi_distributed_transpose program~mpi_distributed_transpose->proc~transpose_y_x~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial character(len=M), public :: errs integer(kind=int64), public :: from integer, public :: idr (0:num_nodes-1) integer, public :: ids (0:num_nodes-1) integer(kind=int64), public :: recv_status (MPI_STATUS_SIZE) integer(kind=int64), public :: recv_tag integer(kind=int64), public :: send_status (MPI_STATUS_SIZE) integer(kind=int64), public :: send_tag integer, public :: stage integer(kind=int64), public :: to Source Code subroutine transpose_Y_X use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) character * ( MPI_MAX_ERROR_STRING ) errs integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( ur ( 1 , 1 , first_y , 1 + to * mx ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   transpose other image's block (get block then transpose it)  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , u ( 1 , 1 , first_x , 1 + from * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( u ( 1 , 1 , first_x , 1 + from * my ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + to * mx ), bufr & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () !   deallocate(ids,idr) end  subroutine transpose_Y_X","tags":"","loc":"proc/transpose_y_x~2.html","title":"transpose_Y_X – OpenCoarrays"},{"text":"function calibrate_loop(usecs) result(cl) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: usecs Return Value integer(kind=int64) Calls proc~~calibrate_loop~~CallsGraph proc~calibrate_loop calibrate_loop proc~loop loop proc~calibrate_loop->proc~loop proc~from_lower_half from_lower_half proc~loop->proc~from_lower_half images images proc~loop->images proc~sending_half sending_half proc~loop->proc~sending_half interface~stop_timer stop_timer proc~loop->interface~stop_timer interface~elapsed_time elapsed_time proc~loop->interface~elapsed_time proc~to_upper_half to_upper_half proc~loop->proc~to_upper_half interface~start_timer start_timer proc~loop->interface~start_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~calibrate_loop~~CalledByGraph proc~calibrate_loop calibrate_loop program~psnap psnap program~psnap->proc~calibrate_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: calibrate_useconds = 100000000 integer(kind=int64), public :: counter integer(kind=int64), public :: difference integer(kind=int64), public :: i integer(kind=int64), public, parameter :: initial_counter = 100000 integer(kind=int64), public, parameter :: initial_ntrial = 1000 integer(kind=int64), public :: loop_time integer(kind=int64), public :: min_time_usecs integer(kind=int64), public :: ntrial real(kind=real64), public, parameter :: preset_tolerance = 1.0_real64 integer(kind=int64), public :: tolerance integer(kind=int64), public :: total_time Source Code function calibrate_loop ( usecs ) result ( cl ) integer ( int64 ) :: cl integer ( int64 ), intent ( in ) :: usecs integer ( int64 ), parameter :: calibrate_useconds = 100000000 !real( real64), parameter :: preset_tolerance = 0.001_real64 real ( real64 ), parameter :: preset_tolerance = 1.0_real64 integer ( int64 ), parameter :: initial_ntrial = 1000 !integer( int64), parameter :: initial_counter = 1000000 integer ( int64 ), parameter :: initial_counter = 100000 integer ( int64 ) :: counter integer ( int64 ) :: min_time_usecs integer ( int64 ) :: tolerance integer ( int64 ) :: difference integer ( int64 ) :: total_time integer ( int64 ) :: ntrial integer ( int64 ) :: i integer ( int64 ) :: loop_time continue counter = initial_counter !write(*,*) 'Counter after initial counter',counter !  if usecs / granularity is less than 1/preset_tolerance then use zero tolerance = int ( real ( usecs , real64 ) * preset_tolerance , int64 ) total_time = 0 trials : do ntrial = initial_ntrial min_time_usecs = huge ( 0_int64 ) get_min : do i = 1 , ntrial loop_time = loop ( counter ) !write(*,*) 'loop_time',loop_time min_time_usecs = min ( min_time_usecs , loop_time ) end do get_min !  keep an estimate of total calibration time total_time = total_time + min_time_usecs * ntrial counter = int ( real ( counter , real64 ) * real ( usecs , real64 ) / real ( min_time_usecs , real64 ), int64 ) !write(*,*) 'Counter after assignment',counter difference = abs ( min_time_usecs - usecs ) if ( difference <= tolerance . or . total_time >= calibrate_useconds ) exit trials end do trials cl = counter write ( unit = output_unit , fmt = '( a, i2, a, i10, a, i10, a, i10, a, i10)' ) \"#rank= \" , rank , & \" count= \" , counter , \" time= \" , min_time_usecs , & \" difference= \" , difference , \" tolerance= \" , tolerance time_out : if ( total_time > calibrate_useconds ) then write ( unit = output_unit , fmt = '( a, i2, a, f10.4, a, f10.4, a, f10.4, a, i0)' ) \"PSNAP: WARNING rank \" , rank , & \" didn't converge in 10 seconds tolerance = \" , & real ( difference ) / real ( usecs ), & \" should be \" , preset_tolerance , \" approx \" , & preset_tolerance * 10 0.0 , \" percent, granularity= \" , usecs end if time_out return end function calibrate_loop","tags":"","loc":"proc/calibrate_loop.html","title":"calibrate_loop – OpenCoarrays"},{"text":"function from_lower_half(i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer Called By proc~~from_lower_half~~CalledByGraph proc~from_lower_half from_lower_half proc~loop loop proc~loop->proc~from_lower_half proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function from_lower_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process upper half ranks only l = i - np_half return end function from_lower_half","tags":"","loc":"proc/from_lower_half.html","title":"from_lower_half – OpenCoarrays"},{"text":"function get_usecs() result(usecs) Arguments None Return Value real(kind=real64) Variables Type Visibility Attributes Name Initial integer(kind=8), public, parameter :: c = 1000000 integer(kind=8), public :: r integer(kind=8), public :: t Source Code function get_usecs () result ( usecs ) !integer( int64) :: usecs !  usec per sec !integer( int64), parameter :: c = 1000000 !   integer( int64) :: t !   integer( int64) :: r integer ( kind = 8 ) :: t , r real ( real64 ) :: usecs integer ( kind = 8 ), parameter :: c = 1000000 continue !call system_clock( count= t, count_rate= r) call cpu_time ( usecs ) usecs = usecs * 1. d6 !if( r /= c ) usecs = int( real( t, 8) / real( r, 8) * real( c, 8)) !if( r /= c ) usecs = int( t/r * c) return end function get_usecs","tags":"","loc":"proc/get_usecs.html","title":"get_usecs – OpenCoarrays"},{"text":"function loop(iterations) result(dt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iterations Return Value integer(kind=int64) Calls proc~~loop~~CallsGraph proc~loop loop proc~from_lower_half from_lower_half proc~loop->proc~from_lower_half images images proc~loop->images proc~sending_half sending_half proc~loop->proc~sending_half interface~stop_timer stop_timer proc~loop->interface~stop_timer interface~elapsed_time elapsed_time proc~loop->interface~elapsed_time proc~to_upper_half to_upper_half proc~loop->proc~to_upper_half interface~start_timer start_timer proc~loop->interface~start_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~loop~~CalledByGraph proc~loop loop proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, codimension[ *], save :: coarray integer(kind=int64), public :: i integer, public :: next_rank integer, public :: prev_rank integer(kind=int64), public :: usecs_final integer(kind=int64), public :: usecs_init Source Code function loop ( iterations ) result ( dt ) integer ( int64 ) :: dt integer ( int64 ), intent ( in ) :: iterations integer ( int64 ) :: i integer ( int64 ) :: usecs_init , usecs_final integer :: next_rank , prev_rank integer , codimension [ * ], save :: coarray continue !   usecs_init = get_usecs() call start_timer () next_rank = to_upper_half ( rank ) prev_rank = from_lower_half ( rank ) !   write(*,*) 'Proc',rank,'Next rank',next_rank,'Prev rank',prev_rank counter : do i = 1 , iterations even_odd : if ( sending_half ( rank ) ) then !  send rank to next then fetch rank coarray [ next_rank ] = coarray sync images ( next_rank ) else even_odd !  stay calm coarray [ prev_rank ] = coarray sync images ( prev_rank ) end if even_odd end do counter !   usecs_final = get_usecs() call stop_timer () !   write(*,*) 'usec_init',usec_init,'usec_final',usec_final dt = elapsed_time () !write(*,*) 'usec_init',usec_init,'usec_final',usec_final,'dt',dt return end function loop","tags":"","loc":"proc/loop.html","title":"loop – OpenCoarrays"},{"text":"function sending_half(i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value logical Called By proc~~sending_half~~CalledByGraph proc~sending_half sending_half proc~loop loop proc~loop->proc~sending_half proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function sending_half ( i ) result ( l ) integer , intent ( in ) :: i logical :: l continue !  this must process np == even values only l = i <= np_half return end function sending_half","tags":"","loc":"proc/sending_half.html","title":"sending_half – OpenCoarrays"},{"text":"function to_upper_half(i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer Called By proc~~to_upper_half~~CalledByGraph proc~to_upper_half to_upper_half proc~loop loop proc~loop->proc~to_upper_half proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function to_upper_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process lower half ranks only l = i + np_half return end function to_upper_half","tags":"","loc":"proc/to_upper_half.html","title":"to_upper_half – OpenCoarrays"},{"text":"subroutine print_banner() Arguments None Called By proc~~print_banner~~CalledByGraph proc~print_banner print_banner program~psnap psnap program~psnap->proc~print_banner Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine print_banner () continue write ( unit = output_unit , fmt = string_fmt ) '########' write ( unit = output_unit , fmt = string_fmt ) '##P-SNAP: PAL System Noise Activity Program' write ( unit = output_unit , fmt = string_fmt ) '##' // psnap_rcs_id write ( unit = output_unit , fmt = string_fmt ) '##This is a Fortran translation of P-SNAP v 1.2 from' write ( unit = output_unit , fmt = string_fmt ) '##http://www.c3.lanl.gov/pal/software/psnap/' write ( unit = output_unit , fmt = string_fmt ) '##This program is the coarray ping-pong version' write ( unit = output_unit , fmt = string_fmt ) '########' return end subroutine print_banner","tags":"","loc":"proc/print_banner.html","title":"print_banner – OpenCoarrays"},{"text":"subroutine usage() Arguments None Called By proc~~usage~~CalledByGraph proc~usage usage program~psnap psnap program~psnap->proc~usage Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i character(len=*), public, parameter, dimension( 17) :: msg = [\"Usage: psnap [OPTIONS]                                             \", \"                                                                   \", \"  -n number of repetitions                                \", \"                default: 100000                                    \", \"  -w number of warm-up repetitions                        \", \"                default: 10%% of the number of reps                \", \"  -c calibration count                                    \", \"                default: perform a calibration to match granularity\", \"  -g granularity of the test in microseconds              \", \"                default: 1000                                      \", \"  -b perform a barrier between every N loops              \", \"                default: no                                        \", \"  -h          this message                                         \", \"                                                                   \", \"  Example: psnap -n 1000000 -w 10 > psnap.out                      \", \"    runs a test with 1000000 repetitions and 10 warm-up reps.      \", \"                                                                   \"] Source Code subroutine usage () character ( len = * ), dimension ( 17 ), parameter :: msg = & [ \"Usage: psnap [OPTIONS]                                             \" , & \"                                                                   \" , & \"  -n <reps>   number of repetitions                                \" , & \"                default: 100000                                    \" , & \"  -w <reps>   number of warm-up repetitions                        \" , & \"                default: 10%% of the number of reps                \" , & \"  -c <count>  calibration count                                    \" , & \"                default: perform a calibration to match granularity\" , & \"  -g <usecs>  granularity of the test in microseconds              \" , & \"                default: 1000                                      \" , & \"  -b <N>      perform a barrier between every N loops              \" , & \"                default: no                                        \" , & \"  -h          this message                                         \" , & \"                                                                   \" , & \"  Example: psnap -n 1000000 -w 10 > psnap.out                      \" , & \"    runs a test with 1000000 repetitions and 10 warm-up reps.      \" , & \"                                                                   \" ] integer :: i continue write ( unit = error_unit , fmt = string_fmt ) ( trim ( msg ( i )), i = 1 , size ( msg , 1 )) stop 'normal exit in usage' end subroutine usage","tags":"","loc":"proc/usage.html","title":"usage – OpenCoarrays"},{"text":"subroutine warmup_loop(wa) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: wa Calls proc~~warmup_loop~~CallsGraph proc~warmup_loop warmup_loop proc~loop loop proc~warmup_loop->proc~loop proc~from_lower_half from_lower_half proc~loop->proc~from_lower_half images images proc~loop->images proc~sending_half sending_half proc~loop->proc~sending_half interface~stop_timer stop_timer proc~loop->interface~stop_timer interface~elapsed_time elapsed_time proc~loop->interface~elapsed_time proc~to_upper_half to_upper_half proc~loop->proc~to_upper_half interface~start_timer start_timer proc~loop->interface~start_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By proc~~warmup_loop~~CalledByGraph proc~warmup_loop warmup_loop program~psnap psnap program~psnap->proc~warmup_loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: counter = 10000 integer, public :: i integer(kind=int64), public :: loop_time integer(kind=int64), public :: min_time_usecs Source Code subroutine warmup_loop ( wa ) integer ( int64 ), intent ( in ) :: wa !integer( int64), parameter :: counter = 1000000 integer ( int64 ), parameter :: counter = 10000 integer ( int64 ) :: min_time_usecs integer ( int64 ) :: loop_time integer :: i continue min_time_usecs = huge ( 0_int64 ) reloop : do i = 1 , wa loop_time = loop ( counter ) min_time_usecs = min ( loop_time , min_time_usecs ) end do reloop return end subroutine warmup_loop","tags":"","loc":"proc/warmup_loop.html","title":"warmup_loop – OpenCoarrays"},{"text":"interface Called By interface~~elapsed_time~~CalledByGraph interface~elapsed_time elapsed_time proc~loop loop proc~loop->interface~elapsed_time proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. function elapsed_time() result(res) bind(c,name=\"elapsed_time\") Uses: iso_c_binding Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/elapsed_time.html","title":"elapsed_time – OpenCoarrays"},{"text":"interface Called By interface~~start_timer~~CalledByGraph interface~start_timer start_timer proc~loop loop proc~loop->interface~start_timer proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine start_timer() bind(C, name=\"0\") Uses: iso_c_binding Arguments None","tags":"","loc":"interface/start_timer.html","title":"start_timer – OpenCoarrays"},{"text":"interface Called By interface~~stop_timer~~CalledByGraph interface~stop_timer stop_timer proc~loop loop proc~loop->interface~stop_timer proc~calibrate_loop calibrate_loop proc~calibrate_loop->proc~loop program~psnap psnap program~psnap->proc~loop program~psnap->proc~calibrate_loop proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~warmup_loop->proc~loop Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. subroutine stop_timer() bind(C, name=\"0\") Uses: iso_c_binding Arguments None","tags":"","loc":"interface/stop_timer.html","title":"stop_timer – OpenCoarrays"},{"text":"private subroutine co_all_logical(a) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: a (:) Called By proc~~co_all_logical~~CalledByGraph proc~co_all_logical co_all_logical interface~co_all co_all interface~co_all->proc~co_all_logical program~main~7 main program~main~7->interface~co_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function and(lhs, rhs) result(lhs_and_rhs) bind(C,name=\"and\") Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs logical, intent(in) :: rhs Return Value logical","tags":"","loc":"proc/co_all_logical.html","title":"co_all_logical – OpenCoarrays"},{"text":"private subroutine co_product_c_double(a) Uses: iso_c_binding Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout) :: a Called By proc~~co_product_c_double~~CalledByGraph proc~co_product_c_double co_product_c_double interface~co_product co_product interface~co_product->proc~co_product_c_double program~main~7 main program~main~7->interface~co_product Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function product_(lhs, rhs) result(lhs_x_rhs) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: lhs real(kind=c_double), intent(in) :: rhs Return Value real(kind=c_double)","tags":"","loc":"proc/co_product_c_double.html","title":"co_product_c_double – OpenCoarrays"},{"text":"private subroutine co_product_c_int(a) Uses: iso_c_binding Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout) :: a Called By proc~~co_product_c_int~~CalledByGraph proc~co_product_c_int co_product_c_int interface~co_product co_product interface~co_product->proc~co_product_c_int program~main~7 main program~main~7->interface~co_product Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions pure function product_(lhs, rhs) result(lhs_x_rhs) bind(C,name=\"product_\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: lhs integer(kind=c_int), intent(in) :: rhs Return Value integer(kind=c_int)","tags":"","loc":"proc/co_product_c_int.html","title":"co_product_c_int – OpenCoarrays"},{"text":"public interface co_all Calls interface~~co_all~~CallsGraph interface~co_all co_all proc~co_all_logical co_all_logical interface~co_all->proc~co_all_logical Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~co_all~~CalledByGraph interface~co_all co_all program~main~7 main program~main~7->interface~co_all Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_all_logical (a) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: a (:)","tags":"","loc":"interface/co_all.html","title":"co_all – OpenCoarrays"},{"text":"public interface co_product Calls interface~~co_product~~CallsGraph interface~co_product co_product proc~co_product_c_int co_product_c_int interface~co_product->proc~co_product_c_int proc~co_product_c_double co_product_c_double interface~co_product->proc~co_product_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called By interface~~co_product~~CalledByGraph interface~co_product co_product program~main~7 main program~main~7->interface~co_product Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private subroutine co_product_c_int (a) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout) :: a private subroutine co_product_c_double (a) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout) :: a","tags":"","loc":"interface/co_product.html","title":"co_product – OpenCoarrays"},{"text":"subroutine test_alloc(me) Arguments Type Intent Optional Attributes Name integer, intent(out) :: me Called By proc~~test_alloc~~CalledByGraph proc~test_alloc test_alloc program~alloc_as_barrier~2 alloc_as_barrier program~alloc_as_barrier~2->proc~test_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, allocatable :: a (:)[:]","tags":"","loc":"proc/test_alloc.html","title":"test_alloc – OpenCoarrays"},{"text":"subroutine one(lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 Called By proc~~one~~CalledByGraph proc~one one program~main~9 main program~main~9->proc~one Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, allocatable :: a (:,:) integer, public, allocatable :: b (:,:) integer, public, allocatable :: c (:,:) integer, public, allocatable :: caf (:,:)[:] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s Source Code subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:), c (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & c ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = b caf = - 42 c = caf sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) call abort () endif ! Whole array: ARRAY = ARRAY caf = - 42 a = b c = caf if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 1:' , any ( a /= c ) print * , a print * , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Scalar assignment a = - 42 caf = - 42 c = caf sync all do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 2:' , any ( a /= c ) print * , this_image (), ': ' , a print * , this_image (), ': ' , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 42 caf = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if ! ARRAY = ARRAY caf = - 42 a = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one","tags":"","loc":"proc/one.html","title":"one – OpenCoarrays"},{"text":"subroutine three() Arguments None Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = 0 integer, public, parameter :: lb2 = 0 Source Code subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three","tags":"","loc":"proc/three.html","title":"three – OpenCoarrays"},{"text":"subroutine two() Arguments None Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = -5 integer, public, parameter :: lb2 = 1 Source Code subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two","tags":"","loc":"proc/two.html","title":"two – OpenCoarrays"},{"text":"subroutine one(lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 Called By proc~~one~2~~CalledByGraph proc~one~2 one program~main~10 main program~main~10->proc~one~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, allocatable :: a (:,:) integer, public, allocatable :: b (:,:) integer, public, allocatable :: caf (:,:)[:] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s Source Code subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] print * , this_image (), '//' , a , '//' , b ( lb1 , lb2 ) print * , '>>>' , any ( a /= b ( lb1 , lb2 )) if ( any ( a /= b ( lb1 , lb2 ))) then ! FIXME: ABORTS UNLESS THERE IS SOME OTHER CODE print * , 'HELLO!!!!!!!!!!!!!!!!!' call abort () end if end if ! Whole array: ARRAY = ARRAY a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] if ( any ( a /= b )) & !FIXME print * , a print * , b print * , 'WRONG:' , any ( a /= b ) call abort () end if end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !\t\t      b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !\t\t\t   = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine one","tags":"","loc":"proc/one~2.html","title":"one – OpenCoarrays"},{"text":"subroutine three() Arguments None Called By proc~~three~2~~CalledByGraph proc~three~2 three program~main~10 main program~main~10->proc~three~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = 0 integer, public, parameter :: lb2 = 0 Source Code subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                      if (any (a /= b)) then !                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                             lb2,\":\",m+lb2-1 !                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                        print *, i !                        print *, a !                        print *, caf !                        print *, a-caf !                        call abort() !                      endif end if end do end do end do end do end do end do end do end do end subroutine three","tags":"","loc":"proc/three~2.html","title":"three – OpenCoarrays"},{"text":"subroutine two() Arguments None Called By proc~~two~2~~CalledByGraph proc~two~2 two program~main~10 main program~main~10->proc~two~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = -5 integer, public, parameter :: lb2 = 1 Source Code subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY b = - 32 a = - 12 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            =caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine two","tags":"","loc":"proc/two~2.html","title":"two – OpenCoarrays"},{"text":"subroutine one(lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 Called By proc~~one~3~~CalledByGraph proc~one~3 one program~main~11 main program~main~11->proc~one~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, allocatable :: a (:,:) integer, public, allocatable :: b (:,:) integer, public, allocatable :: caf (:,:)[:] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s Source Code subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one","tags":"","loc":"proc/one~3.html","title":"one – OpenCoarrays"},{"text":"subroutine three() Arguments None Called By proc~~three~3~~CalledByGraph proc~three~3 three program~main~11 main program~main~11->proc~three~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = 0 integer, public, parameter :: lb2 = 0 Source Code subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three","tags":"","loc":"proc/three~3.html","title":"three – OpenCoarrays"},{"text":"subroutine two() Arguments None Called By proc~~two~3~~CalledByGraph proc~two~3 two program~main~11 main program~main~11->proc~two~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, save :: a (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: b (lb1:n+lb1-1,lb2:m+lb2-1) integer, public, save :: caf (lb1:n+lb1-1,lb2:m+lb2-1)[*] integer, public :: i integer, public :: i_e integer, public :: i_s integer, public :: i_sgn1 integer, public :: i_sgn2 integer, public :: j integer, public :: j_e integer, public :: j_s integer, public, parameter :: lb1 = -5 integer, public, parameter :: lb2 = 1 Source Code subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two","tags":"","loc":"proc/two~3.html","title":"two – OpenCoarrays"},{"text":"Uses: iso_c_binding module~~opencoarrays~~UsesGraph module~opencoarrays opencoarrays iso_c_binding iso_c_binding iso_c_binding->module~opencoarrays Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=c_int), private, save, volatile, bind(C,name=\"0\") :: CAF_COMM_WORLD integer(kind=c_int32_t), private, parameter :: bytes_per_word = 4_c_int32_t integer, private, parameter :: max_dimensions = 15 Enumerations enum, bind(c) Enumerators enumerator :: BT_ASSUMED = 11 enumerator :: BT_CHARACTER = 6 enumerator :: BT_CLASS = 7 enumerator :: BT_COMPLEX = 4 enumerator :: BT_DERIVED = 5 enumerator :: BT_HOLLERITH = 9 enumerator :: BT_INTEGER = 1 enumerator :: BT_LOGICAL = 2 enumerator :: BT_PROCEDURE = 8 enumerator :: BT_REAL = 3 enumerator :: BT_UNKNOWN = 0 enumerator :: BT_VOID = 10 Interfaces public interface co_broadcast private subroutine co_broadcast_c_int (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_double (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_char (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(inout), volatile, target :: a integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg public interface co_max private subroutine co_max_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_max_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg public interface co_min private subroutine co_min_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_min_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg public interface co_reduce private subroutine co_reduce_c_int (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, contiguous :: a (..) procedure( c_int_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_c_double (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, contiguous :: a (..) procedure( c_double_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_logical (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name logical, intent(inout), volatile, contiguous :: a (..) procedure( logical_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) public interface co_sum private subroutine co_sum_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_sum_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private interface gfc_descriptor private function gfc_descriptor_c_int (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_c_double (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_logical (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name logical, intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) interface private subroutine opencoarrays_co_broadcast (a, source_image, stat, errmsg, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: errmsg_len interface private subroutine opencoarrays_co_max (a, result_image, stat, errmsg, unused, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: unused integer(kind=c_int), intent(in), value :: errmsg_len interface private subroutine opencoarrays_co_min (a, result_image, stat, errmsg, unused, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) integer(kind=c_int), intent(in), value :: unused integer(kind=c_int), intent(in), value :: errmsg_len interface private subroutine opencoarrays_co_reduce (a, opr, opr_flags, result_image, stat, errmsg, a_len, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a type(c_funptr), intent(in), value :: opr integer(kind=c_int), intent(in), value :: opr_flags integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out) :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) integer(kind=c_int), intent(in), value :: a_len integer(kind=c_int), intent(in), value :: errmsg_len interface private subroutine opencoarrays_co_sum (a, result_image, stat, errmsg, errmsg_len) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: a integer(kind=c_int), intent(in), value :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=c_char), intent(out), optional :: errmsg (*) integer(kind=c_int), intent(in), value :: errmsg_len interface private subroutine opencoarrays_error_stop (stop_code) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), value :: stop_code interface private subroutine opencoarrays_get (token, offset, image_index_, src, src_vector_unused, dest, src_kind, dst_kind, mrt) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name type(c_ptr), , value :: token integer(kind=c_ptrdiff_t), , value :: offset integer(kind=c_int), , value :: image_index_ type( gfc_descriptor_t ) :: src type( caf_vector_t ) :: src_vector_unused type( gfc_descriptor_t ) :: dest integer(kind=c_int), , value :: src_kind integer(kind=c_int), , value :: dst_kind logical(kind=c_bool), , value :: mrt interface private function opencoarrays_num_images (coarray, dim_) result(num_images_) bind(C,name=\"_gfortran_caf_num_images\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: coarray integer(kind=c_int), intent(in), value :: dim_ Return Value integer(kind=c_int) interface private subroutine opencoarrays_sync_all (stat, errmsg, unused) bind(C,name=\"0\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: stat character(len=c_char), intent(out) :: errmsg (*) integer(kind=c_int), intent(out) :: unused interface private function opencoarrays_this_image (coarray) result(image_num) bind(C,name=\"_gfortran_caf_this_image\") Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: coarray Return Value integer(kind=c_int) Abstract Interfaces abstract interface private pure function c_double_operator (lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: lhs real(kind=c_double), intent(in) :: rhs Return Value real(kind=c_double) abstract interface private pure function c_int_operator (lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: lhs integer(kind=c_int), intent(in) :: rhs Return Value integer(kind=c_int) abstract interface private pure function logical_operator (lhs, rhs) result(lhs_op_rhs) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs logical, intent(in) :: rhs Return Value logical Derived Types type, private, bind(C) :: caf_vector_t Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: nvec type( u_t ), public :: u type, private, bind(C) :: descriptor_dimension Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: lower_bound integer(kind=c_ptrdiff_t), public :: stride integer(kind=c_ptrdiff_t), public :: ubound_ type, private, bind(C) :: gfc_descriptor_t Components Type Visibility Attributes Name Initial type(c_ptr), public :: base_addr type( descriptor_dimension ), public :: dim_ (max_dimensions) integer(kind=c_ptrdiff_t), public :: dtype integer(kind=c_ptrdiff_t), public :: offset type, private, bind(C) :: triplet_t Components Type Visibility Attributes Name Initial integer(kind=c_ptrdiff_t), public :: lower_bound integer(kind=c_ptrdiff_t), public :: stride integer(kind=c_ptrdiff_t), public :: upper_bound type, private, bind(C) :: u_t Components Type Visibility Attributes Name Initial type( triplet_t ), public :: triplet type( v_t ), public :: v type, private, bind(C) :: v_t Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: kind_ type(c_ptr), public :: vector Functions private function gfc_descriptor_c_double (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_c_int (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function gfc_descriptor_logical (a) result(a_descriptor) Arguments Type Intent Optional Attributes Name logical, intent(in), target, contiguous :: a (..) Return Value type( gfc_descriptor_t ) private function my_dtype (type_, kind_, rank_) result(dtype_) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: type_ integer(kind=c_int32_t), intent(in) :: kind_ integer(kind=c_int32_t), intent(in) :: rank_ Return Value integer(kind=c_int32_t) public function num_images () result(num_images_) Arguments None Return Value integer(kind=c_int) public function this_image () result(image_num) Arguments None Return Value integer(kind=c_int) Subroutines private subroutine co_broadcast_c_char (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name character(kind=c_char,len=*), intent(inout), volatile, target :: a integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_double (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_broadcast_c_int (a, source_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: source_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_max_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_max_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_min_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_min_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_reduce_c_double (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, contiguous :: a (..) procedure( c_double_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_c_int (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, contiguous :: a (..) procedure( c_int_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_reduce_logical (a, opr, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name logical, intent(inout), volatile, contiguous :: a (..) procedure( logical_operator ) :: opr integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional volatile :: stat character(kind=c_char), intent(out), optional volatile :: errmsg (*) private subroutine co_sum_c_double (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg private subroutine co_sum_c_int (a, result_image, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout), volatile, target, contiguous :: a (..) integer(kind=c_int), intent(in), optional :: result_image integer(kind=c_int), intent(out), optional :: stat character(kind=1,len=*), intent(out), optional :: errmsg public subroutine error_stop (stop_code) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in), optional :: stop_code private subroutine get_c_int (src, dest, image_index_, offset, mrt) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), target, contiguous :: src (..) integer(kind=c_int), intent(out), target, contiguous, volatile :: dest (..) integer(kind=c_int), intent(in) :: image_index_ integer(kind=c_ptrdiff_t), intent(in) :: offset logical(kind=c_bool), intent(in) :: mrt public subroutine sync_all (stat, errmsg, unused) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out), optional :: stat character(len=c_char), intent(out), optional :: errmsg integer(kind=c_int), intent(out), optional :: unused","tags":"","loc":"module/opencoarrays.html","title":"opencoarrays – OpenCoarrays"},{"text":"Uses: iso_fortran_env mpi module~~run_size~2~~UsesGraph module~run_size~2 run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~2 mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. s run_size/broadcast_int\n NAME\n   broadcast_int\n  SYNOPSIS\n   Broadcast a scalar coarray integer from image 1 to all other images. *** Used By module~~run_size~2~~UsedByGraph module~run_size~2 run_size proc~solve_navier_stokes~4 solve_navier_stokes module~run_size~2->proc~solve_navier_stokes~4 none~phase3~3 phase3 module~run_size~2->none~phase3~3 none~copy_s_n~4 copy_s_n module~run_size~2->none~copy_s_n~4 none~phase1 phase1 module~run_size~2->none~phase1 none~transpose_x_y transpose_X_Y module~run_size~2->none~transpose_x_y none~advance~4 advance module~run_size~2->none~advance~4 none~copy_s_n~3 copy_s_n module~run_size~2->none~copy_s_n~3 program~cshear cshear module~run_size~2->program~cshear none~define_field~4 define_field module~run_size~2->none~define_field~4 none~advance~3 advance module~run_size~2->none~advance~3 none~phase2 phase2 module~run_size~2->none~phase2 none~define_kspace~4 define_kspace module~run_size~2->none~define_kspace~4 none~define_step~2 define_step module~run_size~2->none~define_step~2 none~phase3~2 phase3 module~run_size~2->none~phase3~2 none~pressure~3 pressure module~run_size~2->none~pressure~3 none~transpose_y_x transpose_Y_X module~run_size~2->none~transpose_y_x none~phase1~4 phase1 module~run_size~2->none~phase1~4 none~pressure~2 pressure module~run_size~2->none~pressure~2 none~phase2~2 phase2 module~run_size~2->none~phase2~2 none~define_step define_step module~run_size~2->none~define_step none~phase3 phase3 module~run_size~2->none~phase3 none~transpose_y_x~3 transpose_Y_X module~run_size~2->none~transpose_y_x~3 proc~solve_navier_stokes solve_navier_stokes module~run_size~2->proc~solve_navier_stokes none~define_step~3 define_step module~run_size~2->none~define_step~3 none~pressure pressure module~run_size~2->none~pressure program~cshear~3 cshear module~run_size~2->program~cshear~3 none~advance advance module~run_size~2->none~advance none~copy_s_n copy_s_n module~run_size~2->none~copy_s_n none~transpose_y_x~2 transpose_Y_X module~run_size~2->none~transpose_y_x~2 none~define_shifts~4 define_shifts module~run_size~2->none~define_shifts~4 none~define_step~4 define_step module~run_size~2->none~define_step~4 proc~solve_navier_stokes~2 solve_navier_stokes module~run_size~2->proc~solve_navier_stokes~2 none~copy_n_s~4 copy_n_s module~run_size~2->none~copy_n_s~4 program~coarray_distributed_transpose coarray_distributed_transpose module~run_size~2->program~coarray_distributed_transpose none~transpose_x_y~3 transpose_X_Y module~run_size~2->none~transpose_x_y~3 none~define_field~3 define_field module~run_size~2->none~define_field~3 none~advance~2 advance module~run_size~2->none~advance~2 none~transpose_x_y~4 transpose_X_Y module~run_size~2->none~transpose_x_y~4 none~define_kspace define_kspace module~run_size~2->none~define_kspace none~copy_n_s~3 copy_n_s module~run_size~2->none~copy_n_s~3 none~pressure~4 pressure module~run_size~2->none~pressure~4 none~define_kspace~2 define_kspace module~run_size~2->none~define_kspace~2 none~phase2~4 phase2 module~run_size~2->none~phase2~4 none~phase3~4 phase3 module~run_size~2->none~phase3~4 none~define_field~2 define_field module~run_size~2->none~define_field~2 none~phase1~3 phase1 module~run_size~2->none~phase1~3 none~copy_s_n~2 copy_s_n module~run_size~2->none~copy_s_n~2 program~mshear mshear module~run_size~2->program~mshear none~copy_n_s~2 copy_n_s module~run_size~2->none~copy_n_s~2 none~define_shifts~2 define_shifts module~run_size~2->none~define_shifts~2 proc~transpose_x_y transpose_X_Y module~run_size~2->proc~transpose_x_y none~define_field define_field module~run_size~2->none~define_field none~transpose_y_x~4 transpose_Y_X module~run_size~2->none~transpose_y_x~4 none~phase2~3 phase2 module~run_size~2->none~phase2~3 proc~transpose_y_x transpose_Y_X module~run_size~2->proc~transpose_y_x none~define_kspace~3 define_kspace module~run_size~2->none~define_kspace~3 none~phase1~2 phase1 module~run_size~2->none~phase1~2 none~transpose_x_y~2 transpose_X_Y module~run_size~2->none~transpose_x_y~2 proc~solve_navier_stokes~3 solve_navier_stokes module~run_size~2->proc~solve_navier_stokes~3 none~copy_n_s copy_n_s module~run_size~2->none~copy_n_s none~define_shifts define_shifts module~run_size~2->none~define_shifts none~define_shifts~3 define_shifts module~run_size~2->none~define_shifts~3 program~cshear~2 cshear module~run_size~2->program~cshear~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, codimension[*] :: first_x integer(kind=int64), public, codimension[*] :: first_y integer(kind=int64), public, codimension[*] :: last_x integer(kind=int64), public, codimension[*] :: last_y integer(kind=int64), public, codimension[*] :: mx integer(kind=int64), public, codimension[*] :: my integer(kind=int64), public :: my_node integer(kind=int64), public :: num_nodes integer(kind=int64), public, codimension[*] :: nx integer(kind=int64), public, codimension[*] :: ny integer(kind=int64), public, codimension[*] :: nz real(kind=real64), public, codimension[*] :: tran_time Subroutines public subroutine broadcast_int (variable) Arguments Type Intent Optional Attributes Name integer(kind=int64), , codimension[*] :: variable public subroutine copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3","tags":"","loc":"module/run_size~2.html","title":"run_size – OpenCoarrays"},{"text":"Uses: iso_fortran_env co_object_interface ForTrilinos_assertion_utility local_field_module module~~global_field_module~~UsesGraph module~global_field_module global_field_module iso_fortran_env iso_fortran_env iso_fortran_env->module~global_field_module module~local_field_module~2 local_field_module iso_fortran_env->module~local_field_module~2 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~local_field_module~2->module~global_field_module module~fortrilinos_assertion_utility->module~global_field_module module~fortrilinos_assertion_utility->module~local_field_module~2 module~co_object_interface~2 co_object_interface module~co_object_interface~2->module~global_field_module module~object_interface~2 object_interface module~object_interface~2->module~local_field_module~2 module~object_interface~2->module~fortrilinos_assertion_utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~global_field_module~~UsedByGraph module~global_field_module global_field_module program~main main module~global_field_module->program~main program~main~2 main module~global_field_module->program~main~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=real64), private :: boundary_vals (num_end_points) real(kind=real64), private, allocatable :: dx integer(kind=int64), private, parameter :: num_end_points = 2_int64 integer(kind=int64), private, allocatable :: num_global_points integer(kind=int64), private, allocatable :: num_local_points Abstract Interfaces abstract interface public pure function initial_condition (x) result(initial_values) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Derived Types type, public, extends( co_object ) :: global_field Components Type Visibility Attributes Name Initial real(kind=real64), private, allocatable :: values (:)[:] Type-Bound Procedures procedure, private :: add_local_field procedure, private :: assign_local_field generic, public :: assignment(=) => assign_local_field procedure, public, nopass :: grid_spacing procedure, private :: multiply generic, public :: operator(*) => multiply generic, public :: operator(+) => add_local_field procedure, public :: output procedure, public :: set procedure, public :: state procedure, public :: x procedure, public :: xx Functions private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) private function grid_spacing () result(delta_x) Arguments None Return Value real(kind=real64) private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs class( global_field ), intent(in) :: rhs Return Value type( local_field ) private pure function state (this) result(local_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:) private pure function x (this) result(this_x) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field ) private function xx (this) result(this_xx) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value type( local_field ) Subroutines private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg private subroutine set (this, initial_function, num_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this procedure( initial_condition ), , pointer :: initial_function integer, intent(in) :: num_points private subroutine synchronize () Arguments None","tags":"","loc":"module/global_field_module.html","title":"global_field_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env ForTrilinos_assertion_utility object_interface module~~local_field_module~2~~UsesGraph module~local_field_module~2 local_field_module iso_fortran_env iso_fortran_env iso_fortran_env->module~local_field_module~2 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~fortrilinos_assertion_utility->module~local_field_module~2 module~object_interface~2 object_interface module~object_interface~2->module~local_field_module~2 module~object_interface~2->module~fortrilinos_assertion_utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~local_field_module~2~~UsedByGraph module~local_field_module~2 local_field_module module~global_field_module global_field_module module~local_field_module~2->module~global_field_module module~global_field_module~2 global_field_module module~local_field_module~2->module~global_field_module~2 program~main main module~global_field_module->program~main program~main~2 main module~global_field_module->program~main~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Derived Types type, public, extends( object ) :: local_field Components Type Visibility Attributes Name Initial real(kind=real64), private, allocatable :: values (:) Type-Bound Procedures procedure, private :: assign_array generic, public :: assignment(=) => assign_array procedure, private, pass(rhs) :: multiply generic, public :: operator(*) => multiply generic, public :: operator(-) => subtract procedure, public :: output procedure, public :: state procedure, private :: subtract Functions private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field ) private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real(kind=real64),\n  allocatable,(:) private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs class( local_field ), intent(in) :: rhs Return Value type( local_field ) Subroutines private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real(kind=real64), intent(in) :: rhs (:) private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"module/local_field_module~2.html","title":"local_field_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env object_interface module~~fortrilinos_assertion_utility~~UsesGraph module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env iso_fortran_env iso_fortran_env->module~fortrilinos_assertion_utility module~object_interface~2 object_interface module~object_interface~2->module~fortrilinos_assertion_utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. @cond Private\n @endcond @endcond Used By module~~fortrilinos_assertion_utility~~UsedByGraph module~fortrilinos_assertion_utility ForTrilinos_assertion_utility module~local_field_module~2 local_field_module module~fortrilinos_assertion_utility->module~local_field_module~2 program~main main module~fortrilinos_assertion_utility->program~main module~global_field_module global_field_module module~fortrilinos_assertion_utility->module~global_field_module module~periodic_2nd_order_module periodic_2nd_order_module module~fortrilinos_assertion_utility->module~periodic_2nd_order_module module~mpi_module mpi_module module~fortrilinos_assertion_utility->module~mpi_module module~local_field_module~2->module~global_field_module module~global_field_module~2 global_field_module module~local_field_module~2->module~global_field_module~2 module~global_field_module->program~main program~main~2 main module~global_field_module->program~main~2 program~main~3 main module~periodic_2nd_order_module->program~main~3 module~mpi_module->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~mpi_share->module~periodic_2nd_order_module module~mpi_share->program~main~3 var panmodulefortrilinos_assertion_utilityUsedByGraph = svgPanZoom('#modulefortrilinos_assertion_utilityUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_string_length = 256 @cond Do not show max_string_length Interfaces public interface assert private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text public interface error_message @cond Interface private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Derived Types type, public :: error_message Components Type Visibility Attributes Name Initial complex, private, allocatable :: cdata (:) character, private, allocatable :: chdata (:) integer, private, allocatable :: idata (:) logical, private, allocatable :: ldata (:) class( object ), private, allocatable :: odata real, private, allocatable :: rdata (:) character(len=max_string_length), private :: string character(len=:), private, allocatable :: string Constructor @cond Interface private  function new_message (message, message_data) Description @endcond Functions private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Subroutines public subroutine assert_identical (integers) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: integers private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text","tags":"","loc":"module/fortrilinos_assertion_utility.html","title":"ForTrilinos_assertion_utility – OpenCoarrays"},{"text":"Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_string_length = 256 Derived Types type, public :: error Components Type Visibility Attributes Name Initial integer, private :: code class(*), private, allocatable :: data_ (:) character(len=max_string_length), private :: message character(len=:), private, allocatable :: message Type-Bound Procedures procedure, public :: define_error generic, public :: error => define_error procedure, public :: error_code Functions private function error_code (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer private function error_message (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value character(len=:),\n  allocatable Subroutines private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:)","tags":"","loc":"module/fortrilinos_error~2.html","title":"ForTrilinos_error – OpenCoarrays"},{"text":"Used By module~~co_object_interface~2~~UsedByGraph module~co_object_interface~2 co_object_interface module~global_field_module global_field_module module~co_object_interface~2->module~global_field_module program~main main module~global_field_module->program~main program~main~2 main module~global_field_module->program~main~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine formatted_output_interface (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, abstract :: co_object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. real, private, allocatable :: dummy_to_facilitate_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined procedure(formatted_output_interface), public :: output procedure, public :: user_defined Functions private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical Subroutines private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this","tags":"","loc":"module/co_object_interface~2.html","title":"co_object_interface – OpenCoarrays"},{"text":"Used By module~~object_interface~2~~UsedByGraph module~object_interface~2 object_interface module~fortrilinos_assertion_utility~2 ForTrilinos_assertion_utility module~object_interface~2->module~fortrilinos_assertion_utility~2 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility module~object_interface~2->module~fortrilinos_assertion_utility module~local_field_module~2 local_field_module module~object_interface~2->module~local_field_module~2 module~periodic_2nd_order_module periodic_2nd_order_module module~object_interface~2->module~periodic_2nd_order_module module~mpi_module mpi_module module~object_interface~2->module~mpi_module proc~new_message~2 new_message module~object_interface~2->proc~new_message~2 proc~new_message new_message module~object_interface~2->proc~new_message module~fortrilinos_assertion_utility->module~local_field_module~2 module~fortrilinos_assertion_utility->module~periodic_2nd_order_module module~fortrilinos_assertion_utility->module~mpi_module program~main main module~fortrilinos_assertion_utility->program~main module~global_field_module global_field_module module~fortrilinos_assertion_utility->module~global_field_module module~local_field_module~2->module~global_field_module module~global_field_module~2 global_field_module module~local_field_module~2->module~global_field_module~2 program~main~3 main module~periodic_2nd_order_module->program~main~3 module~mpi_module->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~global_field_module->program~main program~main~2 main module~global_field_module->program~main~2 module~mpi_share->module~periodic_2nd_order_module module~mpi_share->program~main~3 var panmoduleobject_interface2UsedByGraph = svgPanZoom('#moduleobject_interface2UsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Abstract Interfaces abstract interface private subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, abstract :: object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Type-Bound Procedures procedure, public :: mark_as_defined procedure(output_interface), public :: output procedure, public :: user_defined generic, public :: write(formatted) => output Functions private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical Subroutines private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this","tags":"","loc":"module/object_interface~2.html","title":"object_interface – OpenCoarrays"},{"text":"Uses: local_field_module module~~global_field_module~2~~UsesGraph module~global_field_module~2 global_field_module module~local_field_module~2 local_field_module module~local_field_module~2->module~global_field_module~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~local_field_module~2 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~fortrilinos_assertion_utility->module~local_field_module~2 module~object_interface~2 object_interface module~object_interface~2->module~local_field_module~2 module~object_interface~2->module~fortrilinos_assertion_utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real, private :: boundary_vals (num_end_points) real, private :: dx integer, private, parameter :: num_end_points = 2 integer, private, allocatable :: num_local_points Derived Types type, public :: global_field Components Type Visibility Attributes Name Initial real, private, allocatable :: values (:)[:] Type-Bound Procedures procedure, private :: add_local_field procedure, private :: assign_local_field generic, public :: assignment(=) => assign_local_field generic, public :: global_field_ => set, only_allocate procedure, private :: laplacian procedure, public :: only_allocate generic, public :: operator(+) => add_local_field generic, public :: operator(.laplacian.) => laplacian procedure, public :: set procedure, public :: state Functions private pure function add_local_field (lhs, rhs) result(total) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: lhs type( local_field ), intent(in) :: rhs Return Value type( local_field ) private pure function laplacian (rhs) result(laplacian_rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: rhs Return Value type( local_field ) private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( global_field ), intent(in) :: this Return Value real\n  (size(this%values(:))) Subroutines private subroutine assign_local_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: lhs class( local_field ), intent(in) :: rhs private subroutine only_allocate (this) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this private subroutine set (this, internal_values, boundary_values, domain, num_global_points) Arguments Type Intent Optional Attributes Name class( global_field ), intent(inout) :: this real, intent(in) :: internal_values real, intent(in) :: boundary_values (num_end_points) real, intent(in) :: domain (num_end_points) integer, intent(in) :: num_global_points private subroutine synchronize () Arguments None","tags":"","loc":"module/global_field_module~2.html","title":"global_field_module – OpenCoarrays"},{"text":"Derived Types type, public :: local_field Components Type Visibility Attributes Name Initial real, private, allocatable :: values (:) Type-Bound Procedures procedure, private :: assign_array generic, public :: assignment(=) => assign_array procedure, private :: multiply generic, public :: operator(*) => multiply procedure, public :: state Functions private pure function multiply (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: lhs real, intent(in) :: rhs Return Value type( local_field ) private pure function state (this) result(this_values) Arguments Type Intent Optional Attributes Name class( local_field ), intent(in) :: this Return Value real\n  (size(this%values)) Subroutines private pure subroutine assign_array (lhs, rhs) Arguments Type Intent Optional Attributes Name class( local_field ), intent(inout) :: lhs real, intent(in) :: rhs (:)","tags":"","loc":"module/local_field_module.html","title":"local_field_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env object_interface module~~fortrilinos_assertion_utility~2~~UsesGraph module~fortrilinos_assertion_utility~2 ForTrilinos_assertion_utility iso_fortran_env iso_fortran_env iso_fortran_env->module~fortrilinos_assertion_utility~2 module~object_interface~2 object_interface module~object_interface~2->module~fortrilinos_assertion_utility~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. @cond Private\n @endcond @endcond Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_string_length = 256 @cond Do not show max_string_length Interfaces public interface assert private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text public interface error_message @cond Interface private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Derived Types type, public :: error_message Components Type Visibility Attributes Name Initial complex, private, allocatable :: cdata (:) character, private, allocatable :: chdata (:) integer, private, allocatable :: idata (:) logical, private, allocatable :: ldata (:) class( object ), private, allocatable :: odata real, private, allocatable :: rdata (:) character(len=max_string_length), private :: string character(len=:), private, allocatable :: string Constructor @cond Interface private  function new_message (message, message_data) Description @endcond Functions private function new_message (message, message_data) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message class(*), intent(in), optional :: message_data Return Value type( error_message ) Subroutines public subroutine assert_identical (integers) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: integers private subroutine scalar_assert (assertion, message) Arguments Type Intent Optional Attributes Name logical, intent(in) :: assertion type( error_message ), intent(in) :: message private subroutine vector_assert (assertion, text) Arguments Type Intent Optional Attributes Name logical, intent(in), dimension(:) :: assertion type( error_message ), intent(in), dimension(:) :: text","tags":"","loc":"module/fortrilinos_assertion_utility~2.html","title":"ForTrilinos_assertion_utility – OpenCoarrays"},{"text":"Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_string_length = 256 Derived Types type, public :: error Components Type Visibility Attributes Name Initial integer, private :: code class(*), private, allocatable :: data_ (:) character(len=max_string_length), private :: message character(len=:), private, allocatable :: message Type-Bound Procedures procedure, public :: define_error generic, public :: error => define_error procedure, public :: error_code Functions private function error_code (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value integer private function error_message (this) Arguments Type Intent Optional Attributes Name class( error ), intent(in) :: this Return Value character(len=:),\n  allocatable Subroutines private subroutine define_error (this, new_code, new_message, new_data) Arguments Type Intent Optional Attributes Name class( error ), intent(out) :: this integer, intent(in) :: new_code character(len=*), intent(in) :: new_message class(*), intent(in), optional :: new_data (:)","tags":"","loc":"module/fortrilinos_error.html","title":"ForTrilinos_error – OpenCoarrays"},{"text":"Abstract Interfaces abstract interface private subroutine formatted_output_interface (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, abstract :: co_object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. real, private, allocatable :: dummy_to_facilitate_extension [:] Type-Bound Procedures procedure, public :: mark_as_defined procedure(formatted_output_interface), public :: output procedure, public :: user_defined Functions private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(in) :: this Return Value logical Subroutines private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( co_object ), intent(inout) :: this","tags":"","loc":"module/co_object_interface.html","title":"co_object_interface – OpenCoarrays"},{"text":"Abstract Interfaces abstract interface private subroutine output_interface (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, abstract :: object Components Type Visibility Attributes Name Initial logical, private :: defined = .false. Type-Bound Procedures procedure, public :: mark_as_defined procedure(output_interface), public :: output procedure, public :: user_defined generic, public :: write(formatted) => output Functions private pure function user_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(in) :: this Return Value logical Subroutines private pure subroutine mark_as_defined (this) Arguments Type Intent Optional Attributes Name class( object ), intent(inout) :: this","tags":"","loc":"module/object_interface.html","title":"object_interface – OpenCoarrays"},{"text":"Functions public function get_keyword_values (keys, default_values) result(actual_values) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: keys character(len=*), intent(in), dimension(:) :: default_values Return Value character(len=:),\n  dimension(:),allocatable Subroutines private subroutine assert (test_passes) Arguments Type Intent Optional Attributes Name logical, intent(in) :: test_passes","tags":"","loc":"module/parse_command_line.html","title":"parse_command_line – OpenCoarrays"},{"text":"Uses: iso_fortran_env module~~constants_module~4~~UsesGraph module~constants_module~4 constants_module iso_fortran_env iso_fortran_env iso_fortran_env->module~constants_module~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~constants_module~4~~UsedByGraph module~constants_module~4 constants_module none~transpose_x_y~3 transpose_X_Y module~constants_module~4->none~transpose_x_y~3 none~define_shifts~2 define_shifts module~constants_module~4->none~define_shifts~2 none~define_shifts~3 define_shifts module~constants_module~4->none~define_shifts~3 none~transpose_x_y transpose_X_Y module~constants_module~4->none~transpose_x_y none~phase2~4 phase2 module~constants_module~4->none~phase2~4 none~phase3~4 phase3 module~constants_module~4->none~phase3~4 module~run_size~4 run_size module~constants_module~4->module~run_size~4 none~define_field define_field module~constants_module~4->none~define_field module~run_size~5 run_size module~constants_module~4->module~run_size~5 none~transpose_y_x~4 transpose_Y_X module~constants_module~4->none~transpose_y_x~4 none~transpose_x_y~2 transpose_X_Y module~constants_module~4->none~transpose_x_y~2 none~transpose_x_y~4 transpose_X_Y module~constants_module~4->none~transpose_x_y~4 none~define_field~2 define_field module~constants_module~4->none~define_field~2 none~phase1~4 phase1 module~constants_module~4->none~phase1~4 module~run_size~3 run_size module~constants_module~4->module~run_size~3 none~define_shifts define_shifts module~constants_module~4->none~define_shifts none~define_field~3 define_field module~constants_module~4->none~define_field~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: one = 1_int64 integer(kind=int64), public, parameter :: zero = 0_int64","tags":"","loc":"module/constants_module~4.html","title":"constants_module – OpenCoarrays"},{"text":"Used By module~~random_module~2~~UsedByGraph module~random_module~2 random_module none~define_field define_field module~random_module~2->none~define_field none~define_field~4 define_field module~random_module~2->none~define_field~4 none~define_field~3 define_field module~random_module~2->none~define_field~3 none~define_field~2 define_field module~random_module~2->none~define_field~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Subroutines public subroutine init_random_seed () Arguments None","tags":"","loc":"module/random_module~2.html","title":"random_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env constants_module module~~run_size~3~~UsesGraph module~run_size~3 run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~3 module~constants_module~4 constants_module iso_fortran_env->module~constants_module~4 module~constants_module~4->module~run_size~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real, public, codimension[*] :: b11 real, public, codimension[*] :: b12 real, public, codimension[*] :: b22 real, public, codimension[*] :: b33 real, public :: cfl real(kind=real64), public, codimension[*] :: cpu_time real, public :: dt integer(kind=int64), public, codimension[*] :: first_x integer(kind=int64), public, codimension[*] :: first_y integer(kind=int64), public, codimension[*] :: last_x integer(kind=int64), public, codimension[*] :: last_y real(kind=real64), public, codimension[*] :: max_cpu_time real(kind=real64), public, codimension[*] :: max_sync_time real(kind=real64), public, codimension[*] :: max_total_time real(kind=real64), public, codimension[*] :: max_tran_time real(kind=real64), public, codimension[*] :: min_cpu_time real(kind=real64), public, codimension[*] :: min_sync_time real(kind=real64), public, codimension[*] :: min_total_time real(kind=real64), public, codimension[*] :: min_tran_time integer(kind=int64), public, codimension[*] :: mx integer(kind=int64), public, codimension[*] :: my integer(kind=int64), public :: my_node integer(kind=int64), public, codimension[*] :: nsteps integer(kind=int64), public :: num_nodes integer(kind=int64), public, codimension[*] :: nx integer(kind=int64), public, codimension[*] :: ny integer(kind=int64), public, codimension[*] :: nz integer(kind=int64), public, codimension[*] :: output_step real, public, parameter :: pi = 3.141592653589793 real, public, codimension[*] :: shear real(kind=real64), public, codimension[*] :: sync_time real, public :: time real(kind=real64), public, codimension[*] :: total_time real(kind=real64), public, codimension[*] :: tran_time real, public, codimension[*] :: velmax real, public, codimension[*] :: viscos Subroutines public subroutine copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 public subroutine global_times () Arguments None public subroutine max_velmax () Arguments None","tags":"","loc":"module/run_size~3.html","title":"run_size – OpenCoarrays"},{"text":"Uses: iso_fortran_env module~~constants_module~3~~UsesGraph module~constants_module~3 constants_module iso_fortran_env iso_fortran_env iso_fortran_env->module~constants_module~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: one = 1_int64 integer(kind=int64), public, parameter :: zero = 0_int64","tags":"","loc":"module/constants_module~3.html","title":"constants_module – OpenCoarrays"},{"text":"Subroutines public subroutine init_random_seed () Arguments None","tags":"","loc":"module/random_module~4.html","title":"random_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env constants_module mpi module~~run_size~4~~UsesGraph module~run_size~4 run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~4 module~constants_module~4 constants_module iso_fortran_env->module~constants_module~4 mpi mpi mpi->module~run_size~4 module~constants_module~4->module~run_size~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real, public, codimension[*] :: b11 real, public, codimension[*] :: b12 real, public, codimension[*] :: b22 real, public, codimension[*] :: b33 real, public :: cfl real(kind=real64), public, codimension[*] :: cpu_time_ real, public :: dt integer(kind=int64), public, codimension[*] :: first_x integer(kind=int64), public, codimension[*] :: first_y integer(kind=int64), public, codimension[*] :: last_x integer(kind=int64), public, codimension[*] :: last_y real(kind=real64), public, codimension[*] :: max_cpu_time real(kind=real64), public, codimension[*] :: max_sync_time real(kind=real64), public, codimension[*] :: max_total_time real(kind=real64), public, codimension[*] :: max_tran_time real(kind=real64), public, codimension[*] :: min_cpu_time real(kind=real64), public, codimension[*] :: min_sync_time real(kind=real64), public, codimension[*] :: min_total_time real(kind=real64), public, codimension[*] :: min_tran_time integer(kind=int64), public, codimension[*] :: mx integer(kind=int64), public, codimension[*] :: my integer(kind=int64), public :: my_node integer(kind=int64), public, codimension[*] :: nsteps integer(kind=int64), public :: num_nodes integer(kind=int64), public, codimension[*] :: nx integer(kind=int64), public, codimension[*] :: ny integer(kind=int64), public, codimension[*] :: nz integer(kind=int64), public, codimension[*] :: output_step real, public, parameter :: pi = 3.141592653589793 real, public, codimension[*] :: shear real(kind=real64), public, codimension[*] :: sync_time real, public :: time real(kind=real64), public, codimension[*] :: total_time real(kind=real64), public, codimension[*] :: tran_time real, public, codimension[*] :: velmax real, public, codimension[*] :: viscos Subroutines public subroutine copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 public subroutine global_times () Arguments None public subroutine max_velmax () Arguments None","tags":"","loc":"module/run_size~4.html","title":"run_size – OpenCoarrays"},{"text":"Uses: iso_fortran_env module~~constants_module~~UsesGraph module~constants_module constants_module iso_fortran_env iso_fortran_env iso_fortran_env->module~constants_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: one = 1_int64 integer(kind=int64), public, parameter :: zero = 0_int64","tags":"","loc":"module/constants_module.html","title":"constants_module – OpenCoarrays"},{"text":"Subroutines public subroutine init_random_seed () Arguments None","tags":"","loc":"module/random_module.html","title":"random_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env constants_module module~~run_size~5~~UsesGraph module~run_size~5 run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~5 module~constants_module~4 constants_module iso_fortran_env->module~constants_module~4 module~constants_module~4->module~run_size~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real, public, codimension[*] :: b11 real, public, codimension[*] :: b12 real, public, codimension[*] :: b22 real, public, codimension[*] :: b33 real, public :: cfl real(kind=real64), public, codimension[*] :: cpu_time real, public :: dt integer(kind=int64), public, codimension[*] :: first_x integer(kind=int64), public, codimension[*] :: first_y type(lock_type), public, save :: l_xy_buff [*] type(lock_type), public, save :: l_yx_buff [*] integer(kind=int64), public, codimension[*] :: last_x integer(kind=int64), public, codimension[*] :: last_y real(kind=real64), public, codimension[*] :: max_cpu_time real(kind=real64), public, codimension[*] :: max_sync_time real(kind=real64), public, codimension[*] :: max_total_time real(kind=real64), public, codimension[*] :: max_tran_time real(kind=real64), public, codimension[*] :: min_cpu_time real(kind=real64), public, codimension[*] :: min_sync_time real(kind=real64), public, codimension[*] :: min_total_time real(kind=real64), public, codimension[*] :: min_tran_time integer(kind=int64), public, codimension[*] :: mx integer(kind=int64), public, codimension[*] :: my integer(kind=int64), public :: my_node integer(kind=int64), public, codimension[*] :: nsteps integer(kind=int64), public :: num_nodes integer(kind=int64), public, codimension[*] :: nx integer(kind=int64), public, codimension[*] :: ny integer(kind=int64), public, codimension[*] :: nz integer(kind=int64), public, codimension[*] :: output_step real, public, parameter :: pi = 3.141592653589793 real, public, codimension[*] :: shear real(kind=real64), public, codimension[*] :: sync_time real, public :: time real(kind=real64), public, codimension[*] :: total_time real(kind=real64), public, codimension[*] :: tran_time real, public, codimension[*] :: velmax real, public, codimension[*] :: viscos Subroutines public subroutine copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 public subroutine global_times () Arguments None public subroutine max_velmax () Arguments None","tags":"","loc":"module/run_size~5.html","title":"run_size – OpenCoarrays"},{"text":"Uses: iso_fortran_env module~~constants_module~2~~UsesGraph module~constants_module~2 constants_module iso_fortran_env iso_fortran_env iso_fortran_env->module~constants_module~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public, parameter :: one = 1_int64 integer(kind=int64), public, parameter :: zero = 0_int64","tags":"","loc":"module/constants_module~2.html","title":"constants_module – OpenCoarrays"},{"text":"Subroutines public subroutine init_random_seed () Arguments None","tags":"","loc":"module/random_module~3.html","title":"random_module – OpenCoarrays"},{"text":"Uses: iso_fortran_env module~~run_size~~UsesGraph module~run_size run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: MPI_2DOUBLE_PRECISION = 1275072547 integer, public, parameter :: MPI_2INT = 1275070486 integer, public, parameter :: MPI_2INTEGER = 1275070496 integer, public, parameter :: MPI_2REAL = 1275070497 integer, public, parameter :: MPI_ADDRESS_KIND = 8 integer, public, parameter :: MPI_AINT = 1275070531 integer, public, parameter :: MPI_ANY_SOURCE = -2 integer, public, parameter :: MPI_ANY_TAG = -1 integer, public, parameter :: MPI_APPNUM = 1681915918 character, public :: MPI_ARGVS_NULL (1,1) character, public :: MPI_ARGV_NULL (1) logical, public :: MPI_ASYNC_PROTECTS_NONBLOCKING integer, public, parameter :: MPI_BAND = 1476395014 integer, public, parameter :: MPI_BOR = 1476395016 integer, public :: MPI_BOTTOM integer, public, parameter :: MPI_BSEND_OVERHEAD = 96 integer, public, parameter :: MPI_BXOR = 1476395018 integer, public, parameter :: MPI_BYTE = 1275068685 integer, public, parameter :: MPI_CART = 2 integer, public, parameter :: MPI_CHAR = 1275068673 integer, public, parameter :: MPI_CHARACTER = 1275068698 integer, public, parameter :: MPI_COMBINER_CONTIGUOUS = 3 integer, public, parameter :: MPI_COMBINER_DARRAY = 14 integer, public, parameter :: MPI_COMBINER_DUP = 2 integer, public, parameter :: MPI_COMBINER_F90_COMPLEX = 16 integer, public, parameter :: MPI_COMBINER_F90_INTEGER = 17 integer, public, parameter :: MPI_COMBINER_F90_REAL = 15 integer, public, parameter :: MPI_COMBINER_HINDEXED = 9 integer, public, parameter :: MPI_COMBINER_HINDEXED_BLOCK = 19 integer, public, parameter :: MPI_COMBINER_HINDEXED_INTEGER = 8 integer, public, parameter :: MPI_COMBINER_HVECTOR = 6 integer, public, parameter :: MPI_COMBINER_HVECTOR_INTEGER = 5 integer, public, parameter :: MPI_COMBINER_INDEXED = 7 integer, public, parameter :: MPI_COMBINER_INDEXED_BLOCK = 10 integer, public, parameter :: MPI_COMBINER_NAMED = 1 integer, public, parameter :: MPI_COMBINER_RESIZED = 18 integer, public, parameter :: MPI_COMBINER_STRUCT = 12 integer, public, parameter :: MPI_COMBINER_STRUCT_INTEGER = 11 integer, public, parameter :: MPI_COMBINER_SUBARRAY = 13 integer, public, parameter :: MPI_COMBINER_VECTOR = 4 integer, public, parameter :: MPI_COMM_NULL = 67108864 integer, public, parameter :: MPI_COMM_SELF = 1140850689 integer, public, parameter :: MPI_COMM_TYPE_SHARED = 1 integer, public, parameter :: MPI_COMM_WORLD = 1140850688 integer, public, parameter :: MPI_COMPLEX = 1275070494 integer, public, parameter :: MPI_COMPLEX16 = 1275072554 integer, public, parameter :: MPI_COMPLEX32 = 1275076652 integer, public, parameter :: MPI_COMPLEX8 = 1275070504 integer, public, parameter :: MPI_CONGRUENT = 1 integer, public, parameter :: MPI_COUNT = 1275070533 integer, public, parameter :: MPI_COUNT_KIND = 8 integer, public, parameter :: MPI_CXX_BOOL = 1275068723 integer, public, parameter :: MPI_CXX_DOUBLE_COMPLEX = 1275072565 integer, public, parameter :: MPI_CXX_FLOAT_COMPLEX = 1275070516 integer, public, parameter :: MPI_CXX_LONG_DOUBLE_COMPLEX = 1275076662 integer, public, parameter :: MPI_C_BOOL = 1275068735 integer, public, parameter :: MPI_C_COMPLEX = 1275070528 integer, public, parameter :: MPI_C_DOUBLE_COMPLEX = 1275072577 integer, public, parameter :: MPI_C_FLOAT_COMPLEX = 1275070528 integer, public, parameter :: MPI_C_LONG_DOUBLE_COMPLEX = 1275076674 integer, public, parameter :: MPI_DATATYPE_NULL = 201326592 integer, public, parameter :: MPI_DISPLACEMENT_CURRENT = -54278278 integer, public, parameter :: MPI_DISTRIBUTE_BLOCK = 121 integer, public, parameter :: MPI_DISTRIBUTE_CYCLIC = 122 integer, public, parameter :: MPI_DISTRIBUTE_DFLT_DARG = -49767 integer, public, parameter :: MPI_DISTRIBUTE_NONE = 123 integer, public, parameter :: MPI_DIST_GRAPH = 3 integer, public, parameter :: MPI_DOUBLE = 1275070475 integer, public, parameter :: MPI_DOUBLE_COMPLEX = 1275072546 integer, public, parameter :: MPI_DOUBLE_INT = -1946157055 integer, public, parameter :: MPI_DOUBLE_PRECISION = 1275070495 integer, public :: MPI_ERRCODES_IGNORE (1) integer, public, parameter :: MPI_ERRHANDLER_NULL = 335544320 integer, public, parameter :: MPI_ERROR = 5 integer, public, parameter :: MPI_ERRORS_ARE_FATAL = 1409286144 integer, public, parameter :: MPI_ERRORS_RETURN = 1409286145 integer, public, parameter :: MPI_ERR_ACCESS = 20 integer, public, parameter :: MPI_ERR_AMODE = 21 integer, public, parameter :: MPI_ERR_ARG = 12 integer, public, parameter :: MPI_ERR_ASSERT = 53 integer, public, parameter :: MPI_ERR_BAD_FILE = 22 integer, public, parameter :: MPI_ERR_BASE = 46 integer, public, parameter :: MPI_ERR_BUFFER = 1 integer, public, parameter :: MPI_ERR_COMM = 5 integer, public, parameter :: MPI_ERR_CONVERSION = 23 integer, public, parameter :: MPI_ERR_COUNT = 2 integer, public, parameter :: MPI_ERR_DIMS = 11 integer, public, parameter :: MPI_ERR_DISP = 52 integer, public, parameter :: MPI_ERR_DUP_DATAREP = 24 integer, public, parameter :: MPI_ERR_FILE = 27 integer, public, parameter :: MPI_ERR_FILE_EXISTS = 25 integer, public, parameter :: MPI_ERR_FILE_IN_USE = 26 integer, public, parameter :: MPI_ERR_GROUP = 8 integer, public, parameter :: MPI_ERR_INFO = 28 integer, public, parameter :: MPI_ERR_INFO_KEY = 29 integer, public, parameter :: MPI_ERR_INFO_NOKEY = 31 integer, public, parameter :: MPI_ERR_INFO_VALUE = 30 integer, public, parameter :: MPI_ERR_INTERN = 16 integer, public, parameter :: MPI_ERR_IN_STATUS = 17 integer, public, parameter :: MPI_ERR_IO = 32 integer, public, parameter :: MPI_ERR_KEYVAL = 48 integer, public, parameter :: MPI_ERR_LASTCODE = 1073741823 integer, public, parameter :: MPI_ERR_LOCKTYPE = 47 integer, public, parameter :: MPI_ERR_NAME = 33 integer, public, parameter :: MPI_ERR_NOT_SAME = 35 integer, public, parameter :: MPI_ERR_NO_MEM = 34 integer, public, parameter :: MPI_ERR_NO_SPACE = 36 integer, public, parameter :: MPI_ERR_NO_SUCH_FILE = 37 integer, public, parameter :: MPI_ERR_OP = 9 integer, public, parameter :: MPI_ERR_OTHER = 15 integer, public, parameter :: MPI_ERR_PENDING = 18 integer, public, parameter :: MPI_ERR_PORT = 38 integer, public, parameter :: MPI_ERR_QUOTA = 39 integer, public, parameter :: MPI_ERR_RANK = 6 integer, public, parameter :: MPI_ERR_READ_ONLY = 40 integer, public, parameter :: MPI_ERR_REQUEST = 19 integer, public, parameter :: MPI_ERR_RMA_ATTACH = 56 integer, public, parameter :: MPI_ERR_RMA_CONFLICT = 49 integer, public, parameter :: MPI_ERR_RMA_FLAVOR = 58 integer, public, parameter :: MPI_ERR_RMA_RANGE = 55 integer, public, parameter :: MPI_ERR_RMA_SHARED = 57 integer, public, parameter :: MPI_ERR_RMA_SYNC = 50 integer, public, parameter :: MPI_ERR_ROOT = 7 integer, public, parameter :: MPI_ERR_SERVICE = 41 integer, public, parameter :: MPI_ERR_SIZE = 51 integer, public, parameter :: MPI_ERR_SPAWN = 42 integer, public, parameter :: MPI_ERR_TAG = 4 integer, public, parameter :: MPI_ERR_TOPOLOGY = 10 integer, public, parameter :: MPI_ERR_TRUNCATE = 14 integer, public, parameter :: MPI_ERR_TYPE = 3 integer, public, parameter :: MPI_ERR_UNKNOWN = 13 integer, public, parameter :: MPI_ERR_UNSUPPORTED_DATAREP = 43 integer, public, parameter :: MPI_ERR_UNSUPPORTED_OPERATION = 44 integer, public, parameter :: MPI_ERR_WIN = 45 integer, public, parameter :: MPI_FILE_NULL = 0 integer, public, parameter :: MPI_FLOAT = 1275069450 integer, public, parameter :: MPI_FLOAT_INT = -1946157056 integer, public, parameter :: MPI_GRAPH = 1 integer, public, parameter :: MPI_GROUP_EMPTY = 1207959552 integer, public, parameter :: MPI_GROUP_NULL = 134217728 integer, public, parameter :: MPI_HOST = 1681915908 integer, public, parameter :: MPI_IDENT = 0 integer, public, parameter :: MPI_INFO_ENV = 1543503873 integer, public, parameter :: MPI_INFO_NULL = 469762048 integer, public, parameter :: MPI_INT = 1275069445 integer, public, parameter :: MPI_INT16_T = 1275068984 integer, public, parameter :: MPI_INT32_T = 1275069497 integer, public, parameter :: MPI_INT64_T = 1275070522 integer, public, parameter :: MPI_INT8_T = 1275068727 integer, public, parameter :: MPI_INTEGER = 1275069467 integer, public, parameter :: MPI_INTEGER1 = 1275068717 integer, public, parameter :: MPI_INTEGER16 = MPI_DATATYPE_NULL integer, public, parameter :: MPI_INTEGER2 = 1275068975 integer, public, parameter :: MPI_INTEGER4 = 1275069488 integer, public, parameter :: MPI_INTEGER8 = 1275070513 integer, public, parameter :: MPI_INTEGER_KIND = 4 integer, public :: MPI_IN_PLACE integer, public, parameter :: MPI_IO = 1681915910 integer, public, parameter :: MPI_KEYVAL_INVALID = 603979776 integer, public, parameter :: MPI_LAND = 1476395013 integer, public, parameter :: MPI_LASTUSEDCODE = 1681915916 integer, public, parameter :: MPI_LB = 1275068432 integer, public, parameter :: MPI_LOCK_EXCLUSIVE = 234 integer, public, parameter :: MPI_LOCK_SHARED = 235 integer, public, parameter :: MPI_LOGICAL = 1275069469 integer, public, parameter :: MPI_LONG = 1275070471 integer, public, parameter :: MPI_LONG_DOUBLE = 1275072524 integer, public, parameter :: MPI_LONG_DOUBLE_INT = -1946157052 integer, public, parameter :: MPI_LONG_INT = -1946157054 integer, public, parameter :: MPI_LONG_LONG = 1275070473 integer, public, parameter :: MPI_LONG_LONG_INT = 1275070473 integer, public, parameter :: MPI_LOR = 1476395015 integer, public, parameter :: MPI_LXOR = 1476395017 integer, public, parameter :: MPI_MAX = 1476395009 integer, public, parameter :: MPI_MAXLOC = 1476395020 integer, public, parameter :: MPI_MAX_DATAREP_STRING = 127 integer, public, parameter :: MPI_MAX_ERROR_STRING = 512-1 integer, public, parameter :: MPI_MAX_INFO_KEY = 254 integer, public, parameter :: MPI_MAX_INFO_VAL = 1023 integer, public, parameter :: MPI_MAX_LIBRARY_VERSION_STRING = 8192-1 integer, public, parameter :: MPI_MAX_OBJECT_NAME = 127 integer, public, parameter :: MPI_MAX_PORT_NAME = 255 integer, public, parameter :: MPI_MAX_PROCESSOR_NAME = 128-1 integer, public, parameter :: MPI_MESSAGE_NO_PROC = 1811939328 integer, public, parameter :: MPI_MESSAGE_NULL = 738197504 integer, public, parameter :: MPI_MIN = 1476395010 integer, public, parameter :: MPI_MINLOC = 1476395019 integer, public, parameter :: MPI_MODE_APPEND = 128 integer, public, parameter :: MPI_MODE_CREATE = 1 integer, public, parameter :: MPI_MODE_DELETE_ON_CLOSE = 16 integer, public, parameter :: MPI_MODE_EXCL = 64 integer, public, parameter :: MPI_MODE_NOCHECK = 1024 integer, public, parameter :: MPI_MODE_NOPRECEDE = 8192 integer, public, parameter :: MPI_MODE_NOPUT = 4096 integer, public, parameter :: MPI_MODE_NOSTORE = 2048 integer, public, parameter :: MPI_MODE_NOSUCCEED = 16384 integer, public, parameter :: MPI_MODE_RDONLY = 2 integer, public, parameter :: MPI_MODE_RDWR = 8 integer, public, parameter :: MPI_MODE_SEQUENTIAL = 256 integer, public, parameter :: MPI_MODE_UNIQUE_OPEN = 32 integer, public, parameter :: MPI_MODE_WRONLY = 4 integer, public, parameter :: MPI_NO_OP = 1476395022 integer, public, parameter :: MPI_OFFSET = 1275070532 integer, public, parameter :: MPI_OFFSET_KIND = 8 integer, public, parameter :: MPI_OP_NULL = 402653184 integer, public, parameter :: MPI_ORDER_C = 56 integer, public, parameter :: MPI_ORDER_FORTRAN = 57 integer, public, parameter :: MPI_PACKED = 1275068687 integer, public, parameter :: MPI_PROC_NULL = -1 integer, public, parameter :: MPI_PROD = 1476395012 integer, public, parameter :: MPI_REAL = 1275069468 integer, public, parameter :: MPI_REAL16 = 1275072555 integer, public, parameter :: MPI_REAL4 = 1275069479 integer, public, parameter :: MPI_REAL8 = 1275070505 integer, public, parameter :: MPI_REPLACE = 1476395021 integer, public, parameter :: MPI_REQUEST_NULL = 738197504 integer, public, parameter :: MPI_ROOT = -3 integer, public, parameter :: MPI_SEEK_CUR = 602 integer, public, parameter :: MPI_SEEK_END = 604 integer, public, parameter :: MPI_SEEK_SET = 600 integer, public, parameter :: MPI_SHORT = 1275068931 integer, public, parameter :: MPI_SHORT_INT = -1946157053 integer, public, parameter :: MPI_SIGNED_CHAR = 1275068696 integer, public, parameter :: MPI_SIMILAR = 2 integer, public, parameter :: MPI_SOURCE = 3 integer, public :: MPI_STATUSES_IGNORE (MPI_STATUS_SIZE,1) integer, public :: MPI_STATUS_IGNORE (MPI_STATUS_SIZE) integer, public, parameter :: MPI_STATUS_SIZE = 5 logical, public :: MPI_SUBARRAYS_SUPPORTED integer, public, parameter :: MPI_SUBVERSION = 1 integer, public, parameter :: MPI_SUCCESS = 0 integer, public, parameter :: MPI_SUM = 1476395011 integer, public, parameter :: MPI_TAG = 4 integer, public, parameter :: MPI_TAG_UB = 1681915906 integer, public, parameter :: MPI_THREAD_FUNNELED = 1 integer, public, parameter :: MPI_THREAD_MULTIPLE = 3 integer, public, parameter :: MPI_THREAD_SERIALIZED = 2 integer, public, parameter :: MPI_THREAD_SINGLE = 0 integer, public, parameter :: MPI_TYPECLASS_COMPLEX = 3 integer, public, parameter :: MPI_TYPECLASS_INTEGER = 2 integer, public, parameter :: MPI_TYPECLASS_REAL = 1 integer, public, parameter :: MPI_UB = 1275068433 integer, public, parameter :: MPI_UINT16_T = 1275068988 integer, public, parameter :: MPI_UINT32_T = 1275069501 integer, public, parameter :: MPI_UINT64_T = 1275070526 integer, public, parameter :: MPI_UINT8_T = 1275068731 integer, public, parameter :: MPI_UNDEFINED = (-32766) integer, public, parameter :: MPI_UNEQUAL = 3 integer, public, parameter :: MPI_UNIVERSE_SIZE = 1681915914 integer, public, parameter :: MPI_UNSIGNED = 1275069446 integer, public, parameter :: MPI_UNSIGNED_CHAR = 1275068674 integer, public, parameter :: MPI_UNSIGNED_LONG = 1275070472 integer, public, parameter :: MPI_UNSIGNED_LONG_LONG = 1275070489 integer, public, parameter :: MPI_UNSIGNED_SHORT = 1275068932 integer, public :: MPI_UNWEIGHTED integer, public, parameter :: MPI_VERSION = 3 integer, public, parameter :: MPI_WCHAR = 1275069454 integer, public :: MPI_WEIGHTS_EMPTY integer, public, parameter :: MPI_WIN_BASE = 1711276034 integer, public, parameter :: MPI_WIN_CREATE_FLAVOR = 1711276040 integer, public, parameter :: MPI_WIN_DISP_UNIT = 1711276038 integer, public, parameter :: MPI_WIN_FLAVOR_ALLOCATE = 2 integer, public, parameter :: MPI_WIN_FLAVOR_CREATE = 1 integer, public, parameter :: MPI_WIN_FLAVOR_DYNAMIC = 3 integer, public, parameter :: MPI_WIN_FLAVOR_SHARED = 4 integer, public, parameter :: MPI_WIN_MODEL = 1711276042 integer, public, parameter :: MPI_WIN_NULL = 536870912 integer, public, parameter :: MPI_WIN_SEPARATE = 1 integer, public, parameter :: MPI_WIN_SIZE = 1711276036 integer, public, parameter :: MPI_WIN_UNIFIED = 2 integer, public, parameter :: MPI_WTIME_IS_GLOBAL = 1681915912 real, public :: b11 real, public :: b12 real, public :: b22 real, public :: b33 real, public :: cfl real(kind=real64), public :: cpu_time real, public :: dt integer(kind=int64), public :: first_x integer(kind=int64), public :: first_y integer(kind=int64), public :: ierror integer(kind=int64), public :: last_x integer(kind=int64), public :: last_y real(kind=real64), public :: max_cpu_time real(kind=real64), public :: max_total_time real(kind=real64), public :: max_tran_time real, public :: max_velmax real(kind=real64), public :: min_cpu_time real(kind=real64), public :: min_total_time real(kind=real64), public :: min_tran_time integer(kind=int64), public :: mx integer(kind=int64), public :: my integer(kind=int64), public :: my_node integer(kind=int64), public :: nsteps integer(kind=int64), public :: num_nodes integer(kind=int64), public :: nx integer(kind=int64), public :: ny integer(kind=int64), public :: nz integer(kind=int64), public :: output_step real, public, parameter :: pi = 3.141592653589793 real, public :: shear real, public :: time real(kind=real64), public :: total_time real(kind=real64), public :: tran_time real, public :: velmax real, public :: viscos Subroutines public subroutine copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3 public subroutine global_times () Arguments None","tags":"","loc":"module/run_size.html","title":"run_size – OpenCoarrays"},{"text":"Uses: kind_parameters module~~input_file~~UsesGraph module~input_file input_file module~kind_parameters kind_parameters module~kind_parameters->module~input_file Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~input_file~~UsedByGraph module~input_file input_file program~main~3 main module~input_file->program~main~3 module~periodic_2nd_order_module periodic_2nd_order_module module~input_file->module~periodic_2nd_order_module module~periodic_2nd_order_module->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=ikind), public, parameter :: grid_resolution = 819200","tags":"","loc":"module/input_file.html","title":"input_file – OpenCoarrays"},{"text":"Used By module~~kind_parameters~~UsedByGraph module~kind_parameters kind_parameters program~main~3 main module~kind_parameters->program~main~3 module~mpi_module mpi_module module~kind_parameters->module~mpi_module module~input_file input_file module~kind_parameters->module~input_file module~periodic_2nd_order_module periodic_2nd_order_module module~kind_parameters->module~periodic_2nd_order_module module~initializer initializer module~kind_parameters->module~initializer module~mpi_module->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~input_file->program~main~3 module~input_file->module~periodic_2nd_order_module module~periodic_2nd_order_module->program~main~3 module~initializer->program~main~3 module~mpi_share->program~main~3 module~mpi_share->module~periodic_2nd_order_module Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, parameter :: ckind = selected_char_kind('default') integer, private, parameter :: decades = 9 integer, private, parameter :: digits = 8 integer, public, parameter :: ikind = selected_int_kind(decades) integer, public, parameter :: rkind = selected_real_kind(digits)","tags":"","loc":"module/kind_parameters.html","title":"kind_parameters – OpenCoarrays"},{"text":"Uses: kind_parameters module~~initializer~~UsesGraph module~initializer initializer module~kind_parameters kind_parameters module~kind_parameters->module~initializer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~initializer~~UsedByGraph module~initializer initializer program~main~3 main module~initializer->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Functions public pure function u_initial (x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) public pure function zero (x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"module/initializer.html","title":"initializer – OpenCoarrays"},{"text":"Uses: kind_parameters object_interface ForTrilinos_assertion_utility shared module~~mpi_module~~UsesGraph module~mpi_module mpi_module module~fortrilinos_assertion_utility ForTrilinos_assertion_utility module~fortrilinos_assertion_utility->module~mpi_module module~shared shared module~shared->module~mpi_module module~kind_parameters kind_parameters module~kind_parameters->module~mpi_module module~object_interface~2 object_interface module~object_interface~2->module~mpi_module module~object_interface~2->module~fortrilinos_assertion_utility iso_fortran_env iso_fortran_env iso_fortran_env->module~fortrilinos_assertion_utility mpi mpi mpi->module~shared Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~mpi_module~~UsedByGraph module~mpi_module mpi_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~periodic_2nd_order_module periodic_2nd_order_module module~mpi_module->module~periodic_2nd_order_module module~mpi_share->module~periodic_2nd_order_module program~main~3 main module~mpi_share->program~main~3 module~periodic_2nd_order_module->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=ikind), private :: program_status = 0 Derived Types type, public, extends( object ) :: mpi_class Type-Bound Procedures procedure, public, nopass :: barrier procedure, public, nopass :: mpi_begin procedure, public, nopass :: mpi_end procedure, public, nopass :: oned_message procedure, public :: output Subroutines private subroutine barrier () Arguments None private subroutine mpi_begin () Arguments None private subroutine mpi_end () Arguments None private subroutine oned_message (periodic, local_grid_resolution, left_sub, right_sub) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in), dimension(:) :: periodic integer(kind=ikind), intent(in) :: local_grid_resolution real(kind=rkind), intent(inout) :: left_sub real(kind=rkind), intent(inout) :: right_sub private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( mpi_class ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","loc":"module/mpi_module.html","title":"mpi_module – OpenCoarrays"},{"text":"Uses: mpi_module module~~mpi_share~~UsesGraph module~mpi_share mpi_share module~mpi_module mpi_module module~mpi_module->module~mpi_share module~fortrilinos_assertion_utility ForTrilinos_assertion_utility module~fortrilinos_assertion_utility->module~mpi_module module~shared shared module~shared->module~mpi_module module~kind_parameters kind_parameters module~kind_parameters->module~mpi_module module~object_interface~2 object_interface module~object_interface~2->module~mpi_module module~object_interface~2->module~fortrilinos_assertion_utility iso_fortran_env iso_fortran_env iso_fortran_env->module~fortrilinos_assertion_utility mpi mpi mpi->module~shared Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~mpi_share~~UsedByGraph module~mpi_share mpi_share program~main~3 main module~mpi_share->program~main~3 module~periodic_2nd_order_module periodic_2nd_order_module module~mpi_share->module~periodic_2nd_order_module module~periodic_2nd_order_module->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial type( mpi_class ), public :: mpi_object","tags":"","loc":"module/mpi_share.html","title":"mpi_share – OpenCoarrays"},{"text":"Uses: kind_parameters ForTrilinos_assertion_utility object_interface input_file mpi_module mpi_share shared module~~periodic_2nd_order_module~~UsesGraph module~periodic_2nd_order_module periodic_2nd_order_module module~object_interface~2 object_interface module~object_interface~2->module~periodic_2nd_order_module module~fortrilinos_assertion_utility ForTrilinos_assertion_utility module~object_interface~2->module~fortrilinos_assertion_utility module~mpi_module mpi_module module~object_interface~2->module~mpi_module module~fortrilinos_assertion_utility->module~periodic_2nd_order_module module~fortrilinos_assertion_utility->module~mpi_module module~mpi_module->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~input_file input_file module~input_file->module~periodic_2nd_order_module module~mpi_share->module~periodic_2nd_order_module module~shared shared module~shared->module~periodic_2nd_order_module module~shared->module~mpi_module module~kind_parameters kind_parameters module~kind_parameters->module~periodic_2nd_order_module module~kind_parameters->module~mpi_module module~kind_parameters->module~input_file iso_fortran_env iso_fortran_env iso_fortran_env->module~fortrilinos_assertion_utility mpi mpi mpi->module~shared var panmoduleperiodic_2nd_order_moduleUsesGraph = svgPanZoom('#moduleperiodic_2nd_order_moduleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~periodic_2nd_order_module~~UsedByGraph module~periodic_2nd_order_module periodic_2nd_order_module program~main~3 main module~periodic_2nd_order_module->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: local_grid (:) real(kind=rkind), private, parameter :: pi = acos(-1._rkind) real(kind=rkind), private :: time = 0. Abstract Interfaces abstract interface public pure function initial_field (x) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Derived Types type, public, extends( object ) :: periodic_2nd_order Components Type Visibility Attributes Name Initial real(kind=rkind), public, allocatable :: global_f (:) Type-Bound Procedures procedure, public :: add => add_field procedure, public :: assign_field generic, public :: assignment(=) => assign_field procedure, public :: construct procedure, public, nopass :: get_time procedure, public :: has_a_zero_at procedure, public :: local_state procedure, public :: multiply => multiply_field procedure, public :: multiply_real generic, public :: operator(*) => multiply generic, public :: operator(*) => multiply_real generic, public :: operator(+) => add generic, public :: operator(-) => subtract procedure, public :: output procedure, public :: runge_kutta_2nd_step => rk2_dt procedure, public, nopass :: set_time procedure, public :: subtract procedure, public, nopass :: this_image_contains procedure, public :: x => df_dx procedure, public :: xx => d2f_dx2 Functions private function add_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) private function d2f_dx2 (this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order ) private function df_dx (this) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value type( periodic_2nd_order ) private pure function get_time () result(t) Arguments None Return Value real(kind=rkind) private pure function has_a_zero_at (this, expected_location) result(zero_at_expected_location) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: expected_location Return Value logical private pure function local_state (this) result(local_state_vector) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this Return Value real(kind=rkind),\n  allocatable,(:) private function multiply_field (this, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) private function multiply_real (lhs, rhs) result(product_) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs real(kind=rkind), intent(in) :: rhs Return Value type( periodic_2nd_order ) private function rk2_dt (this, nu, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this real(kind=rkind), intent(in) :: nu integer(kind=ikind), intent(in) :: num_grid_pts Return Value real(kind=rkind) private pure function subtract (lhs, rhs) result(difference) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: lhs class( periodic_2nd_order ), intent(in) :: rhs Return Value type( periodic_2nd_order ) private pure function this_image_contains (location) result(within_bounds) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: location Return Value logical Subroutines private subroutine assign_field (lhs, rhs) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: lhs type( periodic_2nd_order ), intent(in) :: rhs private subroutine construct (this, initial, num_grid_pts) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(inout) :: this procedure( initial_field ), intent(in), pointer :: initial integer(kind=ikind), intent(in) :: num_grid_pts private subroutine output (this, unit, iotype, v_list, iostat, iomsg) Arguments Type Intent Optional Attributes Name class( periodic_2nd_order ), intent(in) :: this integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg private subroutine set_time (time_stamp) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: time_stamp","tags":"","loc":"module/periodic_2nd_order_module.html","title":"periodic_2nd_order_module – OpenCoarrays"},{"text":"Uses: mpi module~~shared~~UsesGraph module~shared shared mpi mpi mpi->module~shared Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~shared~~UsedByGraph module~shared shared module~mpi_module mpi_module module~shared->module~mpi_module module~periodic_2nd_order_module periodic_2nd_order_module module~shared->module~periodic_2nd_order_module program~main~3 main module~shared->program~main~3 module~mpi_module->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_module->module~mpi_share module~periodic_2nd_order_module->program~main~3 module~mpi_share->module~periodic_2nd_order_module module~mpi_share->program~main~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: MPI_COMM_CART integer, public :: ierr integer, public :: left_id integer, public :: local_grid_resolution integer, public, parameter :: max_local_resolution = 10000 integer, public :: my_id integer, public :: num_procs integer, public, parameter :: return_data_tag = 2002 integer, public :: right_id integer, public, parameter :: root_process = 0 integer, public, parameter :: send_data_tag = 2001 integer, public :: status (MPI_STATUS_SIZE) integer, public :: tag","tags":"","loc":"module/shared.html","title":"shared – OpenCoarrays"},{"text":"Uses: iso_fortran_env mpi module~~mpi_run_size~~UsesGraph module~mpi_run_size mpi_run_size iso_fortran_env iso_fortran_env iso_fortran_env->module~mpi_run_size mpi mpi mpi->module~mpi_run_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Used By module~~mpi_run_size~~UsedByGraph module~mpi_run_size mpi_run_size program~mpi_distributed_transpose mpi_distributed_transpose module~mpi_run_size->program~mpi_distributed_transpose proc~transpose_x_y~2 transpose_X_Y module~mpi_run_size->proc~transpose_x_y~2 proc~transpose_y_x~2 transpose_Y_X module~mpi_run_size->proc~transpose_y_x~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer(kind=int64), public :: first_x integer(kind=int64), public :: first_y integer(kind=int64), public :: last_x integer(kind=int64), public :: last_y integer(kind=int64), public :: mx integer(kind=int64), public :: my integer(kind=int64), public :: my_node integer(kind=int64), public :: num_nodes integer(kind=int64), public :: nx integer(kind=int64), public :: ny integer(kind=int64), public :: nz real(kind=real64), public :: tran_time Subroutines public subroutine mpi_copy3 (A, B, n1, sA1, sB1, n2, sA2, sB2, n3, sA3, sB3) Arguments Type Intent Optional Attributes Name complex, intent(in) :: A (0:*) complex, intent(out) :: B (0:*) integer(kind=int64), intent(in) :: n1 integer(kind=int64), intent(in) :: sA1 integer(kind=int64), intent(in) :: sB1 integer(kind=int64), intent(in) :: n2 integer(kind=int64), intent(in) :: sA2 integer(kind=int64), intent(in) :: sB2 integer(kind=int64), intent(in) :: n3 integer(kind=int64), intent(in) :: sA3 integer(kind=int64), intent(in) :: sB3","tags":"","loc":"module/mpi_run_size.html","title":"mpi_run_size – OpenCoarrays"},{"text":"Used By module~~co_intrinsics_module~~UsedByGraph module~co_intrinsics_module co_intrinsics_module program~main~7 main module~co_intrinsics_module->program~main~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces public interface co_all private subroutine co_all_logical (a) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: a (:) public interface co_product private subroutine co_product_c_int (a) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout) :: a private subroutine co_product_c_double (a) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout) :: a Subroutines private subroutine co_all_logical (a) Arguments Type Intent Optional Attributes Name logical, intent(inout) :: a (:) private subroutine co_product_c_double (a) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout) :: a private subroutine co_product_c_int (a) Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(inout) :: a","tags":"","loc":"module/co_intrinsics_module.html","title":"co_intrinsics_module – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, parameter :: MAX_STRING = 100 character(len=MAX_STRING) :: greeting [*] integer :: image","tags":"","loc":"program/hello_multiverse.html","title":"hello_multiverse – OpenCoarrays"},{"text":"Uses: run_size program~~coarray_distributed_transpose~~UsesGraph program~coarray_distributed_transpose coarray_distributed_transpose module~run_size~2 run_size module~run_size~2->program~coarray_distributed_transpose iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~2 mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~coarray_distributed_transpose~~CallsGraph program~coarray_distributed_transpose coarray_distributed_transpose proc~broadcast_int broadcast_int program~coarray_distributed_transpose->proc~broadcast_int proc~transpose_y_x transpose_Y_X program~coarray_distributed_transpose->proc~transpose_y_x proc~transpose_x_y transpose_X_Y program~coarray_distributed_transpose->proc~transpose_x_y walltime walltime proc~transpose_y_x->walltime proc~copy3 copy3 proc~transpose_y_x->proc~copy3 proc~transpose_x_y->walltime proc~transpose_x_y->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial complex, allocatable :: bufr_X_Y (:,:,:,:) complex, allocatable :: bufr_Y_X (:,:,:,:) integer(kind=int64) :: iter integer(kind=int64) :: msg_size complex, allocatable :: u (:,:,:,:)[:] complex, allocatable :: ur (:,:,:,:)[:] integer(kind=int64) :: x integer(kind=int64) :: y integer(kind=int64) :: z Subroutines subroutine transpose_X_Y () Arguments None subroutine transpose_Y_X () Arguments None Source Code program coarray_distributed_transpose !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use run_size implicit none complex , allocatable :: u (:,:,:,:)[:] ! u(nz,4,first_x:last_x,ny)[*]    !(*-- ny = my * num_nodes --*) complex , allocatable :: ur (:,:,:,:)[:] !ur(nz,4,first_y:last_y,nx/2)[*]  !(*-- nx/2 = mx * num_nodes --*) complex , allocatable :: bufr_X_Y (:,:,:,:) complex , allocatable :: bufr_Y_X (:,:,:,:) integer ( int64 ) :: x , y , z , msg_size , iter num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then !write(6,*) \"nx,ny,nz : \";      read(5,*) nx, ny, nz nx = 32 ; ny = 32 ; nz = 32 call broadcast_int ( nx ); call broadcast_int ( ny ); call broadcast_int ( nz ); end if sync all !-- other nodes wait for broadcast! if ( mod ( ny , num_nodes ) == 0 ) then ; my = ny / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \" ny not multiple of num_nodes\" ; error stop end if if ( mod ( nx / 2 , num_nodes ) == 0 ) then ; mx = nx / 2 / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \"nx/2 not multiple of num_nodes\" ; error stop end if first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx allocate ( u ( nz , 4 , first_x : last_x , ny ) [ * ] ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 )[ * ] ) !(*-- x-z planes --*) allocate ( bufr_X_Y ( nz , 4 , mx , my ) ) allocate ( bufr_Y_X ( nz , 4 , my , mx ) ) msg_size = nz * 4 * mx * my !-- message size (complex data items) !---------  initialize data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz u ( z , 1 , x , y ) = x u ( z , 2 , x , y ) = y u ( z , 3 , x , y ) = z end do end do end do tran_time = 0 do iter = 1 , 2 !--- 2 transform pairs per second-order time step !---------  transpose data u -> ur (mx y-z planes to my x-z planes per image)  -------- ur = 0 call transpose_X_Y !--------- test data ur (my x-z planes per image) ---------- do x = 1 , nx / 2 do y = first_y , last_y do z = 1 , nz if ( real ( ur ( z , 1 , y , x )) /= x . or . real ( ur ( z , 2 , y , x )) /= y . or . real ( ur ( z , 3 , y , x )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_X_Y failed:  image \" , my_node & , \" X \" , real ( ur ( z , 1 , y , x )), x , \"  Y \" , real ( ur ( z , 2 , y , x )), y , \"  Z \" , real ( ur ( z , 3 , y , x )), z stop end if end do end do end do !---------  transpose data ur -> u (my x-z planes to mx y-z planes per image)  -------- u = 0 call transpose_Y_X !--------- test data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( real ( u ( z , 1 , x , y )) /= x . or . real ( u ( z , 2 , x , y )) /= y . or . real ( u ( z , 3 , x , y )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_Y_X failed:  image \" , my_node & , \" X \" , real ( u ( z , 1 , x , y )), x , \"  Y \" , real ( u ( z , 2 , x , y )), y , \"  Z \" , real ( u ( z , 3 , x , y )), z stop end if end do end do end do end do sync all if ( my_node == 1 ) write ( 6 , fmt = \"(A,f8.3)\" ) \"test passed:  tran_time \" , tran_time deallocate ( bufr_X_Y ); deallocate ( bufr_Y_X ) !=========================   end of main executable  ============================= contains !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_X_Y (:,:,:,:) = u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_X_Y , ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ), bufr_Y_X & !-- intra-node transpose to buffer , nz * 3 , 1 _ 8 , 1 _ 8 & , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] = bufr_Y_X (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use run_size implicit none integer ( int64 ) :: i , stage sync all !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () call copy3 ( ur ( 1 , 1 , first_y , 1 + ( my_node - 1 ) * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + ( my_node - 1 ) * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) bufr_Y_X (:,:,:,:) = ur (:,:,:, 1 + ( my_node - 1 ) * mx : my_node * mx )[ i ] !-- inter-node transpose to buffer call copy3 ( bufr_Y_X , u ( 1 , 1 , first_x , 1 + ( i - 1 ) * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else do stage = 1 , num_nodes - 1 i = 1 + mod ( my_node - 1 + stage , num_nodes ) call copy3 ( ur ( 1 , 1 , first_y , 1 + ( i - 1 ) * mx ), bufr_X_Y & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) u (:,:,:, 1 + ( my_node - 1 ) * my : my_node * my )[ i ] = bufr_X_Y (:,:,:,:) !-- inter-node transpose from buffer end do #endif sync all !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () end  subroutine transpose_Y_X end program coarray_distributed_transpose","tags":"","loc":"program/coarray_distributed_transpose.html","title":"coarray_distributed_transpose – OpenCoarrays"},{"text":"Uses: iso_fortran_env ieee_arithmetic global_field_module ForTrilinos_assertion_utility program~~main~~UsesGraph program~main main iso_fortran_env iso_fortran_env iso_fortran_env->program~main module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~global_field_module global_field_module iso_fortran_env->module~global_field_module module~local_field_module~2 local_field_module iso_fortran_env->module~local_field_module~2 module~fortrilinos_assertion_utility->program~main module~fortrilinos_assertion_utility->module~global_field_module module~fortrilinos_assertion_utility->module~local_field_module~2 module~global_field_module->program~main ieee_arithmetic ieee_arithmetic ieee_arithmetic->program~main module~object_interface~2 object_interface module~object_interface~2->module~fortrilinos_assertion_utility module~object_interface~2->module~local_field_module~2 module~local_field_module~2->module~global_field_module module~co_object_interface~2 co_object_interface module~co_object_interface~2->module~global_field_module var panprogrammainUsesGraph = svgPanZoom('#programmainUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~main~~CallsGraph program~main main proc~diffusion_stability_limit diffusion_stability_limit program~main->proc~diffusion_stability_limit proc~test test program~main->proc~test proc~sinusoid sinusoid proc~test->proc~sinusoid interface~assert assert proc~test->interface~assert interface~error_message error_message proc~test->interface~error_message proc~sinusoid->interface~assert proc~sinusoid->interface~error_message proc~scalar_assert scalar_assert interface~assert->proc~scalar_assert proc~vector_assert vector_assert interface~assert->proc~vector_assert proc~new_message new_message interface~error_message->proc~new_message proc~assert_identical assert_identical proc~vector_assert->proc~assert_identical var panprogrammainCallsGraph = svgPanZoom('#programmainCallsGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial real(kind=real64) :: dt real(kind=real64) :: dx real(kind=real64), parameter :: final_time = 0.6_real64 type( global_field ) :: half_uu procedure( initial_condition ), pointer :: initial_u => ten_sin integer, parameter :: nodes = 16 real(kind=real64), parameter :: nu = 1. real(kind=real64), parameter :: safety_factor = 0.1_real64 real(kind=real64) :: time = 0. real(kind=real64), parameter :: tolerance = 1.E-3_real64 type( global_field ) :: u type( global_field ) :: u_half Functions pure function diffusion_stability_limit (diffusivity, delta_x, order_of_accuracy) result(stable_time_step) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: diffusivity real(kind=real64), intent(in) :: delta_x integer, intent(in) :: order_of_accuracy Return Value real(kind=real64) function sinusoid (u_solution) result(is_sinusoid) Arguments Type Intent Optional Attributes Name type( global_field ), intent(in) :: u_solution Return Value logical pure function ten_sin (x) result(ten_sin_x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Subroutines subroutine test (burgers_solution) Arguments Type Intent Optional Attributes Name type( global_field ), intent(in) :: burgers_solution","tags":"","loc":"program/main.html","title":"main – OpenCoarrays"},{"text":"Uses: global_field_module program~~main~2~~UsesGraph program~main~2 main module~global_field_module global_field_module module~global_field_module->program~main~2 iso_fortran_env iso_fortran_env iso_fortran_env->module~global_field_module module~local_field_module~2 local_field_module iso_fortran_env->module~local_field_module~2 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~local_field_module~2->module~global_field_module module~fortrilinos_assertion_utility->module~global_field_module module~fortrilinos_assertion_utility->module~local_field_module~2 module~co_object_interface~2 co_object_interface module~co_object_interface~2->module~global_field_module module~object_interface~2 object_interface module~object_interface~2->module~local_field_module~2 module~object_interface~2->module~fortrilinos_assertion_utility var panprogrammain2UsesGraph = svgPanZoom('#programmain2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial type( global_field ) :: T type( global_field ) :: T_half real, parameter :: alpha = 1. real, parameter :: dt = 0.0001 real, parameter :: final_time = 1. type( global_field ) :: laplacian_T real :: time = 0. real, parameter :: tolerance = 1.E-3","tags":"","loc":"program/main~2.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_fortran_env run_size program~~cshear~~UsesGraph program~cshear cshear iso_fortran_env iso_fortran_env iso_fortran_env->program~cshear module~run_size~2 run_size iso_fortran_env->module~run_size~2 module~run_size~2->program~cshear mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~cshear~~CallsGraph program~cshear cshear interface~solve_navier_stokes solve_navier_stokes program~cshear->interface~solve_navier_stokes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces interface subroutine solve_navier_stokes () Arguments None Source Code program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface nx = 128 ; ny = 128 ; nz = 128 viscos = 0. ; shear = 0. b11 = 1. ; b22 = 1. ; b33 = 1. ; b12 = 0. nsteps = 10 ; output_step = 1 num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then !       write(6,*) \"nx,ny,nz : \";               read(5,*) nx, ny, nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if !       write(6,*) \"viscos, shear : \";          read(5,*) viscos, shear !       write(6,*) \"b11 b22 b33 b12 : \";        read(5,*) b11, b22, b33, b12 !       write(6,*) \"nsteps, output_step : \";    read(5,*) nsteps, output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes end program cshear","tags":"","loc":"program/cshear.html","title":"cshear – OpenCoarrays"},{"text":"Uses: iso_fortran_env run_size program~~cshear~2~~UsesGraph program~cshear~2 cshear iso_fortran_env iso_fortran_env iso_fortran_env->program~cshear~2 module~run_size~2 run_size iso_fortran_env->module~run_size~2 module~run_size~2->program~cshear~2 mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~cshear~2~~CallsGraph program~cshear~2 cshear interface~solve_navier_stokes~2 solve_navier_stokes program~cshear~2->interface~solve_navier_stokes~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces interface subroutine solve_navier_stokes () Arguments None Source Code program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface num_nodes = num_images () my_node = this_image () nx = 128 ; ny = 128 ; nz = 128 viscos = 0. ; shear = 0. b11 = 1. ; b22 = 1. ; b33 = 1. ; b12 = 0. nsteps = 5 ; output_step = 1 if ( my_node == 1 ) then !write(6,*) \"nx,ny,nz : \";               read(5,*) nx, ny, nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if !write(6,*) \"viscos, shear : \";          read(5,*) viscos, shear !write(6,*) \"b11 b22 b33 b12 : \";        read(5,*) b11, b22, b33, b12 !write(6,*) \"nsteps, output_step : \";    read(5,*) nsteps, output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes if ( this_image () == 1 ) print * , \"Test passed.\" end program cshear","tags":"","loc":"program/cshear~2.html","title":"cshear – OpenCoarrays"},{"text":"Uses: iso_fortran_env run_size program~~cshear~3~~UsesGraph program~cshear~3 cshear iso_fortran_env iso_fortran_env iso_fortran_env->program~cshear~3 module~run_size~2 run_size iso_fortran_env->module~run_size~2 module~run_size~2->program~cshear~3 mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~cshear~3~~CallsGraph program~cshear~3 cshear interface~solve_navier_stokes~3 solve_navier_stokes program~cshear~3->interface~solve_navier_stokes~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces interface subroutine solve_navier_stokes () Arguments None Source Code program cshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use iso_fortran_env , only : int64 , real64 ! 64-bit integer and real kind parameters use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface num_nodes = num_images () my_node = this_image () if ( my_node == 1 ) then write ( 6 , * ) \"nx,ny,nz : \" ; read ( 5 , * ) nx , ny , nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if write ( 6 , * ) \"viscos, shear : \" ; read ( 5 , * ) viscos , shear write ( 6 , * ) \"b11 b22 b33 b12 : \" ; read ( 5 , * ) b11 , b22 , b33 , b12 write ( 6 , * ) \"nsteps, output_step : \" ; read ( 5 , * ) nsteps , output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if sync all !--- images > 1 wait on inputs from image = 1 ! if ( my_node > 1 ) then nx = nx [ 1 ]; ny = ny [ 1 ]; nz = nz [ 1 ] viscos = viscos [ 1 ]; shear = shear [ 1 ] b11 = b11 [ 1 ]; b22 = b22 [ 1 ]; b33 = b33 [ 1 ]; b12 = b12 [ 1 ] nsteps = nsteps [ 1 ]; output_step = output_step [ 1 ] end if mx = nx / 2 / num_nodes ; first_x = ( my_node - 1 ) * mx + 1 ; last_x = ( my_node - 1 ) * mx + mx my = ny / num_nodes ; first_y = ( my_node - 1 ) * my + 1 ; last_y = ( my_node - 1 ) * my + my if ( my_node == 1 ) write ( 6 , fmt = \"(A, f6.2)\" ) \"message size (MB) = \" , real ( nz * 4 * mx * my * 8 ) / real ( 1024 * 1024 ) call solve_navier_stokes end program cshear","tags":"","loc":"program/cshear~3.html","title":"cshear – OpenCoarrays"},{"text":"Uses: run_size program~~mshear~~UsesGraph program~mshear mshear module~run_size~2 run_size module~run_size~2->program~mshear iso_fortran_env iso_fortran_env iso_fortran_env->module~run_size~2 mpi mpi mpi->module~run_size~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~mshear~~CallsGraph program~mshear mshear mpi_comm_size mpi_comm_size program~mshear->mpi_comm_size mpi_comm_rank mpi_comm_rank program~mshear->mpi_comm_rank interface~solve_navier_stokes~4 solve_navier_stokes program~mshear->interface~solve_navier_stokes~4 mpi_barrier mpi_barrier program~mshear->mpi_barrier mpi_init mpi_init program~mshear->mpi_init mpi_bcast mpi_bcast program~mshear->mpi_bcast Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Interfaces interface subroutine solve_navier_stokes () Arguments None Source Code program mshear !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use run_size implicit none interface subroutine solve_navier_stokes end subroutine solve_navier_stokes end interface call MPI_INIT ( ierror ) call MPI_COMM_RANK ( MPI_COMM_WORLD , my_node , ierror ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , num_nodes , ierror ) if ( my_node == 0 ) then write ( 6 , * ) \"nx,ny,nz : \" ; read ( 5 , * ) nx , ny , nz if ( mod ( nx / 2 , num_nodes ) /= 0 ) then ; write ( 6 , * ) \"nx/2 not multiple of num_nodes\" ; stop ; end if if ( mod ( ny , num_nodes ) /= 0 ) then ; write ( 6 , * ) \" ny not multiple of num_nodes\" ; stop ; end if write ( 6 , * ) \"viscos, shear : \" ; read ( 5 , * ) viscos , shear write ( 6 , * ) \"b11 b22 b33 b12 : \" ; read ( 5 , * ) b11 , b22 , b33 , b12 write ( 6 , * ) \"nsteps, output_step : \" ; read ( 5 , * ) nsteps , output_step write ( 6 , fmt = \"(3(A,i4))\" ) \"nx =\" , nx , \"   ny =\" , ny , \"   nz =\" , nz write ( 6 , fmt = \"(2(A,f7.3))\" ) \"viscos = \" , viscos , \"      shear = \" , shear write ( 6 , fmt = \"(A,4f7.3)\" ) \"b11 b22 b33 b12 = \" , b11 , b22 , b33 , b12 write ( 6 , fmt = \"(2(A,i6))\" ) \"nsteps = \" , nsteps , \"       output_step = \" , output_step write ( 6 , fmt = \"(A,i4,A)\" ) \"----------------- running on \" , num_nodes , \" images -------------------\" end if call MPI_BCAST ( nx , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( ny , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nz , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( viscos , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( shear , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b11 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b22 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b33 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( b12 , 1 , MPI_FLOAT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nsteps , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( output_step , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) mx = nx / 2 / num_nodes ; first_x = my_node * mx + 1 ; last_x = my_node * mx + mx my = ny / num_nodes ; first_y = my_node * my + 1 ; last_y = my_node * my + my call solve_navier_stokes end program mshear","tags":"","loc":"program/mshear.html","title":"mshear – OpenCoarrays"},{"text":"Uses: iso_fortran_env kind_parameters periodic_2nd_order_module initializer input_file shared mpi_share program~~main~3~~UsesGraph program~main~3 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~3 module~fortrilinos_assertion_utility ForTrilinos_assertion_utility iso_fortran_env->module~fortrilinos_assertion_utility module~kind_parameters kind_parameters module~kind_parameters->program~main~3 module~periodic_2nd_order_module periodic_2nd_order_module module~kind_parameters->module~periodic_2nd_order_module module~input_file input_file module~kind_parameters->module~input_file module~initializer initializer module~kind_parameters->module~initializer module~mpi_module mpi_module module~kind_parameters->module~mpi_module module~periodic_2nd_order_module->program~main~3 module~shared shared module~shared->program~main~3 module~shared->module~periodic_2nd_order_module module~shared->module~mpi_module module~input_file->program~main~3 module~input_file->module~periodic_2nd_order_module module~mpi_share mpi_share module~mpi_share->program~main~3 module~mpi_share->module~periodic_2nd_order_module module~initializer->program~main~3 module~object_interface~2 object_interface module~object_interface~2->module~periodic_2nd_order_module module~object_interface~2->module~fortrilinos_assertion_utility module~object_interface~2->module~mpi_module module~fortrilinos_assertion_utility->module~periodic_2nd_order_module module~fortrilinos_assertion_utility->module~mpi_module module~mpi_module->module~periodic_2nd_order_module module~mpi_module->module~mpi_share mpi mpi mpi->module~shared var panprogrammain3UsesGraph = svgPanZoom('#programmain3UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: base_output_unit = output_unit+10 real(kind=rkind) :: dt real(kind=rkind), parameter :: expected_zero_location = pi real(kind=rkind) :: half = 0.5 type( periodic_2nd_order ), save :: half_uu procedure( initial_field ), pointer :: initial character(len=:), allocatable :: iomsg integer :: iostat character(len=:), allocatable :: iotype real(kind=rkind) :: nu = 1. integer :: num_steps = 100000 real(kind=rkind), parameter :: pi = acos(-1._rkind) integer :: step integer :: steps real(kind=rkind) :: t = 0. real(kind=rkind) :: t_1 real(kind=rkind) :: t_2 real(kind=rkind) :: t_3 real(kind=rkind) :: t_final = 3.08 real(kind=rkind), parameter :: time_initial = 0. type( periodic_2nd_order ), save :: u type( periodic_2nd_order ), save :: u_half real(kind=rkind), allocatable :: u_surface (:,:) integer, allocatable :: v_list (:)","tags":"","loc":"program/main~3.html","title":"main – OpenCoarrays"},{"text":"Uses: mpi_run_size program~~mpi_distributed_transpose~~UsesGraph program~mpi_distributed_transpose mpi_distributed_transpose module~mpi_run_size mpi_run_size module~mpi_run_size->program~mpi_distributed_transpose iso_fortran_env iso_fortran_env iso_fortran_env->module~mpi_run_size mpi mpi mpi->module~mpi_run_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. * * * * * * * * * * * * * * * *) Calls program~~mpi_distributed_transpose~~CallsGraph program~mpi_distributed_transpose mpi_distributed_transpose proc~transpose_x_y~2 transpose_X_Y program~mpi_distributed_transpose->proc~transpose_x_y~2 mpi_comm_size mpi_comm_size program~mpi_distributed_transpose->mpi_comm_size proc~transpose_y_x~2 transpose_Y_X program~mpi_distributed_transpose->proc~transpose_y_x~2 mpi_comm_rank mpi_comm_rank program~mpi_distributed_transpose->mpi_comm_rank mpi_barrier mpi_barrier program~mpi_distributed_transpose->mpi_barrier mpi_init mpi_init program~mpi_distributed_transpose->mpi_init mpi_bcast mpi_bcast program~mpi_distributed_transpose->mpi_bcast proc~transpose_x_y~2->mpi_barrier mpi_issend mpi_issend proc~transpose_x_y~2->mpi_issend walltime walltime proc~transpose_x_y~2->walltime mpi_recv mpi_recv proc~transpose_x_y~2->mpi_recv proc~mpi_copy3 mpi_copy3 proc~transpose_x_y~2->proc~mpi_copy3 proc~transpose_y_x~2->mpi_barrier proc~transpose_y_x~2->mpi_issend proc~transpose_y_x~2->walltime proc~transpose_y_x~2->mpi_recv proc~transpose_y_x~2->proc~mpi_copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: MPI_2DOUBLE_PRECISION = 1275072547 integer, parameter :: MPI_2INT = 1275070486 integer, parameter :: MPI_2INTEGER = 1275070496 integer, parameter :: MPI_2REAL = 1275070497 integer, parameter :: MPI_ADDRESS_KIND = 8 integer, parameter :: MPI_AINT = 1275070531 integer, parameter :: MPI_ANY_SOURCE = -2 integer, parameter :: MPI_ANY_TAG = -1 integer, parameter :: MPI_APPNUM = 1681915918 character :: MPI_ARGVS_NULL (1,1) character :: MPI_ARGV_NULL (1) logical :: MPI_ASYNC_PROTECTS_NONBLOCKING integer, parameter :: MPI_BAND = 1476395014 integer, parameter :: MPI_BOR = 1476395016 integer :: MPI_BOTTOM integer, parameter :: MPI_BSEND_OVERHEAD = 96 integer, parameter :: MPI_BXOR = 1476395018 integer, parameter :: MPI_BYTE = 1275068685 integer, parameter :: MPI_CART = 2 integer, parameter :: MPI_CHAR = 1275068673 integer, parameter :: MPI_CHARACTER = 1275068698 integer, parameter :: MPI_COMBINER_CONTIGUOUS = 3 integer, parameter :: MPI_COMBINER_DARRAY = 14 integer, parameter :: MPI_COMBINER_DUP = 2 integer, parameter :: MPI_COMBINER_F90_COMPLEX = 16 integer, parameter :: MPI_COMBINER_F90_INTEGER = 17 integer, parameter :: MPI_COMBINER_F90_REAL = 15 integer, parameter :: MPI_COMBINER_HINDEXED = 9 integer, parameter :: MPI_COMBINER_HINDEXED_BLOCK = 19 integer, parameter :: MPI_COMBINER_HINDEXED_INTEGER = 8 integer, parameter :: MPI_COMBINER_HVECTOR = 6 integer, parameter :: MPI_COMBINER_HVECTOR_INTEGER = 5 integer, parameter :: MPI_COMBINER_INDEXED = 7 integer, parameter :: MPI_COMBINER_INDEXED_BLOCK = 10 integer, parameter :: MPI_COMBINER_NAMED = 1 integer, parameter :: MPI_COMBINER_RESIZED = 18 integer, parameter :: MPI_COMBINER_STRUCT = 12 integer, parameter :: MPI_COMBINER_STRUCT_INTEGER = 11 integer, parameter :: MPI_COMBINER_SUBARRAY = 13 integer, parameter :: MPI_COMBINER_VECTOR = 4 integer, parameter :: MPI_COMM_NULL = 67108864 integer, parameter :: MPI_COMM_SELF = 1140850689 integer, parameter :: MPI_COMM_TYPE_SHARED = 1 integer, parameter :: MPI_COMM_WORLD = 1140850688 integer, parameter :: MPI_COMPLEX = 1275070494 integer, parameter :: MPI_COMPLEX16 = 1275072554 integer, parameter :: MPI_COMPLEX32 = 1275076652 integer, parameter :: MPI_COMPLEX8 = 1275070504 integer, parameter :: MPI_CONGRUENT = 1 integer, parameter :: MPI_COUNT = 1275070533 integer, parameter :: MPI_COUNT_KIND = 8 integer, parameter :: MPI_CXX_BOOL = 1275068723 integer, parameter :: MPI_CXX_DOUBLE_COMPLEX = 1275072565 integer, parameter :: MPI_CXX_FLOAT_COMPLEX = 1275070516 integer, parameter :: MPI_CXX_LONG_DOUBLE_COMPLEX = 1275076662 integer, parameter :: MPI_C_BOOL = 1275068735 integer, parameter :: MPI_C_COMPLEX = 1275070528 integer, parameter :: MPI_C_DOUBLE_COMPLEX = 1275072577 integer, parameter :: MPI_C_FLOAT_COMPLEX = 1275070528 integer, parameter :: MPI_C_LONG_DOUBLE_COMPLEX = 1275076674 integer, parameter :: MPI_DATATYPE_NULL = 201326592 integer, parameter :: MPI_DISPLACEMENT_CURRENT = -54278278 integer, parameter :: MPI_DISTRIBUTE_BLOCK = 121 integer, parameter :: MPI_DISTRIBUTE_CYCLIC = 122 integer, parameter :: MPI_DISTRIBUTE_DFLT_DARG = -49767 integer, parameter :: MPI_DISTRIBUTE_NONE = 123 integer, parameter :: MPI_DIST_GRAPH = 3 integer, parameter :: MPI_DOUBLE = 1275070475 integer, parameter :: MPI_DOUBLE_COMPLEX = 1275072546 integer, parameter :: MPI_DOUBLE_INT = -1946157055 integer, parameter :: MPI_DOUBLE_PRECISION = 1275070495 integer :: MPI_ERRCODES_IGNORE (1) integer, parameter :: MPI_ERRHANDLER_NULL = 335544320 integer, parameter :: MPI_ERROR = 5 integer, parameter :: MPI_ERRORS_ARE_FATAL = 1409286144 integer, parameter :: MPI_ERRORS_RETURN = 1409286145 integer, parameter :: MPI_ERR_ACCESS = 20 integer, parameter :: MPI_ERR_AMODE = 21 integer, parameter :: MPI_ERR_ARG = 12 integer, parameter :: MPI_ERR_ASSERT = 53 integer, parameter :: MPI_ERR_BAD_FILE = 22 integer, parameter :: MPI_ERR_BASE = 46 integer, parameter :: MPI_ERR_BUFFER = 1 integer, parameter :: MPI_ERR_COMM = 5 integer, parameter :: MPI_ERR_CONVERSION = 23 integer, parameter :: MPI_ERR_COUNT = 2 integer, parameter :: MPI_ERR_DIMS = 11 integer, parameter :: MPI_ERR_DISP = 52 integer, parameter :: MPI_ERR_DUP_DATAREP = 24 integer, parameter :: MPI_ERR_FILE = 27 integer, parameter :: MPI_ERR_FILE_EXISTS = 25 integer, parameter :: MPI_ERR_FILE_IN_USE = 26 integer, parameter :: MPI_ERR_GROUP = 8 integer, parameter :: MPI_ERR_INFO = 28 integer, parameter :: MPI_ERR_INFO_KEY = 29 integer, parameter :: MPI_ERR_INFO_NOKEY = 31 integer, parameter :: MPI_ERR_INFO_VALUE = 30 integer, parameter :: MPI_ERR_INTERN = 16 integer, parameter :: MPI_ERR_IN_STATUS = 17 integer, parameter :: MPI_ERR_IO = 32 integer, parameter :: MPI_ERR_KEYVAL = 48 integer, parameter :: MPI_ERR_LASTCODE = 1073741823 integer, parameter :: MPI_ERR_LOCKTYPE = 47 integer, parameter :: MPI_ERR_NAME = 33 integer, parameter :: MPI_ERR_NOT_SAME = 35 integer, parameter :: MPI_ERR_NO_MEM = 34 integer, parameter :: MPI_ERR_NO_SPACE = 36 integer, parameter :: MPI_ERR_NO_SUCH_FILE = 37 integer, parameter :: MPI_ERR_OP = 9 integer, parameter :: MPI_ERR_OTHER = 15 integer, parameter :: MPI_ERR_PENDING = 18 integer, parameter :: MPI_ERR_PORT = 38 integer, parameter :: MPI_ERR_QUOTA = 39 integer, parameter :: MPI_ERR_RANK = 6 integer, parameter :: MPI_ERR_READ_ONLY = 40 integer, parameter :: MPI_ERR_REQUEST = 19 integer, parameter :: MPI_ERR_RMA_ATTACH = 56 integer, parameter :: MPI_ERR_RMA_CONFLICT = 49 integer, parameter :: MPI_ERR_RMA_FLAVOR = 58 integer, parameter :: MPI_ERR_RMA_RANGE = 55 integer, parameter :: MPI_ERR_RMA_SHARED = 57 integer, parameter :: MPI_ERR_RMA_SYNC = 50 integer, parameter :: MPI_ERR_ROOT = 7 integer, parameter :: MPI_ERR_SERVICE = 41 integer, parameter :: MPI_ERR_SIZE = 51 integer, parameter :: MPI_ERR_SPAWN = 42 integer, parameter :: MPI_ERR_TAG = 4 integer, parameter :: MPI_ERR_TOPOLOGY = 10 integer, parameter :: MPI_ERR_TRUNCATE = 14 integer, parameter :: MPI_ERR_TYPE = 3 integer, parameter :: MPI_ERR_UNKNOWN = 13 integer, parameter :: MPI_ERR_UNSUPPORTED_DATAREP = 43 integer, parameter :: MPI_ERR_UNSUPPORTED_OPERATION = 44 integer, parameter :: MPI_ERR_WIN = 45 integer, parameter :: MPI_FILE_NULL = 0 integer, parameter :: MPI_FLOAT = 1275069450 integer, parameter :: MPI_FLOAT_INT = -1946157056 integer, parameter :: MPI_GRAPH = 1 integer, parameter :: MPI_GROUP_EMPTY = 1207959552 integer, parameter :: MPI_GROUP_NULL = 134217728 integer, parameter :: MPI_HOST = 1681915908 integer, parameter :: MPI_IDENT = 0 integer, parameter :: MPI_INFO_ENV = 1543503873 integer, parameter :: MPI_INFO_NULL = 469762048 integer, parameter :: MPI_INT = 1275069445 integer, parameter :: MPI_INT16_T = 1275068984 integer, parameter :: MPI_INT32_T = 1275069497 integer, parameter :: MPI_INT64_T = 1275070522 integer, parameter :: MPI_INT8_T = 1275068727 integer, parameter :: MPI_INTEGER = 1275069467 integer, parameter :: MPI_INTEGER1 = 1275068717 integer, parameter :: MPI_INTEGER16 = MPI_DATATYPE_NULL integer, parameter :: MPI_INTEGER2 = 1275068975 integer, parameter :: MPI_INTEGER4 = 1275069488 integer, parameter :: MPI_INTEGER8 = 1275070513 integer, parameter :: MPI_INTEGER_KIND = 4 integer :: MPI_IN_PLACE integer, parameter :: MPI_IO = 1681915910 integer, parameter :: MPI_KEYVAL_INVALID = 603979776 integer, parameter :: MPI_LAND = 1476395013 integer, parameter :: MPI_LASTUSEDCODE = 1681915916 integer, parameter :: MPI_LB = 1275068432 integer, parameter :: MPI_LOCK_EXCLUSIVE = 234 integer, parameter :: MPI_LOCK_SHARED = 235 integer, parameter :: MPI_LOGICAL = 1275069469 integer, parameter :: MPI_LONG = 1275070471 integer, parameter :: MPI_LONG_DOUBLE = 1275072524 integer, parameter :: MPI_LONG_DOUBLE_INT = -1946157052 integer, parameter :: MPI_LONG_INT = -1946157054 integer, parameter :: MPI_LONG_LONG = 1275070473 integer, parameter :: MPI_LONG_LONG_INT = 1275070473 integer, parameter :: MPI_LOR = 1476395015 integer, parameter :: MPI_LXOR = 1476395017 integer, parameter :: MPI_MAX = 1476395009 integer, parameter :: MPI_MAXLOC = 1476395020 integer, parameter :: MPI_MAX_DATAREP_STRING = 127 integer, parameter :: MPI_MAX_ERROR_STRING = 512-1 integer, parameter :: MPI_MAX_INFO_KEY = 254 integer, parameter :: MPI_MAX_INFO_VAL = 1023 integer, parameter :: MPI_MAX_LIBRARY_VERSION_STRING = 8192-1 integer, parameter :: MPI_MAX_OBJECT_NAME = 127 integer, parameter :: MPI_MAX_PORT_NAME = 255 integer, parameter :: MPI_MAX_PROCESSOR_NAME = 128-1 integer, parameter :: MPI_MESSAGE_NO_PROC = 1811939328 integer, parameter :: MPI_MESSAGE_NULL = 738197504 integer, parameter :: MPI_MIN = 1476395010 integer, parameter :: MPI_MINLOC = 1476395019 integer, parameter :: MPI_MODE_APPEND = 128 integer, parameter :: MPI_MODE_CREATE = 1 integer, parameter :: MPI_MODE_DELETE_ON_CLOSE = 16 integer, parameter :: MPI_MODE_EXCL = 64 integer, parameter :: MPI_MODE_NOCHECK = 1024 integer, parameter :: MPI_MODE_NOPRECEDE = 8192 integer, parameter :: MPI_MODE_NOPUT = 4096 integer, parameter :: MPI_MODE_NOSTORE = 2048 integer, parameter :: MPI_MODE_NOSUCCEED = 16384 integer, parameter :: MPI_MODE_RDONLY = 2 integer, parameter :: MPI_MODE_RDWR = 8 integer, parameter :: MPI_MODE_SEQUENTIAL = 256 integer, parameter :: MPI_MODE_UNIQUE_OPEN = 32 integer, parameter :: MPI_MODE_WRONLY = 4 integer, parameter :: MPI_NO_OP = 1476395022 integer, parameter :: MPI_OFFSET = 1275070532 integer, parameter :: MPI_OFFSET_KIND = 8 integer, parameter :: MPI_OP_NULL = 402653184 integer, parameter :: MPI_ORDER_C = 56 integer, parameter :: MPI_ORDER_FORTRAN = 57 integer, parameter :: MPI_PACKED = 1275068687 integer, parameter :: MPI_PROC_NULL = -1 integer, parameter :: MPI_PROD = 1476395012 integer, parameter :: MPI_REAL = 1275069468 integer, parameter :: MPI_REAL16 = 1275072555 integer, parameter :: MPI_REAL4 = 1275069479 integer, parameter :: MPI_REAL8 = 1275070505 integer, parameter :: MPI_REPLACE = 1476395021 integer, parameter :: MPI_REQUEST_NULL = 738197504 integer, parameter :: MPI_ROOT = -3 integer, parameter :: MPI_SEEK_CUR = 602 integer, parameter :: MPI_SEEK_END = 604 integer, parameter :: MPI_SEEK_SET = 600 integer, parameter :: MPI_SHORT = 1275068931 integer, parameter :: MPI_SHORT_INT = -1946157053 integer, parameter :: MPI_SIGNED_CHAR = 1275068696 integer, parameter :: MPI_SIMILAR = 2 integer, parameter :: MPI_SOURCE = 3 integer :: MPI_STATUSES_IGNORE (MPI_STATUS_SIZE,1) integer :: MPI_STATUS_IGNORE (MPI_STATUS_SIZE) integer, parameter :: MPI_STATUS_SIZE = 5 logical :: MPI_SUBARRAYS_SUPPORTED integer, parameter :: MPI_SUBVERSION = 1 integer, parameter :: MPI_SUCCESS = 0 integer, parameter :: MPI_SUM = 1476395011 integer, parameter :: MPI_TAG = 4 integer, parameter :: MPI_TAG_UB = 1681915906 integer, parameter :: MPI_THREAD_FUNNELED = 1 integer, parameter :: MPI_THREAD_MULTIPLE = 3 integer, parameter :: MPI_THREAD_SERIALIZED = 2 integer, parameter :: MPI_THREAD_SINGLE = 0 integer, parameter :: MPI_TYPECLASS_COMPLEX = 3 integer, parameter :: MPI_TYPECLASS_INTEGER = 2 integer, parameter :: MPI_TYPECLASS_REAL = 1 integer, parameter :: MPI_UB = 1275068433 integer, parameter :: MPI_UINT16_T = 1275068988 integer, parameter :: MPI_UINT32_T = 1275069501 integer, parameter :: MPI_UINT64_T = 1275070526 integer, parameter :: MPI_UINT8_T = 1275068731 integer, parameter :: MPI_UNDEFINED = (-32766) integer, parameter :: MPI_UNEQUAL = 3 integer, parameter :: MPI_UNIVERSE_SIZE = 1681915914 integer, parameter :: MPI_UNSIGNED = 1275069446 integer, parameter :: MPI_UNSIGNED_CHAR = 1275068674 integer, parameter :: MPI_UNSIGNED_LONG = 1275070472 integer, parameter :: MPI_UNSIGNED_LONG_LONG = 1275070489 integer, parameter :: MPI_UNSIGNED_SHORT = 1275068932 integer :: MPI_UNWEIGHTED integer, parameter :: MPI_VERSION = 3 integer, parameter :: MPI_WCHAR = 1275069454 integer :: MPI_WEIGHTS_EMPTY integer, parameter :: MPI_WIN_BASE = 1711276034 integer, parameter :: MPI_WIN_CREATE_FLAVOR = 1711276040 integer, parameter :: MPI_WIN_DISP_UNIT = 1711276038 integer, parameter :: MPI_WIN_FLAVOR_ALLOCATE = 2 integer, parameter :: MPI_WIN_FLAVOR_CREATE = 1 integer, parameter :: MPI_WIN_FLAVOR_DYNAMIC = 3 integer, parameter :: MPI_WIN_FLAVOR_SHARED = 4 integer, parameter :: MPI_WIN_MODEL = 1711276042 integer, parameter :: MPI_WIN_NULL = 536870912 integer, parameter :: MPI_WIN_SEPARATE = 1 integer, parameter :: MPI_WIN_SIZE = 1711276036 integer, parameter :: MPI_WIN_UNIFIED = 2 integer, parameter :: MPI_WTIME_IS_GLOBAL = 1681915912 complex, allocatable :: bufr (:) integer(kind=int64) :: ierror integer(kind=int64) :: iter integer(kind=int64) :: msg_size complex, allocatable :: u (:,:,:,:) complex, allocatable :: ur (:,:,:,:) integer(kind=int64) :: x integer(kind=int64) :: y integer(kind=int64) :: z Subroutines subroutine transpose_X_Y () Arguments None subroutine transpose_Y_X () Arguments None Source Code program mpi_distributed_transpose !(*********************************************************************************************************** !                   m a i n   p r o g r a m !***********************************************************************************************************) use mpi_run_size implicit none include 'mpif.h' complex , allocatable :: u (:,:,:,:) ! u(nz,4,first_x:last_x,ny)    !(*-- ny = my * num_nodes --*) complex , allocatable :: ur (:,:,:,:) !ur(nz,4,first_y:last_y,nx/2)  !(*-- nx/2 = mx * num_nodes --*) complex , allocatable :: bufr (:) integer ( int64 ) :: x , y , z , msg_size , iter integer ( int64 ) :: ierror call MPI_INIT ( ierror ) call MPI_COMM_RANK ( MPI_COMM_WORLD , my_node , ierror ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , num_nodes , ierror ) if ( my_node == 0 ) then !write(6,fmt=\"(A)\") \"nx,ny,nz : \" !read(5,*) nx, ny, nz nx = 32 ; ny = 32 ; nz = 32 end if call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !-- other nodes wait for broadcast! call MPI_BCAST ( nx , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( ny , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) call MPI_BCAST ( nz , 1 , MPI_INT , 0 , MPI_COMM_WORLD , ierror ) if ( mod ( ny , num_nodes ) == 0 ) then ; my = ny / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \" ny not multiple of num_nodes\" ; stop end if if ( mod ( nx / 2 , num_nodes ) == 0 ) then ; mx = nx / 2 / num_nodes else ; write ( 6 , * ) \"node \" , my_node , \"nx/2 not multiple of num_nodes\" ; stop end if first_y = my_node * my + 1 ; last_y = my_node * my + my first_x = my_node * mx + 1 ; last_x = my_node * mx + mx msg_size = nz * 4 * mx * my !-- message size (complex data items allocate ( u ( nz , 4 , first_x : last_x , ny ) ) !(*-- y-z planes --*) allocate ( ur ( nz , 4 , first_y : last_y , nx / 2 ) ) !(*-- x-z planes --*) allocate ( bufr ( msg_size ) ) !---------  initialize data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz u ( z , 1 , x , y ) = x u ( z , 2 , x , y ) = y u ( z , 3 , x , y ) = z end do end do end do tran_time = 0 do iter = 1 , 2 !--- 2 transform pairs per second-order time step !---------  transpose data u -> ur (mx y-z planes to my x-z planes per image)  -------- ur = 0 call transpose_X_Y !--------- test data ur (my x-z planes per image) ---------- do x = 1 , nx / 2 do y = first_y , last_y do z = 1 , nz if ( real ( ur ( z , 1 , y , x )) /= x . or . real ( ur ( z , 2 , y , x )) /= y . or . real ( ur ( z , 3 , y , x )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_X_Y failed:  image \" , my_node & , \" X \" , real ( ur ( z , 1 , y , x )), x , \"  Y \" , real ( ur ( z , 2 , y , x )), y , \"  Z \" , real ( ur ( z , 3 , y , x )), z stop end if end do end do end do !---------  transpose data ur -> u (my x-z planes to mx y-z planes per image)  -------- u = 0 call transpose_Y_X !--------- test data u (mx y-z planes per image) ---------- do x = first_x , last_x do y = 1 , ny do z = 1 , nz if ( real ( u ( z , 1 , x , y )) /= x . or . real ( u ( z , 2 , x , y )) /= y . or . real ( u ( z , 3 , x , y )) /= z ) then write ( 6 , fmt = \"(A,i3,3(6X,A,f7.3,i4))\" ) \"transpose_Y_X failed:  image \" , my_node & , \" X \" , real ( u ( z , 1 , y , x )), x , \"  Y \" , real ( u ( z , 2 , y , x )), y , \"  Z \" , real ( u ( z , 3 , y , x )), z stop end if end do end do end do end do call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) if ( my_node == 0 ) write ( 6 , fmt = \"(A,f8.3)\" ) \"test passed:  tran_time \" , tran_time deallocate ( bufr , ur , u ) !=========================   end of main executable  ============================= contains !-------------   out-of-place transpose data_s --> data_r  ---------------------------- subroutine transpose_X_Y use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) character * ( MPI_MAX_ERROR_STRING ) errs call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- intra-node transpose , ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- no inter-node transpose needed , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( u ( 1 , 1 , first_x , 1 + to * my ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   receive and transpose other image's block  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , ur ( 1 , 1 , first_y , 1 + from * mx ) & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( ur ( 1 , 1 , first_y , 1 + from * mx ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( u ( 1 , 1 , first_x , 1 + to * my ), bufr & !-- intra-node transpose from buffer , nz * 3 , 1 _ 8 , 1 _ 8 & !-- note: only 3 of 4 words needed , mx , nz * 4 , nz * 4 * my & , my , nz * 4 * mx , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () ! deallocate(ids,idr) end  subroutine transpose_X_Y !-------------   out-of-place transpose data_r --> data_s  ---------------------------- subroutine transpose_Y_X use mpi_run_size implicit none integer ( int64 ) :: to , from , send_tag , recv_tag integer :: stage , idr ( 0 : num_nodes - 1 ), ids ( 0 : num_nodes - 1 ) character * ( MPI_MAX_ERROR_STRING ) errs integer ( int64 ) :: send_status ( MPI_STATUS_SIZE ), recv_status ( MPI_STATUS_SIZE ) call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish compute tran_time = tran_time - WALLTIME () !--------------   transpose my image's block (no communication needed)  ------------------ call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + my_node * mx ) & !-- intra-node transpose , u ( 1 , 1 , first_x , 1 + my_node * my ) & !-- no inter-node transpose needed , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) #define RECEIVE #ifdef RECEIVE !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call MPI_ISSEND ( ur ( 1 , 1 , first_y , 1 + to * mx ) & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ids ( stage ), ierror ) end do !--------------   transpose other image's block (get block then transpose it)  ------------------ do stage = 1 , num_nodes - 1 !-- process receives in order from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_RECV ( bufr & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , recv_status , ierror ) call mpi_copy3 ( bufr , u ( 1 , 1 , first_x , 1 + from * my ) & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) end do #else !--------------   issue all block receives ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 from = mod ( my_node + stage , num_nodes ) recv_tag = 256 * my_node + from call MPI_IRECV ( u ( 1 , 1 , first_x , 1 + from * my ) & , msg_size * 2 , MPI_REAL , from , recv_tag , MPI_COMM_WORLD , idr ( stage ), ierror ) end do !--------------   issue all block sends ... tags = 256*dst_image+src_image  ------------------ do stage = 1 , num_nodes - 1 !-- process sends in order to = mod ( my_node + stage , num_nodes ) send_tag = 256 * to + my_node call mpi_copy3 ( ur ( 1 , 1 , first_y , 1 + to * mx ), bufr & !-- intra-node transpose from buffer , nz * 4 , 1 _ 8 , 1 _ 8 & !-- note: all 4 words needed , my , nz * 4 , nz * 4 * mx & , mx , nz * 4 * my , nz * 4 ) call MPI_SEND ( bufr & , msg_size * 2 , MPI_REAL , to , send_tag , MPI_COMM_WORLD , ierror ) end do !--------------   wait on receives   ------------------ do stage = 1 , num_nodes - 1 call MPI_WAIT ( idr ( stage ), recv_status , ierror ) end do #endif call MPI_BARRIER ( MPI_COMM_WORLD , ierror ) !--  wait for other nodes to finish transpose tran_time = tran_time + WALLTIME () !   deallocate(ids,idr) end  subroutine transpose_Y_X end program mpi_distributed_transpose","tags":"","loc":"program/mpi_distributed_transpose.html","title":"mpi_distributed_transpose – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding program~~psnap~~UsesGraph program~psnap psnap iso_fortran_env iso_fortran_env iso_fortran_env->program~psnap iso_c_binding iso_c_binding iso_c_binding->program~psnap Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~psnap~~CallsGraph program~psnap psnap proc~calibrate_loop calibrate_loop program~psnap->proc~calibrate_loop proc~print_banner print_banner program~psnap->proc~print_banner images images program~psnap->images proc~usage usage program~psnap->proc~usage proc~warmup_loop warmup_loop program~psnap->proc~warmup_loop proc~loop loop program~psnap->proc~loop proc~calibrate_loop->proc~loop proc~warmup_loop->proc~loop proc~loop->images proc~from_lower_half from_lower_half proc~loop->proc~from_lower_half proc~sending_half sending_half proc~loop->proc~sending_half interface~stop_timer stop_timer proc~loop->interface~stop_timer interface~elapsed_time elapsed_time proc~loop->interface~elapsed_time proc~to_upper_half to_upper_half proc~loop->proc~to_upper_half interface~start_timer start_timer proc~loop->interface~start_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: astat integer(kind=int64), codimension[ *], save :: barrier = 0 character(len=32) :: cl_arg type( counters ), codimension[ *] :: count_loc integer(kind=int64), codimension[ *] :: globalmax type( counters ), codimension[ *] :: globalmaxloc type( counters ), codimension[ *] :: globalminloc integer(kind=int64), codimension[ *], save :: granularity = 1000 integer(kind=int64) :: i integer(kind=int64), codimension[ *], save :: iteration_count = 0 integer(kind=int64) :: j integer(kind=int64), dimension( :), allocatable, codimension[ :] :: localhist integer(kind=int64), codimension[ *] :: localmax integer(kind=int64), codimension[ *] :: localsum integer(kind=int64), codimension[ *], save :: n = 1000 integer :: np integer :: np_half character(len=*), parameter :: psnap_rcs_id = '$Id$' integer(kind=int64), dimension( :), allocatable :: r integer :: rank character(len=*), parameter :: string_fmt = '( a)' integer(kind=int64), dimension( :), allocatable :: sum_all integer(kind=int64), codimension[ *], save :: w = 1000 Interfaces interface function elapsed_time () result(res) bind(c,name=\"elapsed_time\") Arguments None Return Value integer(kind=c_int) interface subroutine start_timer () bind(C, name=\"0\") Arguments None interface subroutine stop_timer () bind(C, name=\"0\") Arguments None Derived Types type, bind( c) :: counters Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index integer(kind=c_long), public :: val Functions function calibrate_loop (usecs) result(cl) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: usecs Return Value integer(kind=int64) function from_lower_half (i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer function get_usecs () result(usecs) Arguments None Return Value real(kind=real64) function loop (iterations) result(dt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: iterations Return Value integer(kind=int64) function sending_half (i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value logical function to_upper_half (i) result(l) Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer Subroutines subroutine print_banner () Arguments None subroutine usage () Arguments None subroutine warmup_loop (wa) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: wa Source Code program psnap !  #define VERSION_STR \"v1.2\" use , intrinsic :: iso_fortran_env , only : error_unit , output_unit , int64 , real64 , int32 use , intrinsic :: iso_c_binding character ( len = * ), parameter :: psnap_rcs_id = & '$Id$' character ( len = * ), parameter :: string_fmt = '( a)' type , bind ( c ) :: counters integer ( c_long ) :: val integer ( c_int ) :: index end type counters !  int rank, np; // globals integer :: rank integer :: np integer :: np_half !integer( int64), save :: n = 100000 integer ( int64 ), codimension [ * ], save :: n = 1000 integer ( int64 ), codimension [ * ], save :: w = 1000 integer ( int64 ), dimension ( :), allocatable :: r integer ( int64 ) :: i integer ( int64 ), codimension [ * ], save :: iteration_count = 0 integer ( int64 ), codimension [ * ] :: localmax , globalmax integer ( int64 ), codimension [ * ] :: localsum integer ( int64 ), dimension ( :), allocatable :: sum_all integer ( int64 ), dimension ( :), allocatable , codimension [ :] :: localhist integer ( int64 ), codimension [ * ], save :: granularity = 1000 integer ( int64 ), codimension [ * ], save :: barrier = 0 !character( kind= c_char, len= 1024), codimension[ *] :: hostname interface subroutine start_timer () bind ( C , name = \"start_timer\" ) use iso_c_binding end subroutine subroutine stop_timer () bind ( C , name = \"stop_timer\" ) use iso_c_binding end subroutine function elapsed_time () bind ( c , name = \"elapsed_time\" ) result ( res ) use iso_c_binding !use, intrinsic :: iso_fortran_env, only: int64 integer ( c_int ) :: res end function end interface type ( counters ), codimension [ * ] :: count_loc , globalminloc , globalmaxloc integer ( int64 ) :: j integer :: astat character ( len = 32 ) :: cl_arg ! ---------------------------------------------------------------------- !  psnap text continue rank = this_image () np = num_images () np_half = np / 2 j = 0 if ( rank == 1 ) then cl_args : do j = j + 1 if ( j >= command_argument_count () ) exit cl_args call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) which_arg : select case ( cl_arg ( 2 : 2 )) case ( 'b' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = barrier , fmt = * ) cl_arg do i = 2 , np barrier [ i ] = barrier end do case ( 'n' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = n , fmt = * ) cl_arg w = n / 10 do i = 2 , np n [ i ] = n w [ i ] = w end do case ( 'w' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = w , fmt = * ) cl_arg do i = 2 , np w [ i ] = w end do case ( 'c' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = iteration_count , fmt = * ) cl_arg do i = 2 , np iteration_count [ i ] = iteration_count end do case ( 'g' ) j = j + 1 call get_command_argument ( number = int ( j , int32 ), value = cl_arg ) write ( unit = granularity , fmt = * ) cl_arg do i = 2 , np granularity [ i ] = granularity end do case ( 'h' ) call usage () stop 'normal exit in psnap' case default call usage () stop 'normal exit in psnap' end select which_arg end do cl_args end if !  distribute sizes before allocating sync all !call get_environment_variable( name= 'HOSTNAME', value= hostname) allocate ( r ( 1 : n + w ), stat = astat ) alloc_r_error : if ( astat > 0 ) then stop 'error allocating r' end if alloc_r_error allocate ( sum_all ( 1 : np ), stat = astat ) alloc_sum_error : if ( astat > 0 ) then stop 'error allocating sum_all' end if alloc_sum_error only_rank_0 : if ( rank == 1 ) then call print_banner () end if only_rank_0 ! ---------------------------------------------------------------------- !  warmup loop here; calibration follows if ( w > 0 ) call warmup_loop ( w ) if ( iteration_count == 0 ) then iteration_count = calibrate_loop ( granularity ) !write(*,*) 'Iteration after calibrate', iteration_count,'proc',rank count_loc % val = iteration_count count_loc % index = rank globalminloc = count_loc globalmaxloc = count_loc !  compute global counts before communicating them sync all do i = 2 , np if ( globalminloc [ i ]% val < globalminloc % val ) then globalminloc = globalminloc [ i ] end if if ( globalmaxloc [ i ]% val > globalmaxloc % val ) then globalmaxloc = globalmaxloc [ i ] end if end do if ( rank == 1 ) then write ( unit = output_unit , fmt = '( a, i0/ a, i0, a, i0/ a, i0, a, i0)' ) \"my_count= \" , iteration_count , & \"global_min= \" , globalminloc % val , \" min_loc= \" , globalminloc % index , & \"global_max= \" , globalmaxloc % val , \" max_loc= \" , globalmaxloc % index write ( unit = output_unit , fmt = string_fmt ) \"Using Global max for calibration\" end if iteration_count = globalmaxloc % val end if r = 0 ! ---------------------------------------------------------------------- !  measurement loop sync all do i = 1 , n + w r ( i ) = loop ( iteration_count ) if ( barrier /= 0 ) then if ( mod ( i , barrier ) == 0 ) sync all end if end do sync all ! ---------------------------------------------------------------------- !   build histograms localsum = sum ( r ( w + 1 : ) ) if ( rank == 1 ) then sum_all ( 1 ) = localsum do i = 2 , np sync images ( i ) sum_all ( i ) = localsum [ i ] end do else sync images ( 1 ) end if localmax = maxval ( r ( w + 1 : )) if ( rank == 1 ) then globalmax = localmax do i = 2 , np sync images ( i ) globalmax = max ( globalmax , localmax [ i ]) end do else sync images ( 1 ) end if if ( rank == 1 ) then do i = 2 , np globalmax [ i ] = globalmax end do end if sync all allocate ( localhist ( 0 : globalmax )[ * ], stat = astat ) alloc_localhist_error : if ( astat > 0 ) then stop 'error allocating localhist' end if alloc_localhist_error localhist = 0 make_hist : do i = 1 + w , n + w localhist ( r ( i )) = localhist ( r ( i )) + 1 end do make_hist final_print : if ( rank == 1 ) then !  print rank 0's histogram if ( n > 0 ) then write ( unit = output_unit , fmt = '(a, i9, 9x, i9, 3x)' ) \"#\" , 1 , sum_all ( 1 ) !, trim( hostname) do i = 0 , globalmax if ( localhist ( i ) > 0 ) then write ( unit = output_unit , fmt = '(1x, i9, i9, i9, 3x)' ) rank , i , localhist ( i ) !, trim( hostname) end if end do end if !  print rank i's histogram do i = 2 , np sync images ( i ) !localhist(:) = localhist(:)[ i] do j = lbound ( localhist , dim = 1 ), ubound ( localhist , dim = 1 ) localhist ( j ) = localhist ( j )[ i ] end do !hostname = hostname[ i] if ( n > 0 ) then write ( unit = output_unit , fmt = '(a, i9, 9x, i9, 3x)' ) \"#\" , i , sum_all ( i ) !, trim( hostname) do j = 0 , globalmax if ( localhist ( j ) > 0 ) then write ( unit = output_unit , fmt = '(1x, i9, i9, i9, 3x)' ) i , j , localhist ( j ) !, trim( hostname) end if end do end if end do else final_print sync images ( 1 ) end if final_print stop 'normal exit in psnap' contains ! --------------------------------------------------------------------- function get_usecs () result ( usecs ) !integer( int64) :: usecs !  usec per sec !integer( int64), parameter :: c = 1000000 !   integer( int64) :: t !   integer( int64) :: r integer ( kind = 8 ) :: t , r real ( real64 ) :: usecs integer ( kind = 8 ), parameter :: c = 1000000 continue !call system_clock( count= t, count_rate= r) call cpu_time ( usecs ) usecs = usecs * 1. d6 !if( r /= c ) usecs = int( real( t, 8) / real( r, 8) * real( c, 8)) !if( r /= c ) usecs = int( t/r * c) return end function get_usecs ! --------------------------------------------------------------------- function loop ( iterations ) result ( dt ) integer ( int64 ) :: dt integer ( int64 ), intent ( in ) :: iterations integer ( int64 ) :: i integer ( int64 ) :: usecs_init , usecs_final integer :: next_rank , prev_rank integer , codimension [ * ], save :: coarray continue !   usecs_init = get_usecs() call start_timer () next_rank = to_upper_half ( rank ) prev_rank = from_lower_half ( rank ) !   write(*,*) 'Proc',rank,'Next rank',next_rank,'Prev rank',prev_rank counter : do i = 1 , iterations even_odd : if ( sending_half ( rank ) ) then !  send rank to next then fetch rank coarray [ next_rank ] = coarray sync images ( next_rank ) else even_odd !  stay calm coarray [ prev_rank ] = coarray sync images ( prev_rank ) end if even_odd end do counter !   usecs_final = get_usecs() call stop_timer () !   write(*,*) 'usec_init',usec_init,'usec_final',usec_final dt = elapsed_time () !write(*,*) 'usec_init',usec_init,'usec_final',usec_final,'dt',dt return end function loop ! --------------------------------------------------------------------- subroutine warmup_loop ( wa ) integer ( int64 ), intent ( in ) :: wa !integer( int64), parameter :: counter = 1000000 integer ( int64 ), parameter :: counter = 10000 integer ( int64 ) :: min_time_usecs integer ( int64 ) :: loop_time integer :: i continue min_time_usecs = huge ( 0_int64 ) reloop : do i = 1 , wa loop_time = loop ( counter ) min_time_usecs = min ( loop_time , min_time_usecs ) end do reloop return end subroutine warmup_loop ! --------------------------------------------------------------------- function calibrate_loop ( usecs ) result ( cl ) integer ( int64 ) :: cl integer ( int64 ), intent ( in ) :: usecs integer ( int64 ), parameter :: calibrate_useconds = 100000000 !real( real64), parameter :: preset_tolerance = 0.001_real64 real ( real64 ), parameter :: preset_tolerance = 1.0_real64 integer ( int64 ), parameter :: initial_ntrial = 1000 !integer( int64), parameter :: initial_counter = 1000000 integer ( int64 ), parameter :: initial_counter = 100000 integer ( int64 ) :: counter integer ( int64 ) :: min_time_usecs integer ( int64 ) :: tolerance integer ( int64 ) :: difference integer ( int64 ) :: total_time integer ( int64 ) :: ntrial integer ( int64 ) :: i integer ( int64 ) :: loop_time continue counter = initial_counter !write(*,*) 'Counter after initial counter',counter !  if usecs / granularity is less than 1/preset_tolerance then use zero tolerance = int ( real ( usecs , real64 ) * preset_tolerance , int64 ) total_time = 0 trials : do ntrial = initial_ntrial min_time_usecs = huge ( 0_int64 ) get_min : do i = 1 , ntrial loop_time = loop ( counter ) !write(*,*) 'loop_time',loop_time min_time_usecs = min ( min_time_usecs , loop_time ) end do get_min !  keep an estimate of total calibration time total_time = total_time + min_time_usecs * ntrial counter = int ( real ( counter , real64 ) * real ( usecs , real64 ) / real ( min_time_usecs , real64 ), int64 ) !write(*,*) 'Counter after assignment',counter difference = abs ( min_time_usecs - usecs ) if ( difference <= tolerance . or . total_time >= calibrate_useconds ) exit trials end do trials cl = counter write ( unit = output_unit , fmt = '( a, i2, a, i10, a, i10, a, i10, a, i10)' ) \"#rank= \" , rank , & \" count= \" , counter , \" time= \" , min_time_usecs , & \" difference= \" , difference , \" tolerance= \" , tolerance time_out : if ( total_time > calibrate_useconds ) then write ( unit = output_unit , fmt = '( a, i2, a, f10.4, a, f10.4, a, f10.4, a, i0)' ) \"PSNAP: WARNING rank \" , rank , & \" didn't converge in 10 seconds tolerance = \" , & real ( difference ) / real ( usecs ), & \" should be \" , preset_tolerance , \" approx \" , & preset_tolerance * 10 0.0 , \" percent, granularity= \" , usecs end if time_out return end function calibrate_loop ! --------------------------------------------------------------------- subroutine print_banner () continue write ( unit = output_unit , fmt = string_fmt ) '########' write ( unit = output_unit , fmt = string_fmt ) '##P-SNAP: PAL System Noise Activity Program' write ( unit = output_unit , fmt = string_fmt ) '##' // psnap_rcs_id write ( unit = output_unit , fmt = string_fmt ) '##This is a Fortran translation of P-SNAP v 1.2 from' write ( unit = output_unit , fmt = string_fmt ) '##http://www.c3.lanl.gov/pal/software/psnap/' write ( unit = output_unit , fmt = string_fmt ) '##This program is the coarray ping-pong version' write ( unit = output_unit , fmt = string_fmt ) '########' return end subroutine print_banner ! --------------------------------------------------------------------- subroutine usage () character ( len = * ), dimension ( 17 ), parameter :: msg = & [ \"Usage: psnap [OPTIONS]                                             \" , & \"                                                                   \" , & \"  -n <reps>   number of repetitions                                \" , & \"                default: 100000                                    \" , & \"  -w <reps>   number of warm-up repetitions                        \" , & \"                default: 10%% of the number of reps                \" , & \"  -c <count>  calibration count                                    \" , & \"                default: perform a calibration to match granularity\" , & \"  -g <usecs>  granularity of the test in microseconds              \" , & \"                default: 1000                                      \" , & \"  -b <N>      perform a barrier between every N loops              \" , & \"                default: no                                        \" , & \"  -h          this message                                         \" , & \"                                                                   \" , & \"  Example: psnap -n 1000000 -w 10 > psnap.out                      \" , & \"    runs a test with 1000000 repetitions and 10 warm-up reps.      \" , & \"                                                                   \" ] integer :: i continue write ( unit = error_unit , fmt = string_fmt ) ( trim ( msg ( i )), i = 1 , size ( msg , 1 )) stop 'normal exit in usage' end subroutine usage ! --------------------------------------------------------------------- function sending_half ( i ) result ( l ) integer , intent ( in ) :: i logical :: l continue !  this must process np == even values only l = i <= np_half return end function sending_half ! --------------------------------------------------------------------- function to_upper_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process lower half ranks only l = i + np_half return end function to_upper_half ! --------------------------------------------------------------------- function from_lower_half ( i ) result ( l ) integer , intent ( in ) :: i integer :: l continue !  this must process upper half ranks only l = i - np_half return end function from_lower_half ! --------------------------------------------------------------------- end program psnap","tags":"","loc":"program/psnap.html","title":"psnap – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding program~~main~4~~UsesGraph program~main~4 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~4 iso_c_binding iso_c_binding iso_c_binding->program~main~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial logical :: c_char_test_passes = .false. logical :: c_double_test_passes = .false. logical :: c_int_test_passes = .false. integer(kind=c_int) :: me","tags":"","loc":"program/main~4.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding program~~main~5~~UsesGraph program~main~5 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~5 iso_c_binding iso_c_binding iso_c_binding->program~main~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"program/main~5.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding program~~main~6~~UsesGraph program~main~6 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~6 iso_c_binding iso_c_binding iso_c_binding->program~main~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial logical :: co_min_c_double_verified = .false. logical :: co_min_c_int_verified = .false.","tags":"","loc":"program/main~6.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding co_intrinsics_module program~~main~7~~UsesGraph program~main~7 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~7 iso_c_binding iso_c_binding iso_c_binding->program~main~7 module~co_intrinsics_module co_intrinsics_module module~co_intrinsics_module->program~main~7 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~main~7~~CallsGraph program~main~7 main interface~co_all co_all program~main~7->interface~co_all interface~co_product co_product program~main~7->interface~co_product proc~co_all_logical co_all_logical interface~co_all->proc~co_all_logical proc~co_product_c_int co_product_c_int interface~co_product->proc~co_product_c_int proc~co_product_c_double co_product_c_double interface~co_product->proc~co_product_c_double Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial logical :: c_int_passes = .false. logical :: logical_passes = .false.","tags":"","loc":"program/main~7.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_fortran_env iso_c_binding program~~main~8~~UsesGraph program~main~8 main iso_fortran_env iso_fortran_env iso_fortran_env->program~main~8 iso_c_binding iso_c_binding iso_c_binding->program~main~8 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial logical :: co_sum_c_double_verified = .false. logical :: co_sum_c_int_verified = .false.","tags":"","loc":"program/main~8.html","title":"main – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, allocatable :: a (:)[:] integer :: me [*]","tags":"","loc":"program/alloc_as_barrier.html","title":"alloc_as_barrier – OpenCoarrays"},{"text":"Calls program~~alloc_as_barrier~2~~CallsGraph program~alloc_as_barrier~2 alloc_as_barrier proc~test_alloc test_alloc program~alloc_as_barrier~2->proc~test_alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: me Subroutines subroutine test_alloc (me) Arguments Type Intent Optional Attributes Name integer, intent(out) :: me","tags":"","loc":"program/alloc_as_barrier~2.html","title":"alloc_as_barrier – OpenCoarrays"},{"text":"Uses: mpi program~~initialize_mpi~~UsesGraph program~initialize_mpi initialize_mpi mpi mpi mpi->program~initialize_mpi Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~initialize_mpi~~CallsGraph program~initialize_mpi initialize_mpi mpi_comm_size mpi_comm_size program~initialize_mpi->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: ierr integer :: me = -1 integer :: np = -1","tags":"","loc":"program/initialize_mpi.html","title":"initialize_mpi – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, parameter :: invalid_image_number = -1 integer, save :: me [*] = invalid_image_number","tags":"","loc":"program/register.html","title":"register – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer :: arr1 (array_size)[*] integer, parameter :: array_size = 10 integer :: np","tags":"","loc":"program/register2.html","title":"register2 – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, allocatable :: array (:)[:] integer :: array_size = 10 integer, parameter :: invalid_rank = -2 integer :: np = invalid_rank","tags":"","loc":"program/register3.html","title":"register3 – OpenCoarrays"},{"text":"Calls program~~main~9~~CallsGraph program~main~9 main proc~one one program~main~9->proc~one Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: m = 4 integer, parameter :: n = 3 Subroutines subroutine one (lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 subroutine three () Arguments None subroutine two () Arguments None Source Code program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays !  call two() !  call three() write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:), c (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & c ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = b caf = - 42 c = caf sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) call abort () endif ! Whole array: ARRAY = ARRAY caf = - 42 a = b c = caf if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 1:' , any ( a /= c ) print * , a print * , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Scalar assignment a = - 42 caf = - 42 c = caf sync all do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , lb1 , - 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do do j = lb2 , m + lb2 - 1 do i = lb1 , n + lb1 - 1 , 2 a ( i , j ) = caf ( i , j )[ num_images ()] end do end do endif sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print * , 'RES 2:' , any ( a /= c ) print * , this_image (), ': ' , a print * , this_image (), ': ' , c ! FIXME: Without the print lines above, it always fails. Why? call abort () end if endif ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 42 caf = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if ! ARRAY = ARRAY caf = - 42 a = - 42 c = a a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= c )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , c print * , a - c call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"program/main~9.html","title":"main – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, allocatable :: a (:)[:] integer, allocatable :: b (:) integer :: i integer :: me integer :: np","tags":"","loc":"program/get_offset_1d.html","title":"get_offset_1d – OpenCoarrays"},{"text":"Calls program~~main~10~~CallsGraph program~main~10 main proc~three~2 three program~main~10->proc~three~2 proc~one~2 one program~main~10->proc~one~2 proc~two~2 two program~main~10->proc~two~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: m = 4 integer, parameter :: n = 3 Subroutines subroutine one (lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 subroutine three () Arguments None subroutine two () Arguments None Source Code program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays call two () call three () write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf ( lb1 , lb2 )[ num_images ()] print * , this_image (), '//' , a , '//' , b ( lb1 , lb2 ) print * , '>>>' , any ( a /= b ( lb1 , lb2 )) if ( any ( a /= b ( lb1 , lb2 ))) then ! FIXME: ABORTS UNLESS THERE IS SOME OTHER CODE print * , 'HELLO!!!!!!!!!!!!!!!!!' call abort () end if end if ! Whole array: ARRAY = ARRAY a = - 42 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then a (:,:) = caf (:,:)[ num_images ()] if ( any ( a /= b )) & !FIXME print * , a print * , b print * , 'WRONG:' , any ( a /= b ) call abort () end if end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 caf = - 42 if ( this_image () == num_images ()) then caf = b endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !\t\t      b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !\t\t\t   = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY b = - 32 a = - 12 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            =caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                     if (any (a /= b)) then !                       print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                            lb2,\":\",m+lb2-1 !                       print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                            \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                       print *, i !                       print *, a !                       print *, caf !                       print *, a-caf !                       call abort() !                     endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf ( lb1 , lb2 )[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Whole array: ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b (:,:) = caf (:,:)[ num_images ()] end if sync all if ( this_image () == 1 ) then if ( any ( a /= b )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = caf ( lb1 , lb2 )[ num_images ()] end if sync all ! ARRAY = ARRAY a = - 12 b = - 32 if ( this_image () == num_images ()) then caf = a else caf = - 42 endif sync all if ( this_image () == 1 ) then !                       b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) & !                            = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] end if sync all if ( this_image () == 1 ) then !                      if (any (a /= b)) then !                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", & !                             lb2,\":\",m+lb2-1 !                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, & !                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2 !                        print *, i !                        print *, a !                        print *, caf !                        print *, a-caf !                        call abort() !                      endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"program/main~10.html","title":"main – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer, codimension[*] :: a integer, dimension(10), codimension[*] :: b integer, dimension(10), codimension[*] :: c integer :: i integer :: j integer, dimension(9,10), codimension[*] :: m integer, dimension(10) :: t","tags":"","loc":"program/sameloc.html","title":"sameloc – OpenCoarrays"},{"text":"Calls program~~main~11~~CallsGraph program~main~11 main proc~three~3 three program~main~11->proc~three~3 proc~one~3 one program~main~11->proc~one~3 proc~two~3 two program~main~11->proc~two~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, parameter :: m = 4 integer, parameter :: n = 3 Subroutines subroutine one (lb1, lb2) Arguments Type Intent Optional Attributes Name integer, , value :: lb1 integer, , value :: lb2 subroutine three () Arguments None subroutine two () Arguments None Source Code program main implicit none integer , parameter :: n = 3 integer , parameter :: m = 4 ! Allocatable coarrays call one ( - 5 , 1 ) call one ( 0 , 0 ) call one ( 1 , - 5 ) call one ( 0 , - 11 ) ! Static coarrays call two () call three () write ( * , * ) 'Test passed' contains subroutine one ( lb1 , lb2 ) integer , value :: lb1 , lb2 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , allocatable :: caf (:,:)[:] integer , allocatable :: a (:,:), b (:,:) allocate ( caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ], & a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ), & b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine one subroutine two () integer , parameter :: lb1 = - 5 , lb2 = 1 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine two subroutine three () integer , parameter :: lb1 = 0 , lb2 = 0 integer :: i_sgn1 , i_sgn2 , i , i_e , i_s , j , j_e , j_s integer , save :: caf ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 )[ * ] integer , save :: a ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) integer , save :: b ( lb1 : n + lb1 - 1 , lb2 : m + lb2 - 1 ) b = reshape ([( i * 33 , i = 1 , size ( b ))], shape ( b )) ! Whole array: ARRAY = SCALAR caf = - 42 a = - 42 a (:,:) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b ( lb1 , lb2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Whole array: ARRAY = ARRAY caf = - 42 a = - 42 a (:,:) = b (:, :) sync all if ( this_image () == 1 ) then caf (:,:)[ num_images ()] = b (:, :) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Scalar assignment caf = - 42 a = - 42 do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 a ( i , j ) = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 a ( i , j ) = b ( i , j ) end do end do sync all if ( this_image () == 1 ) then do j = lb2 , m + lb2 - 1 do i = n + lb1 - 1 , 1 , - 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do do j = lb2 , m + lb2 - 1 do i = 1 , n + lb1 - 1 , 2 caf ( i , j )[ num_images ()] = b ( i , j ) end do end do end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) & call abort () end if ! Array sections with different ranges and pos/neg strides do i_sgn1 = - 1 , 1 , 2 do i_sgn2 = - 1 , 1 , 2 do i = lb1 , n + lb1 - 1 do i_e = lb1 , n + lb1 - 1 do i_s = 1 , n do j = lb2 , m + lb2 - 1 do j_e = lb2 , m + lb2 - 1 do j_s = 1 , m ! ARRAY = SCALAR caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) = b ( lb1 , lb2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( lb1 , lb2 ) end if sync all ! ARRAY = ARRAY caf = - 42 a = - 42 a ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) sync all if ( this_image () == 1 ) then caf ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 )[ num_images ()] & = b ( i : i_e : i_s * i_sgn1 , j : j_e : j_s * i_sgn2 ) end if sync all if ( this_image () == num_images ()) then if ( any ( a /= caf )) then print '(*(g0))' , \"bounds: \" , lb1 , \":\" , n + lb1 - 1 , \", \" , & lb2 , \":\" , m + lb2 - 1 print '(*(g0))' , \"section: \" , i , \":\" , i_e , \":\" , i_s * i_sgn1 , & \", \" , j , \":\" , j_e , \":\" , j_s * i_sgn2 print * , i print * , a print * , caf print * , a - caf call abort () endif end if end do end do end do end do end do end do end do end do end subroutine three end program main","tags":"","loc":"program/main~11.html","title":"main – OpenCoarrays"},{"text":"Uses: iso_c_binding program~~strided_get~~UsesGraph program~strided_get strided_get iso_c_binding iso_c_binding iso_c_binding->program~strided_get Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer, allocatable :: a (:,:,:,:)[:] complex(kind=DPC), allocatable :: ac (:,:,:,:)[:] integer, allocatable :: b (:,:,:,:) complex(kind=DPC), allocatable :: bc (:,:,:,:) integer :: i integer :: me integer :: np","tags":"","loc":"program/strided_get.html","title":"strided_get – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer :: i integer :: j integer :: k integer :: me integer, parameter :: n = 10 integer :: np integer, allocatable :: x1 (:)[:] integer, allocatable :: x2 (:,:)[:] integer, allocatable :: x3 (:,:,:)[:] integer, allocatable :: y1 (:) integer, allocatable :: y2 (:,:) integer, allocatable :: y3 (:,:,:) Source Code program whole_array_get implicit none integer , allocatable :: x1 (:)[:], y1 (:) integer , allocatable :: x2 (:,:)[:], y2 (:,:) integer , allocatable :: x3 (:,:,:)[:], y3 (:,:,:) integer , parameter :: n = 10 integer :: me , np , i , j , k me = this_image () np = num_images () allocate ( x1 ( n )[ * ], y1 ( n )) x1 = me y1 = 0 sync all if ( me == 1 ) then y1 = x1 (:)[ me + 1 ] if ( any ( y1 /= 2 )) then write ( * , * ) 'Test 1 fails' call abort () end if end if deallocate ( x1 ) allocate ( x2 ( 1 : n , 0 : n - 1 )[ * ], y2 ( n , n )) x2 = me y1 = 0 ; y2 = 0 sync all if ( me == 1 ) then y2 = x2 (:,:)[ np ] if ( any ( y2 /= np )) then write ( * , * ) 'Test 2 fails' call abort () end if end if sync all x2 (:, n / 2 ) = x2 (:, n / 2 ) + n / 2 sync all if ( me == 1 ) then y1 = x2 (:, n / 2 )[ me + 1 ] if ( any ( y1 /= 2 + n / 2 )) then write ( * , * ) 'Test 3 fails' call abort () end if end if deallocate ( y1 , x2 , y2 ) allocate ( x3 ( 0 : n - 1 , 1 : n , - 1 : n - 2 )[ * ], y3 ( n , n , n )) x3 = me ; y3 = 0 sync all if ( me == 1 ) then y3 = x3 (:,:,:)[ me + 1 ] if ( any ( y3 /= me + 1 )) then write ( * , * ) 'Test 4 fails' call abort () end if endif sync all x3 (:,:, n / 2 ) = me + n / 2 y3 = 0 sync all if ( me == 1 ) then y3 (:, n / 2 ,:) = x3 (:,:, n / 2 )[ me + 1 ] if ( any ( y3 (:, n / 2 ,:) /= me + 1 + n / 2 )) then write ( * , * ) 'Test 5 fails' call abort () end if endif if ( me == 1 ) write ( * , * ) 'Test passed.' end program whole_array_get","tags":"","loc":"program/whole_array_get.html","title":"whole_array_get – OpenCoarrays"},{"text":"Calls program~~syncimages~~CallsGraph program~syncimages syncimages images images program~syncimages->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: me integer :: ne integer :: p [*] = 0 logical :: test [*] = .true.","tags":"","loc":"program/syncimages.html","title":"syncimages – OpenCoarrays"},{"text":"Calls program~~syncimages2~~CallsGraph program~syncimages2 syncimages2 images images program~syncimages2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"program/syncimages2.html","title":"syncimages2 – OpenCoarrays"},{"text":"Calls program~~test1caf~~CallsGraph program~test1caf test1caf images images program~test1caf->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: a (num_local_elems)[*] = a_initial integer, parameter :: a_initial = 1 integer :: b (num_local_elems)[*] = b_initial integer, parameter :: b_initial = 2 integer :: i integer :: left integer :: me integer :: np integer, parameter :: num_local_elems = 3 integer :: right Source Code program test1caf implicit none integer , parameter :: num_local_elems = 3 , a_initial = 1 , b_initial = 2 integer :: a ( num_local_elems )[ * ] = a_initial , b ( num_local_elems )[ * ] = b_initial integer :: i , me , np , left , right me = this_image () np = num_images () left = merge ( np , me - 1 , me == 1 ) right = merge ( 1 , me + 1 , me == np ) if ( mod ( me , 2 ). eq . 0 ) then a (:)[ right ] = a (:)[ right ] + me else b (:)[ left ] = b (:)[ left ] + me end if if ( me == 1 ) then write ( * , * ) me , a , b else sync images ( me - 1 ) write ( * , * ) me , a , b end if if ( me < np ) sync images ( me + 1 ) if ( mod ( me , 2 ). eq . 0 ) then if ( any ( a (:)[ right ] /= a_initial + me )) error stop \"Test failed.\" else if ( any ( b (:)[ left ] /= b_initial + me )) error stop \"Test failed.\" end if if ( me == 1 ) print * , \"Test passed.\" end program test1caf","tags":"","loc":"program/test1caf.html","title":"test1caf – OpenCoarrays"},{"text":"Uses: iso_fortran_env program~~atomic~~UsesGraph program~atomic atomic iso_fortran_env iso_fortran_env iso_fortran_env->program~atomic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer(kind=atomic_int_kind) :: atom [*] integer :: me integer :: np integer :: res","tags":"","loc":"program/atomic.html","title":"atomic – OpenCoarrays"},{"text":"Calls program~~duplicate_syncimages~~CallsGraph program~duplicate_syncimages duplicate_syncimages images images program~duplicate_syncimages->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: array (4) integer :: i integer :: me integer :: stat = 0","tags":"","loc":"program/duplicate_syncimages.html","title":"duplicate_syncimages – OpenCoarrays"},{"text":"Variables Type Attributes Name Initial integer :: i integer :: me integer :: np integer :: scalar [*] Source Code program syncall implicit none integer :: me , np , i integer :: scalar [ * ] me = this_image () np = num_images () scalar = - 1 if ( me /= 1 ) call sleep ( 1 ) scalar = 1 sync all if ( me == 1 ) then do i = 1 , np if ( scalar [ i ] /= 1 ) then write ( * , * ) 'Test failed.' stop endif end do end if if ( me == 1 ) print * , 'Test passed.' end program syncall","tags":"","loc":"program/syncall.html","title":"syncall – OpenCoarrays"},{"text":"Calls program~~syncimages~2~~CallsGraph program~syncimages~2 syncimages images images program~syncimages~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: i integer :: me integer :: ne integer :: p [*] = 0 logical :: test [*] = .true.","tags":"","loc":"program/syncimages~2.html","title":"syncimages – OpenCoarrays"},{"text":"Calls program~~syncimages2~2~~CallsGraph program~syncimages2~2 syncimages2 images images program~syncimages2~2->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"program/syncimages2~2.html","title":"syncimages2 – OpenCoarrays"},{"text":"Uses: iso_fortran_env program~~sync_images_stat~~UsesGraph program~sync_images_stat sync_images_stat iso_fortran_env iso_fortran_env iso_fortran_env->program~sync_images_stat Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Calls program~~sync_images_stat~~CallsGraph program~sync_images_stat sync_images_stat images images program~sync_images_stat->images Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Type Type Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Where possible, edges connecting nodes are given different colours to make them\neasier to distinguish in large graphs. Module Graph Solid arrows point from a parent (sub)module to the submodule which is\ndescended from it. Dashed arrows point from a module being used to the\nmodule using it. Type Graph Solid arrows point from one derived type to another which extends\n(inherits from) it. Dashed arrows point from a derived type to another\ntype containing it as a components, with a label listing the name(s) of\nsaid component(s). Call Graph Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial integer :: me integer :: stat_var = 0 Source Code program sync_images_stat use , intrinsic :: iso_fortran_env implicit none integer :: stat_var = 0 , me me = this_image () if ( me /= 1 ) then call sleep ( 1 ) sync images ( * , STAT = stat_var ) if ( stat_var /= STAT_STOPPED_IMAGE ) then print * , \"Error:stat_var /= STAT_STOPPED_IMAGE: \" , me ERROR STOP 1 end if if ( me == 2 ) print * , 'Test passed.' end if end program sync_images_stat","tags":"","loc":"program/sync_images_stat.html","title":"sync_images_stat – OpenCoarrays"}]}