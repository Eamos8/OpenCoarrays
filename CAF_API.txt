DRAFT DOCUMENT FOR A COARRAY API DEFINTION

NOTE: The actual function names will have some PREFIX to avoid name clashes.
This prefix can be vendor specific.


Content
0  TODO
1  Implementation status
2  Description of defines and types used in the API
3  Description of the functions provided by the API


0  TODO

- Discuss the current draft
- Add missing functions of the current gfortran implementation
- Address the TODO items
- Extend the functions to match a sensible set
- Update the implementation status, especially for the ARMCI library



1  Implementation status

The library implementation in this directory should be API compatible
with the wording below, except for some "int errmsg_len" vs. size_t
changes which have not yet been done.

gfortran development is done in GCC's fortran-caf branch and should
also match - with the same exception - the API described here.

In both cases, the implementations might be stubs and not fully
working or not fully adhering  and should
also match - with the same exception - the API described here.

In both cases, the implementations might be stubs and not fully
working or not fully adhering to the specification. See also individual
notes below.



2  Description of defines and types used in the API


2.1  caf_token_t

Typedef of type "void *" on the compiler side. Can be any data
type on the library side.


2.2  caf_register_t

Type used to distinguish different kinds of allocations.

typedef enum caf_register_t {
  CAF_REGTYPE_COARRAY_STATIC,
  CAF_REGTYPE_COARRAY_ALLOC,
  CAF_REGTYPE_LOCK,
}
caf_register_t;

TODO:
  Check whether this set is complete and makes sense

2.3  caf_token_t

In terms of the processor, some opaque pointer, which is used to identify a
coarray.  The exact content is implementation defined by the library.


2.4  Stat values

#define STAT_UNLOCKED           0
#define STAT_LOCKED             1
#define STAT_LOCKED_OTHER_IMAGE 2
#define STAT_STOPPED_IMAGE      6000

TODO:
  Define more, allow room for lib-specific values, update for TS18508.
  Do we need to take care of special vendor choices?
  Note: Some values have to be such that they differ from certain other
  values.



3. Description of the API functions


3.1  Initialization function

     void caf_init (int *argc, char ***argv)

This function shall be called at startup of the program before the Fortran main
program.  It takes as arguments the command-line arguments of the program. The
library is permitted to change the arguments.  It is permitted to pass to
NULL pointers as argument.

Arguments: 
  argc  intent(inout) An integer pointer with the number of arguments
        passed to the program, or NULL.
  argv  intent(inout) A pointer to an array of strings with the
        command-line arguments.

NOTE: 
  The function is modelled after the initialization function of the MPI
  (Message Passing Interface) specification.  Due to the way coarray
  registration (3.5) works, it might not be the first call to the libaray. If
  the main program is not written in Fortran and only a library uses coarrays,
  it can happen that this function is never called.  Therefore, it is
  recommended that the library does not rely on the passed arguments and whether
  the call has been done.

GCC:
  In gfortran, the function is generated when the Fortran main program is
  compiled with -fcoarray=lib; the call happens before the run-time library
  initialiation such that changes to the command-line arguments will be visible
  when the command-line intrinsics are invoked.
  NOTE: The Fortran-caf branch uses this implementation.
  GCC 4.x uses a four-argument version.


3.2  Finalization function

     void caf_finish (void)

This function shall be called at the end of the program to permit a graceful
shutdown.

NOTE:
  It is recommended to add this call at the end of the Fortran main program.
  To ensure that the shutdown is also performed for programs where this function
  is not explicitly invoked, for instance non-Fortran programs or calls to the
  system's exit() function, the library can use a destructor function.
  Note that programs can also be terminated using the STOP and ERROR STOP
  statements; those use different library calls.

GCC:
  In gfortran, this function is called at the end of the Fortran main program,
  if it has been compiled with the -fcoarray=lib option.



3.3 Querying the image number

    int caf_this_image (int distance)

This function returns the current image number, which is a positive number.

Argument:
  distance   As specified for the this_image intrinsic in TS18508. Shall be a
             nonnegative number.
NOTE:
  If the Fortran intrinsic this_image() is invoked without an argument, which
  is the only permitted form in Fortran 2008, the processer shall pass a 0 as
  first argument.

GCC:
  Fortran-caf uses this function. Not called in GCC 4.x.



3.4 Querying the maximal number of images

    int caf_num_images(int distance, int failed)

This function returns the number of images in the current team, if distance is 0
or the number of images in the parent team at the specified distance. If failed
is is -1, the function returns the number of all images at the specified
distance; if it is 0, the function returns the number of nonfailed images, and
if it is 1, it returns the number of failed images.

Arguments:
  distance  the distance from this image to the ancestor. Shall be positive.
  failed    shall be -1, 0, or 1

NOTE:
  This function follows TS18508. If the num_image intrinsic has no arguments,
  the processor shall pass distance=0 and failed=-1 to the function.

GCC:
  Fortran-caf uses this function. Not called in GCC 4.x.



3.5 Registering coarrays

    void *caf_register (size_t size, caf_register_t type, caf_token_t *token,
                        int *stat, char *errmsg, size_t errmsg_len);

Allocates memory for a coarray and creates a token to identify the coarray. The
function is called for both coarrays with SAVE attribute and using an explicit
ALLOCATE statement. If an error occurs and STAT is a NULL pointer, the function
shall abort with printing an error message and starting the error termination.
If no error occurs and STAT= is present, it shall be set to zero. If an error
is 

Arguments:
  size   byte size of the array to be allocated
  type   one of the caf_register_t types. Possible values:
         CAF_REGTYPE_COARRAY_STATIC - for nonallocatable coarrays
         CAF_REGTYPE_COARRAY - for allocatable coarrays
         CAF_REGTYPE_LOCK - for lock variables 
  token  intent(out) An opaque pointer identifying the coarray.
  stat   intent(out) For allocatable coarrays, stores the STAT=; may be NULL
  errmsg intent(out) When an error occurs, this will be set to an error
         message, may be NULL
  errmgs_len the buffersize of errmsg.

TODO:
  - Check whether the locking should be handled like that and whether one needs
  more, e.g. for locking types in DT?
  - Check whether one needs an additional function for to register coarrays
  which are in static memory and used without memory allocation, i.e. just to
  register the address.
  - Check whether we need an explicit SYNC ALL at the beginning of the main
  program or whether we can do without.
  - Does TS18508 require more for SAVE within teams or within blocks?

NOTE:
  Nonalloatable coarrays have to be registered prior use from remote images.
  In order to guarantee this, they have to be registered before the main
  program. This can be achieved by creating constructor functions.  When using
  caf_register, also nonallocatable coarrays the memory is allocated and no
  static memory is used.
  The token permits to identify the coarray; to the processor, the token is a
  nonaliasing pointer. The library can, for instance, store the base address
  of the coarray in the token, some handle or a more complicated struct.
  The function shall finish 

GCC:
  Implemented. However, it currently uses an INT and not a SIZE_T for the
  string length.



3.6  Deregistering coarrays

    void caf_deregister (const caf_token_t *token, int *stat, char *errmsg,
                         size_t errmsg_len);

Called for free the memory of a coarray; the processor calls this function for
automatic and explicit deallocation.  In case of an error, this function shall
fail with an error message, unless the STAT= variable is not null.

Arguments:
  token  intent(inout) An opaque pointer identifying the coarray.
  stat   intent(out) For allocatable coarrays, stores the STAT=; may be NULL
  errmsg intent(out) When an error occurs, this will be set to an error
         message, may be NULL
  errmgs_len the buffersize of errmsg.

NOTE:
  The implementation is permitted to set the token to NULL. However, it is
  not required to do so.
GCC:
  Implemented. Currently uses an int instead of size_t for the string length.



3.7  Sending data from a local image to a remote image


3.7.1 Sending a scalar (contiguous memory) from a local to remote image

   void caf_send (const caf_token_t token, size_t offset, int image_id,
                  void *data, size_t size, bool async)

Called to send a scalar or contiguous section of an array to another image,
identified by the image_index.

Arguments:
  token  intent(in)  An opaque pointer identifying the coarray.
  offset  By which amount of bytes the actual data is shifted compared to
          the base address of the coarray.
  image_id  The ID of the remote image; must be a positive number.
  data  Address of the data, which shall be sent
  size  Amount of bytes to be transmitted
  async When true, the sending is done asynchronously.

NOTE:
  It is permitted to have image_id == current image. Additionally, the memory
  of the send-to and the send-from might (partially) overlap in that case. The
  implementation has to take care that it handles this case.
GCC:
  (Partially) implemented on the Fortran-caf branch. The communication is
  currently always synchronous.
TODO:
  How to handle asynchronous communication. Shall one return a handle, which
  can be optionally used as handle for a wait command?


3.7.2 Sending an array from a local to remote image

   void caf_send_desc (caf_token_t token, size_t offset,
                       int image_id, gfc_descriptor_t *dest,
                       gfc_descriptor_t *src,
                       bool asyn)

Called to send an array section or whole array from a local to a remote
image identified by the image_index.

Arguments:
  token  intent(in)  An opaque pointer identifying the coarray.
  offset  By which amount of bytes the actual data is shifted compared to
          the base address of the coarray.
  image_id  The ID of the remote image; must be a positive number.
  dest    intent(in) Array descriptor for the remote image for the bounds
          and the size. The base_addr shall not be accessed.
  src     intent(in) Array descriptor of the local array to be transferred
          to the remote image
  async When true, the sending is done asynchronously.


NOTE:
  It is permitted to have image_id == current image. Additionally, the memory
  of the send-to and the send-from might (partially) overlap in that case. The
  implementation has to take care that it handles this case.
GCC:
  (Partially) implemented on the Fortran-caf branch. The communication is
  currently always synchronous.



3.7.3 Sending a scalar from a local to remote-image array

   void caf_send_desc_scalar (caf_token_t token, size_t offset,
                              int image_id, gfc_descriptor_t *dest,
                              void *buffer, bool asyn)

Called when assigning a scalar of the local image to an array of the
remote image, identified by the image_index.

Arguments:
  token  intent(in)  An opaque pointer identifying the coarray.
  offset  By which amount of bytes the actual data is shifted compared to
          the base address of the coarray.
  image_id  The ID of the remote image; must be a positive number.
  dest    intent(in) Array descriptor for the remote image for the bounds
          and the size. The base_addr shall not be accessed.
  buffer  intent(in) The values used for the assignment; the buffer size
          must match the element size obtained from the "dest" buffer.
  async When true, the sending is done asynchronously.

NOTE:
  It is permitted to have image_id == current image. Additionally, the memory
  of the send-to and the send-from might (partially) overlap in that case. The
  implementation has to take care that it handles this case.
GCC:
  (Partially) implemented on the Fortran-caf branch. The communication is
  currently always synchronous.



TODO FOR SEND*:
  - Wait is missing
  - Array section, array vector sections, scalar assignment to arrays
  - Assignment to an address instead of using a token, to handle
    caf[i]%allocatable%alloc_array(:,:) = ...
    Or some other means to handle those.
  - Image index: How to handle references to other TEAMS?

OTHER TODOs:
3.x TODO: Handle GET and remote-to-remote communication
3.y TODO: Handle ATOMIC, LOCK, CRITICAL
3.z TODO Teams and error recovery



3.8  All-Image Barrier

   void caf_sync_all (int *stat, char *errmsg, size_t errmsg_len)

Barrier which waits for all other images, pending asynchronous communication
and other data transfer.

Arguments:
  stat  Status variable, if NULL, failures are fatal. If nonnull, assigned 0
        on success, and a stat code (cf. 2.3) in case of an error.
  errmsg  If not NULL: Ignored unless stat is present; unmodified when
          successful, otherwise, an error message is copied into the variable.
  errmsg_len  Maximal length of the error string, which is not '\0' terminated.
          The string should be padded by blanks.

Note:
  For portability, consider only using 7bit ASCII characters in the error
  message.
GCC:
  Implemented in GCC 4.x using an int argument for the length.
  Currently, size_t is not implemented.



3.9  Barrier for Selected Images

   void sync_images (int count, int images[], int *stat,
                     char *errmsg, size_t errmsg_len)

Arguments:
  count Size of the array "images"; has value -1 for 'sync images(*)' and
        value 0 for a zero-sized array.
  image  list of images to be synced with.
  stat  Status variable, if NULL, failures are fatal. If nonnull, assigned 0
        on success, and a stat code (cf. 2.3) in case of an error.
  errmsg  If not NULL: Ignored unless stat is present; unmodified when
          successful, otherwise, an error message is copied into the variable.
  errmsg_len  Maximal length of the error string, which is not '\0' terminated.
          The string should be padded by blanks.

Note:
  For portability, consider only using 7bit ASCII characters in the error
  message. Note that the list can contain also the ID of this image or can be
  an empty set. Example use is that image 1 syncs with all others (i.e "sync
  images(*)") and the others sync only with that image ("sync image(1)"). Or
  for point-to point communication (sync image([left_image, right_image]).

GCC:
  Implemented in GCC 4.x using an int argument for the error-string length.
  Currently, size_t is not implemented.



3.10  Error abort

   void error_stop_str (const char *string, int32_t str_len)
   void error_stop (int32_t exit_error_code)

TODO
  - Fix this description by filling-in the missing bits
  - STOP vs ERROR STOP handling. Currently, STOP calls "finalize" and then the
    normal STOP while for ERROR STOP directly calls the library 
  - F2008 requires that one prints the raised exceptions with STOP and ERROR
    STOP. libgfortran's STOP and ERROR STOP do so - the current implementation
    for ERROR STOP does not.
