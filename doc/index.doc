/*! \mainpage OpenCoarrays
\htmlonly
\endhtmlonly

\section Outline 
<ul>
  <li>\ref overview
  <li>\ref transport_layers 
  <ul>
    <li>\ref LIBCAF_MPI
  </ul>
  <ul>
    <li>\ref LIBCAF_GASNet
  </ul>
  <ul>
    <li>\ref LIBCAF_ARMCI
  </ul>
  <ul>
    <li>\ref LIBCAF_OpenSHMEM
  </ul>
  <ul>
    <li>\ref LIBCAF_SINGLE
  </ul>
  <li>\ref compatible_compilers
  <li>\ref example
</ul>

\section overview Overview
This archive contains the <A href=http://www.opencoarrays.org>OpenCoarrays</A> source code, tests, and documentation. OpenCoarrays is an open-source transport layer for compilers that support the coarray parallel programming features of Fortran 2008 and 2015.  OpenCoarrays-compatible compilers make high-level communication and synchronization requests to OpenCoarrays, which translates the requests into lower-level calls to a user-specified communication library.  A user of an OpenCoarrays-compatible compiler can link compiler-generated object files to the communication library deemed most appropriate and efficient for the target application and platform.  Currently supported communication libraries include the Message Passing Interface (<A href=http://www.mpi-forum.org>MPI</A>)  and the Global Address Space Network (<A href=http://gasnet.lbl.gov>GASNet</A>).  We are evaluating the feasibility and benefits of adding support for the Aggregate Remote Memory Copy Interface (<A href=http://hpc.pnl.gov/armci/>ARMCI</A>) and for <A href=http://www.openshmem.org>OpenSHMEM</A>.

\section transport_layers Transport Layers
\subsection LIBCAF_MPI
We intend for the MPI transport layer to be the default implementation on most platforms.  It has the widest features coverage and is the easiest to install and use.  OpenCoarrays will detect the MPI version and build a transport layer for the  appropriate MPI version.

The preferred MPI standard is MPI 3.0 or later.  To support legacy systems, we will also provide for using MPI 2.0.  The MPI 2.0 transport layer is, however, more complex and thus more difficult to maintain and might therefore become unsupported eventually.  

\subsection LIBCAF_GASNet
The GASNet transport layer targets expert users.  It provides better performance than the MPI layer, but it requires more effort to install and use.

\subsection LIBCAF_ARMCI
This library is incomplete and not yet supported.

\subsection LIBCAF_OpenSHMEM
We do not yet provide an OpenSHMEM transport layer.  We expect to evaluate the utility and performance of OpenSHMEM for supporting coarray Fortran soon.

\subsection LIBCAF_SINGLE
This library provides stub implementations for use with programs that run in one image only.  LIBCAF_SINGLE is useful for debugging purposes in order to isolate problems related to the compiler versus the transport layer or communication library.

\section compatible_compilers Compatible Compilers
The pre-release GNU Fortran (GFortran ) compiler version 4.10 (which will likely be reversioned to 5.0 before release) links to OpenCoarrays.  If you would like to use OpenCoarrays with another compiler, please let the compiler vendor and the OpenCoarrays team know.

\section example Example
Fortran application developers not need understand the mechanics of using OpenCoarrays beyond building the desired transport layer and linking it into executables that use coarrays.  In the intended use case, Fortran programs never directly reference OpenCoarrays procedures.  We provide the following OpenCoarrays example for the benefit of compiler developers.  This example coarray Fortran program sends the local elements of an array coarray from image 1 to image 2:

\verbatim
program sendrecv
  use iso_fortran_env
  implicit none

  integer :: me, np, i
  integer, parameter :: n=1000
  real(kind=real64), allocatable :: d(:)[:]

  allocate(d(n)[*])
  
  np = num_images()
  me = this_image()

  do i=1,n
     d(i) = i
  enddo

  sync all

  if(me == 1) d(:)[2] = d

  sync all
  
  deallocate(d)
end program
\endverbatim
A compiler might generate the follwoing code to translate the above code into calls to an OpenCoarrays transport layer:
\verbatim
sendrecv ()
{
  struct array2_real(kind=8) d;
  integer(kind=4) i;
  integer(kind=4) me;
  integer(kind=4) np;

  d.data = 0B;
  {
    integer(kind=4) overflow.0;

    overflow.0 = 0;
    if (overflow.0 != 0)
      {
        _gfortran_runtime_error (&"Integer overflow when calculating the amount of memory to allocate"[1]{lb: 1 sz: 1});
      }
    else
      {
        if (d.data != 0B)
          {
            _gfortran_runtime_error_at (&"At line 9 of file coarray.f90"[1]{lb: 1 sz: 1}, &"Attempting to allocate already allocated variable \'%s\'"[1]{lb: 1 sz: 1}, &"d"[1]{lb: 1 sz: 1});
          }
        else
          {
            d.data = (void * restrict) _gfortran_caf_register (8000, 1, &d.token, 0B, 0B, 0);
          }
      }
    d.dtype = 537;
    d.dim[0].lbound = 1;
    d.dim[0].ubound = 1000;
    d.dim[0].stride = 1;
    d.dim[1].lbound = 1;
    d.offset = -1;
    np = _gfortran_caf_num_images (0, -1);
    me = _gfortran_caf_this_image (0);
    i = 1;
    if (i <= 1000)
      {
        while (1)
          {
            {
              logical(kind=4) D.2368;

              (*(real(kind=8)[0:] * restrict) d.data)[d.offset + (integer(kind=8)) i] = (real(kind=8)) i;
              L.1:;
              D.2368 = i == 1000;
              i = i + 1;
              if (D.2368) goto L.2;
            }
          }
      }
    L.2:;
    __sync_synchronize ();
    _gfortran_caf_sync_all (0B, 0B, 0);
    if (me == 1)
      {
        _gfortran_caf_send (d.token, 0, 3 - (integer(kind=4)) d.dim[1].lbound, &d, 0B, &d, 8, 8);
      }
    L.3:;
    __sync_synchronize ();
    _gfortran_caf_sync_all (0B, 0B, 0);
    if (d.data == 0B)
      {
        _gfortran_runtime_error_at (&"At line 24 of file coarray.f90"[1]{lb: 1 sz: 1}, &"Attempt to DEALLOCATE unallocated \'%s\'"[1]{lb: 1 sz: 1}, &"d"[1]{lb: 1 sz: 1});
      }
    else
      {
        _gfortran_caf_deregister (&d.token, 0B, 0B, 0);
      }
    d.data = 0B;
  }
}


main (integer(kind=4) argc, character(kind=1) * * argv)
{
  static integer(kind=4) options.1[9] = {68, 1023, 0, 0, 1, 1, 0, 0, 31};

  _gfortran_caf_init (&argc, &argv);
  _gfortran_set_args (argc, argv);
  _gfortran_set_options (9, &options.1[0]);
  sendrecv ();
  __sync_synchronize ();
  _gfortran_caf_finalize ();
  return 0;
}

\endverbatim
\htmlonly
\endhtmlonly
*/

